{"version":3,"sources":["turbopack:///[project]/node_modules/base64-js/index.js","turbopack:///[project]/lib/pdfStorage.ts"],"sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/**\n * In-memory storage for PDF documents\n * Stores PDFs temporarily for conversion operations\n * \n * Note: This is a simple in-memory solution. For production,\n * consider using Redis, S3, or a database.\n */\n\ninterface StoredPDF {\n  buffer: Buffer;\n  fileName: string;\n  uploadedAt: Date;\n}\n\n// In-memory storage Map\nconst pdfStorage = new Map<string, StoredPDF>();\n\n// Cleanup interval (remove PDFs older than 24 hours)\nconst CLEANUP_INTERVAL = 60 * 60 * 1000; // 1 hour (check every hour)\nconst MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours (keep PDFs for 24 hours)\n\n// Periodic cleanup\nif (typeof setInterval !== 'undefined') {\n  setInterval(() => {\n    const now = new Date();\n    for (const [id, pdf] of pdfStorage.entries()) {\n      const age = now.getTime() - pdf.uploadedAt.getTime();\n      if (age > MAX_AGE) {\n        console.log(`üóëÔ∏è  Cleaning up old PDF: ${id} (${pdf.fileName})`);\n        pdfStorage.delete(id);\n      }\n    }\n  }, CLEANUP_INTERVAL);\n}\n\n/**\n * Store a PDF in memory\n */\nexport function storePDF(documentId: string, buffer: Buffer, fileName: string): void {\n  console.log(`üíæ Storing PDF: ${documentId} (${fileName}, ${buffer.length} bytes)`);\n  pdfStorage.set(documentId, {\n    buffer,\n    fileName,\n    uploadedAt: new Date(),\n  });\n}\n\n/**\n * Retrieve a stored PDF\n */\nexport function getPDF(documentId: string): { buffer: Buffer; fileName: string } | null {\n  const stored = pdfStorage.get(documentId);\n  if (!stored) {\n    console.log(`‚ùå PDF not found: ${documentId}`);\n    return null;\n  }\n  console.log(`‚úÖ Retrieved PDF: ${documentId} (${stored.fileName}, ${stored.buffer.length} bytes)`);\n  return {\n    buffer: stored.buffer,\n    fileName: stored.fileName,\n  };\n}\n\n/**\n * Delete a stored PDF\n */\nexport function deletePDF(documentId: string): boolean {\n  const deleted = pdfStorage.delete(documentId);\n  if (deleted) {\n    console.log(`üóëÔ∏è  Deleted PDF: ${documentId}`);\n  }\n  return deleted;\n}\n\n/**\n * Get storage statistics\n */\nexport function getStorageStats(): { count: number; totalSize: number } {\n  let totalSize = 0;\n  for (const pdf of pdfStorage.values()) {\n    totalSize += pdf.buffer.length;\n  }\n  return {\n    count: pdfStorage.size,\n    totalSize,\n  };\n}\n\n"],"names":[],"mappings":"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","ignoreList":[0]}