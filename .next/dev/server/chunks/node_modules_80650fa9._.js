module.exports = [
"[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/uuid/dist/esm-node/rng.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>rng
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomFillSync(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
}),
"[project]/node_modules/uuid/dist/esm-node/regex.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
}),
"[project]/node_modules/uuid/dist/esm-node/validate.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/regex.js [app-route] (ecmascript)");
;
function validate(uuid) {
    return typeof uuid === 'string' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$regex$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].test(uuid);
}
const __TURBOPACK__default__export__ = validate;
}),
"[project]/node_modules/uuid/dist/esm-node/stringify.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__,
    "unsafeStringify",
    ()=>unsafeStringify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/validate.js [app-route] (ecmascript)");
;
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Stringified UUID is invalid');
    }
    return uuid;
}
const __TURBOPACK__default__export__ = stringify;
}),
"[project]/node_modules/uuid/dist/esm-node/v1.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/rng.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/stringify.js [app-route] (ecmascript)"); // **`v1()` - Generate time-based UUID**
;
;
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])();
        if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
                seedBytes[0] | 0x01,
                seedBytes[1],
                seedBytes[2],
                seedBytes[3],
                seedBytes[4],
                seedBytes[5]
            ];
        }
        if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(let n = 0; n < 6; ++n){
        b[i + n] = node[n];
    }
    return buf || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["unsafeStringify"])(b);
}
const __TURBOPACK__default__export__ = v1;
}),
"[project]/node_modules/uuid/dist/esm-node/parse.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/validate.js [app-route] (ecmascript)");
;
function parse(uuid) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Invalid UUID');
    }
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
const __TURBOPACK__default__export__ = parse;
}),
"[project]/node_modules/uuid/dist/esm-node/v35.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DNS",
    ()=>DNS,
    "URL",
    ()=>URL,
    "default",
    ()=>v35
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/stringify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/parse.js [app-route] (ecmascript)");
;
;
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for(let i = 0; i < str.length; ++i){
        bytes.push(str.charCodeAt(i));
    }
    return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === 'string') {
            value = stringToBytes(value);
        }
        if (typeof namespace === 'string') {
            namespace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
            throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for(let i = 0; i < 16; ++i){
                buf[offset + i] = bytes[i];
            }
            return buf;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["unsafeStringify"])(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}
}),
"[project]/node_modules/uuid/dist/esm-node/md5.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
function md5(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('md5').update(bytes).digest();
}
const __TURBOPACK__default__export__ = md5;
}),
"[project]/node_modules/uuid/dist/esm-node/v3.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v35.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$md5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/md5.js [app-route] (ecmascript)");
;
;
const v3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('v3', 0x30, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$md5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = v3;
}),
"[project]/node_modules/uuid/dist/esm-node/native.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
const __TURBOPACK__default__export__ = {
    randomUUID: __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].randomUUID
};
}),
"[project]/node_modules/uuid/dist/esm-node/v4.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$native$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/native.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/rng.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/stringify.js [app-route] (ecmascript)");
;
;
;
function v4(options, buf, offset) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$native$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].randomUUID && !buf && !options) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$native$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$rng$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["unsafeStringify"])(rnds);
}
const __TURBOPACK__default__export__ = v4;
}),
"[project]/node_modules/uuid/dist/esm-node/sha1.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === 'string') {
        bytes = Buffer.from(bytes, 'utf8');
    }
    return __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["default"].createHash('sha1').update(bytes).digest();
}
const __TURBOPACK__default__export__ = sha1;
}),
"[project]/node_modules/uuid/dist/esm-node/v5.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v35.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$sha1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/sha1.js [app-route] (ecmascript)");
;
;
const v5 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v35$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])('v5', 0x50, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$sha1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]);
const __TURBOPACK__default__export__ = v5;
}),
"[project]/node_modules/uuid/dist/esm-node/nil.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const __TURBOPACK__default__export__ = '00000000-0000-0000-0000-000000000000';
}),
"[project]/node_modules/uuid/dist/esm-node/version.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/validate.js [app-route] (ecmascript)");
;
function version(uuid) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(uuid)) {
        throw TypeError('Invalid UUID');
    }
    return parseInt(uuid.slice(14, 15), 16);
}
const __TURBOPACK__default__export__ = version;
}),
"[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NIL",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$nil$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "parse",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "stringify",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "v1",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "v3",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v3$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "v4",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "v5",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "validate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"],
    "version",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v1$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v1.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v3$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v3.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v4$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v4.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$v5$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/v5.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$nil$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/nil.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$version$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/version.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$validate$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/validate.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$stringify$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/stringify.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$node$2f$parse$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-node/parse.js [app-route] (ecmascript)");
}),
"[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
module.exports = DelayedStream;
function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);
DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for(var option in options){
        delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
    };
    source.on('error', function() {});
    if (delayedStream.pauseStream) {
        source.pause();
    }
    return delayedStream;
};
Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function() {
        return this.source.readable;
    }
});
DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream.prototype.resume = function() {
    if (!this._released) {
        this.release();
    }
    this.source.resume();
};
DelayedStream.prototype.pause = function() {
    this.source.pause();
};
DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
        this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
};
DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
};
DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
        this.emit.apply(this, args);
        return;
    }
    if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
};
DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
        return;
    }
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    this._maxDataSizeExceeded = true;
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
};
}),
"[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var DelayedStream = __turbopack_context__.r("[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)");
module.exports = CombinedStream;
function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);
CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for(var option in options){
        combinedStream[option] = options[option];
    }
    return combinedStream;
};
CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== 'function' && typeof stream !== 'string' && typeof stream !== 'boolean' && typeof stream !== 'number' && !Buffer.isBuffer(stream);
};
CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
                maxDataSize: Infinity,
                pauseStream: this.pauseStreams
            });
            stream.on('data', this._checkDataSize.bind(this));
            stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
            stream.pause();
        }
    }
    this._streams.push(stream);
    return this;
};
CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
};
CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
        this._pendingNext = true;
        return; // defer call
    }
    this._insideLoop = true;
    try {
        do {
            this._pendingNext = false;
            this._realGetNext();
        }while (this._pendingNext)
    } finally{
        this._insideLoop = false;
    }
};
CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
        this.end();
        return;
    }
    if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
    }
    var getStream = stream;
    getStream((function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
            stream.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream);
        }
        this._pipeNext(stream);
    }).bind(this));
};
CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {
            end: false
        });
        return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
};
CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on('error', function(err) {
        self._emitError(err);
    });
};
CombinedStream.prototype.write = function(data) {
    this.emit('data', data);
};
CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
        return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function') this._currentStream.pause();
    this.emit('pause');
};
CombinedStream.prototype.resume = function() {
    if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function') this._currentStream.resume();
    this.emit('resume');
};
CombinedStream.prototype.end = function() {
    this._reset();
    this.emit('end');
};
CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit('close');
};
CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
};
CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
};
CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
            return;
        }
        self.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
    }
};
CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit('error', err);
};
}),
"[project]/node_modules/mime-types/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/mime-db/index.js [app-route] (ecmascript)");
var extname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").extname;
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    // source preference (least -> most)
    var preference = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            if (types[extension]) {
                var from = preference.indexOf(db[types[extension]].source);
                var to = preference.indexOf(mime.source);
                if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                    continue;
                }
            }
            // set the extension -> mime
            types[extension] = type;
        }
    });
}
}),
"[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = defer;
/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */ function defer(fn) {
    var nextTick = typeof setImmediate == 'function' ? setImmediate : typeof process == 'object' && typeof process.nextTick == 'function' ? process.nextTick : null;
    if (nextTick) {
        nextTick(fn);
    } else {
        setTimeout(fn, 0);
    }
}
}),
"[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var defer = __turbopack_context__.r("[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)");
// API
module.exports = async;
/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */ function async(callback) {
    var isAsync = false;
    // check if async happened
    defer(function() {
        isAsync = true;
    });
    return function async_callback(err, result) {
        if (isAsync) {
            callback(err, result);
        } else {
            defer(function nextTick_callback() {
                callback(err, result);
            });
        }
    };
}
}),
"[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// API
module.exports = abort;
/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */ function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    // reset leftover jobs
    state.jobs = {};
}
/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */ function clean(key) {
    if (typeof this.jobs[key] == 'function') {
        this.jobs[key]();
    }
}
}),
"[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)"), abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)");
// API
module.exports = iterate;
/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */ function iterate(list, iterator, state, callback) {
    // store current index
    var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        // don't repeat yourself
        // skip secondary callbacks
        if (!(key in state.jobs)) {
            return;
        }
        // clean up jobs
        delete state.jobs[key];
        if (error) {
            // don't process rest of the results
            // stop still active jobs
            // and reset the list
            abort(state);
        } else {
            state.results[key] = output;
        }
        // return salvaged results
        callback(error, state.results);
    });
}
/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */ function runJob(iterator, key, item, callback) {
    var aborter;
    // allow shortcut if iterator expects only two arguments
    if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
    } else {
        aborter = iterator(item, key, async(callback));
    }
    return aborter;
}
}),
"[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// API
module.exports = state;
/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */ function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
        // sort array keys based on it's values
        // sort object's keys just on own merit
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
        });
    }
    return initState;
}
}),
"[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)"), async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)");
// API
module.exports = terminator;
/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */ function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
        return;
    }
    // fast forward iteration index
    this.index = this.size;
    // abort jobs
    abort(this);
    // send back results we have so far
    async(callback)(null, this.results);
}
}),
"[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = parallel;
/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function parallel(list, iterator, callback) {
    var state = initState(list);
    while(state.index < (state['keyedList'] || list).length){
        iterate(list, iterator, state, function(error, result) {
            if (error) {
                callback(error, result);
                return;
            }
            // looks like it's the last one
            if (Object.keys(state.jobs).length === 0) {
                callback(null, state.results);
                return;
            }
        });
        state.index++;
    }
    return terminator.bind(state, callback);
}
}),
"[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending = ascending;
module.exports.descending = descending;
/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
            callback(error, result);
            return;
        }
        state.index++;
        // are we there yet?
        if (state.index < (state['keyedList'] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
        }
        // done here
        callback(null, state.results);
    });
    return terminator.bind(state, callback);
}
/*
 * -- Sort methods
 */ /**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function descending(a, b) {
    return -1 * ascending(a, b);
}
}),
"[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var serialOrdered = __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)");
// Public API
module.exports = serial;
/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
}
}),
"[project]/node_modules/asynckit/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    parallel: __turbopack_context__.r("[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)"),
    serial: __turbopack_context__.r("[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)"),
    serialOrdered: __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)")
};
}),
"[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/es-errors/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/es-errors/eval.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/es-errors/range.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/es-errors/ref.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/es-errors/syntax.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/es-errors/type.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/es-errors/uri.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/math-intrinsics/max.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/math-intrinsics/min.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/math-intrinsics/round.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/gopd/gOPD.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/gopd/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-route] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/es-define-property/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/has-symbols/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/function-bind/implementation.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/function-bind/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-route] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/dunder-proto/get.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-route] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/hasown/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/get-intrinsic/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-route] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-route] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-route] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-route] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-route] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-route] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-route] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-route] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-route] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-route] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-route] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-route] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/has-tostringtag/shams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}),
"[project]/node_modules/es-set-tostringtag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-route] (ecmascript)");
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-route] (ecmascript)")();
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
/** @type {import('.')} */ module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean' || typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean') {
        throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
            $defineProperty(object, toStringTag, {
                configurable: !nonConfigurable,
                enumerable: false,
                value: value,
                writable: false
            });
        } else {
            object[toStringTag] = value; // eslint-disable-line no-param-reassign
        }
    }
};
}),
"[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// populates missing values
module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign
    });
    return dst;
};
}),
"[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var CombinedStream = __turbopack_context__.r("[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var crypto = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
var mime = __turbopack_context__.r("[project]/node_modules/mime-types/index.js [app-route] (ecmascript)");
var asynckit = __turbopack_context__.r("[project]/node_modules/asynckit/index.js [app-route] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/es-set-tostringtag/index.js [app-route] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var populate = __turbopack_context__.r("[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)");
/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {object} options - Properties to be added/overriden for FormData and CombinedStream
 */ function FormData(options) {
    if (!(this instanceof FormData)) {
        return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {}; // eslint-disable-line no-param-reassign
    for(var option in options){
        this[option] = options[option];
    }
}
// make it a Stream
util.inherits(FormData, CombinedStream);
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
FormData.prototype.append = function(field, value, options) {
    options = options || {}; // eslint-disable-line no-param-reassign
    // allow filename as single option
    if (typeof options === 'string') {
        options = {
            filename: options
        }; // eslint-disable-line no-param-reassign
    }
    var append = CombinedStream.prototype.append.bind(this);
    // all that streamy business can't handle numbers
    if (typeof value === 'number' || value == null) {
        value = String(value); // eslint-disable-line no-param-reassign
    }
    // https://github.com/felixge/node-form-data/issues/38
    if (Array.isArray(value)) {
        /*
     * Please convert your array into string
     * the way web server expects it
     */ this._error(new Error('Arrays are not supported.'));
        return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    // pass along options.knownLength
    this._trackLength(header, value, options);
};
FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    /*
   * used w/ getLengthSync(), when length is known.
   * e.g. for streaming directly from a remote server,
   * w/ a known file a size, and not wanting to wait for
   * incoming file to finish to get its size.
   */ if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
    } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
    } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    // @check why add CRLF? does this account for custom/multiple CRLFs?
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    // empty or either doesn't have path or not an http response or not a stream
    if (!value || !value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream)) {
        return;
    }
    // no need to bother with the length
    if (!options.knownLength) {
        this._valuesToMeasure.push(value);
    }
};
FormData.prototype._lengthRetriever = function(value, callback) {
    if (hasOwn(value, 'fd')) {
        // take read range into a account
        // `end` = Infinity > read file till the end
        //
        // TODO: Looks like there is bug in Node fs.createReadStream
        // it doesn't respect `end` options without `start` options
        // Fix it when node fixes it.
        // https://github.com/joyent/node/issues/7819
        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return
        // not that fast snoopy
        } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
                if (err) {
                    callback(err);
                    return;
                }
                // update final size based on the range options
                var fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
        }
    // or http response
    } else if (hasOwn(value, 'httpVersion')) {
        callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return
    // or request stream http://github.com/mikeal/request
    } else if (hasOwn(value, 'httpModule')) {
        // wait till response come back
        value.on('response', function(response) {
            value.pause();
            callback(null, Number(response.headers['content-length']));
        });
        value.resume();
    // something else
    } else {
        callback('Unknown stream'); // eslint-disable-line callback-return
    }
};
FormData.prototype._multiPartHeader = function(field, value, options) {
    /*
   * custom header specified (as string)?
   * it becomes responsible for boundary
   * (e.g. to handle extra CRLFs on .NET servers)
   */ if (typeof options.header === 'string') {
        return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': [
            'form-data',
            'name="' + field + '"'
        ].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || [])
    };
    // allow custom headers.
    if (typeof options.header === 'object') {
        populate(headers, options.header);
    }
    var header;
    for(var prop in headers){
        if (hasOwn(headers, prop)) {
            header = headers[prop];
            // skip nullish headers.
            if (header == null) {
                continue; // eslint-disable-line no-restricted-syntax, no-continue
            }
            // convert all headers to arrays.
            if (!Array.isArray(header)) {
                header = [
                    header
                ];
            }
            // add non-empty headers.
            if (header.length) {
                contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
        }
    }
    return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};
FormData.prototype._getContentDisposition = function(value, options) {
    var filename;
    if (typeof options.filepath === 'string') {
        // custom filepath for relative paths
        filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value && (value.name || value.path)) {
        /*
     * custom filename take precedence
     * formidable and the browser add a name property
     * fs- and request- streams have path property
     */ filename = path.basename(options.filename || value && (value.name || value.path));
    } else if (value && value.readable && hasOwn(value, 'httpVersion')) {
        // or try http response
        filename = path.basename(value.client._httpMessage.path || '');
    }
    if (filename) {
        return 'filename="' + filename + '"';
    }
};
FormData.prototype._getContentType = function(value, options) {
    // use custom content-type above all
    var contentType = options.contentType;
    // or try `name` from formidable, browser
    if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
    }
    // or try `path` from fs-, request- streams
    if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
    }
    // or if it's http-reponse
    if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {
        contentType = value.headers['content-type'];
    }
    // or guess it from the filepath or filename
    if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
    }
    // fallback to the default content type if `value` is not simple value
    if (!contentType && value && typeof value === 'object') {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
};
FormData.prototype._multiPartFooter = function() {
    return (function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
            footer += this._lastBoundary();
        }
        next(footer);
    }).bind(this);
};
FormData.prototype._lastBoundary = function() {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};
FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
    };
    for(header in userHeaders){
        if (hasOwn(userHeaders, header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
        }
    }
    return formHeaders;
};
FormData.prototype.setBoundary = function(boundary) {
    if (typeof boundary !== 'string') {
        throw new TypeError('FormData boundary must be a string');
    }
    this._boundary = boundary;
};
FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
        this._generateBoundary();
    }
    return this._boundary;
};
FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap
    var boundary = this.getBoundary();
    // Create the form content. Add Line breaks to the end of data.
    for(var i = 0, len = this._streams.length; i < len; i++){
        if (typeof this._streams[i] !== 'function') {
            // Add content to the buffer.
            if (Buffer.isBuffer(this._streams[i])) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]);
            } else {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
            }
            // Add break after content.
            if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
        }
    }
    // Add the footer and return the Buffer object.
    return Buffer.concat([
        dataBuffer,
        Buffer.from(this._lastBoundary())
    ]);
};
FormData.prototype._generateBoundary = function() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    this._boundary = '--------------------------' + crypto.randomBytes(12).toString('hex');
};
// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually and add it as knownLength option
FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    // Don't get confused, there are 3 "internal" streams for each keyval pair so it basically checks if there is any value added to the form
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    // https://github.com/form-data/form-data/issues/40
    if (!this.hasKnownLength()) {
        /*
     * Some async length retrievers are present
     * therefore synchronous length calculation is false.
     * Please use getLength(callback) to get proper length
     */ this._error(new Error('Cannot calculate proper length in synchronous way.'));
    }
    return knownLength;
};
// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
        hasKnownLength = false;
    }
    return hasKnownLength;
};
FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
            cb(err);
            return;
        }
        values.forEach(function(length) {
            knownLength += length;
        });
        cb(null, knownLength);
    });
};
FormData.prototype.submit = function(params, cb) {
    var request;
    var options;
    var defaults = {
        method: 'post'
    };
    // parse provided url if it's string or treat it as options object
    if (typeof params === 'string') {
        params = parseUrl(params); // eslint-disable-line no-param-reassign
        /* eslint sort-keys: 0 */ options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults);
    } else {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
            options.port = options.protocol === 'https:' ? 443 : 80;
        }
    }
    // put that good code in getHeaders to some use
    options.headers = this.getHeaders(params.headers);
    // https if specified, fallback to http in any other case
    if (options.protocol === 'https:') {
        request = https.request(options);
    } else {
        request = http.request(options);
    }
    // get content length and fire away
    this.getLength((function(err, length) {
        if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
        }
        // add content length
        if (length) {
            request.setHeader('Content-Length', length);
        }
        this.pipe(request);
        if (cb) {
            var onResponse;
            var callback = function(error, responce) {
                request.removeListener('error', callback);
                request.removeListener('response', onResponse);
                return cb.call(this, error, responce); // eslint-disable-line no-invalid-this
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
        }
    }).bind(this));
    return request;
};
FormData.prototype._error = function(err) {
    if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
    }
};
FormData.prototype.toString = function() {
    return '[object FormData]';
};
setToStringTag(FormData, 'FormData');
// Public API
module.exports = FormData;
}),
"[project]/node_modules/proxy-from-env/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */ function getProxyForUrl(url) {
    var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
        return ''; // Don't proxy URLs without a valid scheme or host.
    }
    proto = proto.split(':', 1)[0];
    // Stripping ports in this way instead of using parsedUrl.hostname to make
    // sure that the brackets around IPv6 addresses are kept.
    hostname = hostname.replace(/:\d*$/, '');
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
        return ''; // Don't proxy URLs that match NO_PROXY.
    }
    var proxy = getEnv('npm_config_' + proto + '_proxy') || getEnv(proto + '_proxy') || getEnv('npm_config_proxy') || getEnv('all_proxy');
    if (proxy && proxy.indexOf('://') === -1) {
        // Missing scheme in proxy, default to the requested URL's scheme.
        proxy = proto + '://' + proxy;
    }
    return proxy;
}
/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */ function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
    if (!NO_PROXY) {
        return true; // Always proxy if NO_PROXY is not set.
    }
    if (NO_PROXY === '*') {
        return false; // Never proxy if wildcard is set.
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
            return true; // Skip zero-length hosts.
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
            return true; // Skip if ports don't match.
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
            // No wildcards, so stop proxying if there is an exact match.
            return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === '*') {
            // Remove leading wildcard.
            parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        // Stop proxying if the hostname ends with the no_proxy host.
        return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
}
/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */ function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}
exports.getProxyForUrl = getProxyForUrl;
}),
"[project]/node_modules/ms/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/debug/src/common.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(/\s+/g, ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}),
"[project]/node_modules/debug/src/node.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}),
"[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || ("TURBOPACK compile-time value", "undefined") !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}),
"[project]/node_modules/debug/src/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}),
"[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var debug;
module.exports = function() {
    if (!debug) {
        try {
            /* eslint global-require: off */ debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("follow-redirects");
        } catch (error) {}
        if (typeof debug !== "function") {
            debug = function() {};
        }
    }
    debug.apply(null, arguments);
};
}),
"[project]/node_modules/follow-redirects/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var URL = url.URL;
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var Writable = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Writable;
var assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debug = __turbopack_context__.r("[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)");
// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = ("TURBOPACK compile-time value", "undefined") !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
    }
})();
// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
    assert(new URL(""));
} catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
}
// URL fields to preserve in copy operations
var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
];
// Create handlers that pass events from native requests
var events = [
    "abort",
    "aborted",
    "connect",
    "error",
    "socket",
    "timeout"
];
var eventHandlers = Object.create(null);
events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
    };
});
// Error types with codes
var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;
// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
    // Initialize the request
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    // Attach a callback if passed
    if (responseCallback) {
        this.on("response", responseCallback);
    }
    // React to responses of native requests
    var self = this;
    this._onNativeResponse = function(response) {
        try {
            self._processResponse(response);
        } catch (cause) {
            self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({
                cause: cause
            }));
        }
    };
    // Perform the first request
    this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
};
// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function(data, encoding, callback) {
    // Writing is not allowed if end has been called
    if (this._ending) {
        throw new WriteAfterEndError();
    }
    // Validate input and shift parameters if necessary
    if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Ignore empty buffers, since writing them doesn't invoke the callback
    // https://github.com/nodejs/node/issues/22066
    if (data.length === 0) {
        if (callback) {
            callback();
        }
        return;
    }
    // Only write when we don't exceed the maximum body length
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({
            data: data,
            encoding: encoding
        });
        this._currentRequest.write(data, encoding, callback);
    } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
    }
};
// Ends the current native request
RedirectableRequest.prototype.end = function(data, encoding, callback) {
    // Shift parameters if necessary
    if (isFunction(data)) {
        callback = data;
        data = encoding = null;
    } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Write data if needed and end
    if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
    } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
            self._ended = true;
            currentRequest.end(null, null, callback);
        });
        this._ending = true;
    }
};
// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
};
// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
};
// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self = this;
    // Destroys the socket on timeout
    function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
    }
    // Sets up a timer to trigger a timeout event
    function startTimer(socket) {
        if (self._timeout) {
            clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
            self.emit("timeout");
            clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
    }
    // Stops a timeout from triggering
    function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
            clearTimeout(self._timeout);
            self._timeout = null;
        }
        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
            self.removeListener("timeout", callback);
        }
        if (!self.socket) {
            self._currentRequest.removeListener("socket", startTimer);
        }
    }
    // Attach callback if passed
    if (callback) {
        this.on("timeout", callback);
    }
    // Start the timer if or when the socket is opened
    if (this.socket) {
        startTimer(this.socket);
    } else {
        this._currentRequest.once("socket", startTimer);
    }
    // Clean up on events
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
};
// Proxy all other public ClientRequest methods
[
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
    };
});
// Proxy all public ClientRequest properties
[
    "aborted",
    "connection",
    "socket"
].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
            return this._currentRequest[property];
        }
    });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
    // Ensure headers are always present
    if (!options.headers) {
        options.headers = {};
    }
    // Since http.request treats host as an alias of hostname,
    // but the url module interprets host as hostname plus port,
    // eliminate the host property to avoid confusion.
    if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
            options.hostname = options.host;
        }
        delete options.host;
    }
    // Complete the URL object when necessary
    if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
            options.pathname = options.path;
        } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
        }
    }
};
// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function() {
    // Load the native protocol
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
    }
    // If specified, use the agent corresponding to the protocol
    // (HTTP and HTTPS use different types of agents)
    if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
    }
    // Create the native request and set up its event handlers
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events){
        request.on(event, eventHandlers[event]);
    }
    // RFC72305.3.1: When making a request directly to an origin server, []
    // a client MUST send only the absolute path [] as the request-target.
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path;
    // End a redirected request
    // (The first request must be ended explicitly with RedirectableRequest#end)
    if (this._isRedirect) {
        // Write the request entity and end
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
            // Only write if this request has not been redirected yet
            // istanbul ignore else
            if (request === self._currentRequest) {
                // Report any write errors
                // istanbul ignore if
                if (error) {
                    self.emit("error", error);
                } else if (i < buffers.length) {
                    var buffer = buffers[i++];
                    // istanbul ignore else
                    if (!request.finished) {
                        request.write(buffer.data, buffer.encoding, writeNext);
                    }
                } else if (self._ended) {
                    request.end();
                }
            }
        })();
    }
};
// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function(response) {
    // Store the redirected response
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
        this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: statusCode
        });
    }
    // RFC72316.4: The 3xx (Redirection) class of status code indicates
    // that further action needs to be taken by the user agent in order to
    // fulfill the request. If a Location header field is provided,
    // the user agent MAY automatically redirect its request to the URI
    // referenced by the Location field value,
    // even if the specific status code is not understood.
    // If the response is not a redirect; return it as-is
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        // Clean up
        this._requestBodyBuffers = [];
        return;
    }
    // The response is a redirect, so abort the current request
    destroyRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();
    // RFC72316.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
    }
    // Store the request headers if applicable
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
        requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
        }, this._options.headers);
    }
    // RFC72316.4: Automatic redirection needs to done with
    // care for methods not known to be safe, []
    // RFC72316.4.23: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        // Drop a possible entity and headers related to it
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
        host: currentHost
    }));
    // Create the redirected request
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    // Drop confidential headers when redirecting to a less secure protocol
    // or to a different domain that is not a superdomain
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    // Evaluate the beforeRedirect callback
    if (isFunction(beforeRedirect)) {
        var responseDetails = {
            headers: response.headers,
            statusCode: statusCode
        };
        var requestDetails = {
            url: currentUrl,
            method: method,
            headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
    }
    // Perform the redirected request
    this._performRequest();
};
// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
    // Default settings
    var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
    };
    // Wrap each protocol
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
        // Executes a request, following redirects
        function request(input, options, callback) {
            // Parse parameters, ensuring that input is an object
            if (isURL(input)) {
                input = spreadUrlObject(input);
            } else if (isString(input)) {
                input = spreadUrlObject(parseUrl(input));
            } else {
                callback = options;
                options = validateUrl(input);
                input = {
                    protocol: protocol
                };
            }
            if (isFunction(options)) {
                callback = options;
                options = null;
            }
            // Set defaults
            options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString(options.host) && !isString(options.hostname)) {
                options.hostname = "::1";
            }
            assert.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
        }
        // Executes a GET request, following redirects
        function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
        }
        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
            request: {
                value: request,
                configurable: true,
                enumerable: true,
                writable: true
            },
            get: {
                value: get,
                configurable: true,
                enumerable: true,
                writable: true
            }
        });
    });
    return exports;
}
function noop() {}
function parseUrl(input) {
    var parsed;
    // istanbul ignore else
    if (useNativeURL) {
        parsed = new URL(input);
    } else {
        // Ensure the URL is valid and absolute
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
            throw new InvalidUrlError({
                input
            });
        }
    }
    return parsed;
}
function resolveUrl(relative, base) {
    // istanbul ignore next
    return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    return input;
}
function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields){
        spread[key] = urlObject[key];
    }
    // Fix IPv6 hostname
    if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
    }
    // Ensure port is a number
    if (spread.port !== "") {
        spread.port = Number(spread.port);
    }
    // Concatenate path
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
}
function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for(var header in headers){
        if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
        }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
    // Create constructor
    function CustomError(properties) {
        // istanbul ignore else
        if (isFunction(Error.captureStackTrace)) {
            Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    // Attach constructor and set default properties
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
        constructor: {
            value: CustomError,
            enumerable: false
        },
        name: {
            value: "Error [" + code + "]",
            enumerable: false
        }
    });
    return CustomError;
}
function destroyRequest(request, error) {
    for (var event of events){
        request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
}
function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
    return typeof value === "function";
}
function isBuffer(value) {
    return typeof value === "object" && "length" in value;
}
function isURL(value) {
    return URL && value instanceof URL;
}
// Exports
module.exports = wrap({
    http: http,
    https: https
});
module.exports.wrap = wrap;
}),
"[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    exports.defaults = {
        "0.1": {
            explicitCharkey: false,
            trim: true,
            normalize: true,
            normalizeTags: false,
            attrkey: "@",
            charkey: "#",
            explicitArray: false,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: false,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            childkey: '@@',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            emptyTag: ''
        },
        "0.2": {
            explicitCharkey: false,
            trim: false,
            normalize: false,
            normalizeTags: false,
            attrkey: "$",
            charkey: "_",
            explicitArray: true,
            ignoreAttrs: false,
            mergeAttrs: false,
            explicitRoot: true,
            validator: null,
            xmlns: false,
            explicitChildren: false,
            preserveChildrenOrder: false,
            childkey: '$$',
            charsAsChildren: false,
            includeWhiteChars: false,
            async: false,
            strict: true,
            attrNameProcessors: null,
            attrValueProcessors: null,
            tagNameProcessors: null,
            valueProcessors: null,
            rootName: 'root',
            xmldec: {
                'version': '1.0',
                'encoding': 'UTF-8',
                'standalone': true
            },
            doctype: null,
            renderOpts: {
                'pretty': true,
                'indent': '  ',
                'newline': '\n'
            },
            headless: false,
            chunkSize: 10000,
            emptyTag: '',
            cdata: false
        }
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/builder.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
    builder = __turbopack_context__.r("[project]/node_modules/xml2js/node_modules/xmlbuilder/lib/index.js [app-route] (ecmascript)");
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)").defaults;
    requiresCDATA = function(entry) {
        return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
    };
    wrapCDATA = function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
    };
    escapeCDATA = function(entry) {
        return entry.replace(']]>', ']]]]><![CDATA[>');
    };
    exports.Builder = function() {
        function Builder(opts) {
            var key, ref, value;
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
        }
        Builder.prototype.buildObject = function(rootObj) {
            var attrkey, charkey, render, rootElement, rootName;
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults['0.2'].rootName) {
                rootName = Object.keys(rootObj)[0];
                rootObj = rootObj[rootName];
            } else {
                rootName = this.options.rootName;
            }
            render = function(_this) {
                return function(element, obj) {
                    var attr, child, entry, index, key, value;
                    if (typeof obj !== 'object') {
                        if (_this.options.cdata && requiresCDATA(obj)) {
                            element.raw(wrapCDATA(obj));
                        } else {
                            element.txt(obj);
                        }
                    } else if (Array.isArray(obj)) {
                        for(index in obj){
                            if (!hasProp.call(obj, index)) continue;
                            child = obj[index];
                            for(key in child){
                                entry = child[key];
                                element = render(element.ele(key), entry).up();
                            }
                        }
                    } else {
                        for(key in obj){
                            if (!hasProp.call(obj, key)) continue;
                            child = obj[key];
                            if (key === attrkey) {
                                if (typeof child === "object") {
                                    for(attr in child){
                                        value = child[attr];
                                        element = element.att(attr, value);
                                    }
                                }
                            } else if (key === charkey) {
                                if (_this.options.cdata && requiresCDATA(child)) {
                                    element = element.raw(wrapCDATA(child));
                                } else {
                                    element = element.txt(child);
                                }
                            } else if (Array.isArray(child)) {
                                for(index in child){
                                    if (!hasProp.call(child, index)) continue;
                                    entry = child[index];
                                    if (typeof entry === 'string') {
                                        if (_this.options.cdata && requiresCDATA(entry)) {
                                            element = element.ele(key).raw(wrapCDATA(entry)).up();
                                        } else {
                                            element = element.ele(key, entry).up();
                                        }
                                    } else {
                                        element = render(element.ele(key), entry).up();
                                    }
                                }
                            } else if (typeof child === "object") {
                                element = render(element.ele(key), child).up();
                            } else {
                                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                                    element = element.ele(key).raw(wrapCDATA(child)).up();
                                } else {
                                    if (child == null) {
                                        child = '';
                                    }
                                    element = element.ele(key, child.toString()).up();
                                }
                            }
                        }
                    }
                    return element;
                };
            }(this);
            rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                headless: this.options.headless,
                allowSurrogateChars: this.options.allowSurrogateChars
            });
            return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
    }();
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/bom.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    exports.stripBOM = function(str) {
        if (str[0] === '\uFEFF') {
            return str.substring(1);
        } else {
            return str;
        }
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/processors.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var prefixMatch;
    prefixMatch = new RegExp(/(?!xmlns)^.*:/);
    exports.normalize = function(str) {
        return str.toLowerCase();
    };
    exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, '');
    };
    exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
            str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
    };
    exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
            str = str.toLowerCase() === 'true';
        }
        return str;
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/parser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
        return function() {
            return fn.apply(me, arguments);
        };
    }, extend = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    sax = __turbopack_context__.r("[project]/node_modules/sax/lib/sax.js [app-route] (ecmascript)");
    events = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
    bom = __turbopack_context__.r("[project]/node_modules/xml2js/lib/bom.js [app-route] (ecmascript)");
    processors = __turbopack_context__.r("[project]/node_modules/xml2js/lib/processors.js [app-route] (ecmascript)");
    setImmediate = __turbopack_context__.r("[externals]/timers [external] (timers, cjs)").setImmediate;
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)").defaults;
    isEmpty = function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
    };
    processItem = function(processors, item, key) {
        var i, len, process;
        for(i = 0, len = processors.length; i < len; i++){
            process = processors[i];
            item = process(item, key);
        }
        return item;
    };
    defineProperty = function(obj, key, value) {
        var descriptor;
        descriptor = Object.create(null);
        descriptor.value = value;
        descriptor.writable = true;
        descriptor.enumerable = true;
        descriptor.configurable = true;
        return Object.defineProperty(obj, key, descriptor);
    };
    exports.Parser = function(superClass) {
        extend(Parser, superClass);
        function Parser(opts) {
            this.parseStringPromise = bind(this.parseStringPromise, this);
            this.parseString = bind(this.parseString, this);
            this.reset = bind(this.reset, this);
            this.assignOrPush = bind(this.assignOrPush, this);
            this.processAsync = bind(this.processAsync, this);
            var key, ref, value;
            if (!(this instanceof exports.Parser)) {
                return new exports.Parser(opts);
            }
            this.options = {};
            ref = defaults["0.2"];
            for(key in ref){
                if (!hasProp.call(ref, key)) continue;
                value = ref[key];
                this.options[key] = value;
            }
            for(key in opts){
                if (!hasProp.call(opts, key)) continue;
                value = opts[key];
                this.options[key] = value;
            }
            if (this.options.xmlns) {
                this.options.xmlnskey = this.options.attrkey + "ns";
            }
            if (this.options.normalizeTags) {
                if (!this.options.tagNameProcessors) {
                    this.options.tagNameProcessors = [];
                }
                this.options.tagNameProcessors.unshift(processors.normalize);
            }
            this.reset();
        }
        Parser.prototype.processAsync = function() {
            var chunk, err;
            try {
                if (this.remaining.length <= this.options.chunkSize) {
                    chunk = this.remaining;
                    this.remaining = '';
                    this.saxParser = this.saxParser.write(chunk);
                    return this.saxParser.close();
                } else {
                    chunk = this.remaining.substr(0, this.options.chunkSize);
                    this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
                    this.saxParser = this.saxParser.write(chunk);
                    return setImmediate(this.processAsync);
                }
            } catch (error1) {
                err = error1;
                if (!this.saxParser.errThrown) {
                    this.saxParser.errThrown = true;
                    return this.emit(err);
                }
            }
        };
        Parser.prototype.assignOrPush = function(obj, key, newValue) {
            if (!(key in obj)) {
                if (!this.options.explicitArray) {
                    return defineProperty(obj, key, newValue);
                } else {
                    return defineProperty(obj, key, [
                        newValue
                    ]);
                }
            } else {
                if (!(obj[key] instanceof Array)) {
                    defineProperty(obj, key, [
                        obj[key]
                    ]);
                }
                return obj[key].push(newValue);
            }
        };
        Parser.prototype.reset = function() {
            var attrkey, charkey, ontext, stack;
            this.removeAllListeners();
            this.saxParser = sax.parser(this.options.strict, {
                trim: false,
                normalize: false,
                xmlns: this.options.xmlns
            });
            this.saxParser.errThrown = false;
            this.saxParser.onerror = function(_this) {
                return function(error) {
                    _this.saxParser.resume();
                    if (!_this.saxParser.errThrown) {
                        _this.saxParser.errThrown = true;
                        return _this.emit("error", error);
                    }
                };
            }(this);
            this.saxParser.onend = function(_this) {
                return function() {
                    if (!_this.saxParser.ended) {
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            this.saxParser.ended = false;
            this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
            this.resultObject = null;
            stack = [];
            attrkey = this.options.attrkey;
            charkey = this.options.charkey;
            this.saxParser.onopentag = function(_this) {
                return function(node) {
                    var key, newValue, obj, processedKey, ref;
                    obj = {};
                    obj[charkey] = "";
                    if (!_this.options.ignoreAttrs) {
                        ref = node.attributes;
                        for(key in ref){
                            if (!hasProp.call(ref, key)) continue;
                            if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                                obj[attrkey] = {};
                            }
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                            if (_this.options.mergeAttrs) {
                                _this.assignOrPush(obj, processedKey, newValue);
                            } else {
                                defineProperty(obj[attrkey], processedKey, newValue);
                            }
                        }
                    }
                    obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
                    if (_this.options.xmlns) {
                        obj[_this.options.xmlnskey] = {
                            uri: node.uri,
                            local: node.local
                        };
                    }
                    return stack.push(obj);
                };
            }(this);
            this.saxParser.onclosetag = function(_this) {
                return function() {
                    var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                    obj = stack.pop();
                    nodeName = obj["#name"];
                    if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                        delete obj["#name"];
                    }
                    if (obj.cdata === true) {
                        cdata = obj.cdata;
                        delete obj.cdata;
                    }
                    s = stack[stack.length - 1];
                    if (obj[charkey].match(/^\s*$/) && !cdata) {
                        emptyStr = obj[charkey];
                        delete obj[charkey];
                    } else {
                        if (_this.options.trim) {
                            obj[charkey] = obj[charkey].trim();
                        }
                        if (_this.options.normalize) {
                            obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                        }
                        obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                        if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                            obj = obj[charkey];
                        }
                    }
                    if (isEmpty(obj)) {
                        if (typeof _this.options.emptyTag === 'function') {
                            obj = _this.options.emptyTag();
                        } else {
                            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
                        }
                    }
                    if (_this.options.validator != null) {
                        xpath = "/" + (function() {
                            var i, len, results;
                            results = [];
                            for(i = 0, len = stack.length; i < len; i++){
                                node = stack[i];
                                results.push(node["#name"]);
                            }
                            return results;
                        })().concat(nodeName).join("/");
                        (function() {
                            var err;
                            try {
                                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
                            } catch (error1) {
                                err = error1;
                                return _this.emit("error", err);
                            }
                        })();
                    }
                    if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
                        if (!_this.options.preserveChildrenOrder) {
                            node = {};
                            if (_this.options.attrkey in obj) {
                                node[_this.options.attrkey] = obj[_this.options.attrkey];
                                delete obj[_this.options.attrkey];
                            }
                            if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                                node[_this.options.charkey] = obj[_this.options.charkey];
                                delete obj[_this.options.charkey];
                            }
                            if (Object.getOwnPropertyNames(obj).length > 0) {
                                node[_this.options.childkey] = obj;
                            }
                            obj = node;
                        } else if (s) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            objClone = {};
                            for(key in obj){
                                if (!hasProp.call(obj, key)) continue;
                                defineProperty(objClone, key, obj[key]);
                            }
                            s[_this.options.childkey].push(objClone);
                            delete obj["#name"];
                            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                                obj = obj[charkey];
                            }
                        }
                    }
                    if (stack.length > 0) {
                        return _this.assignOrPush(s, nodeName, obj);
                    } else {
                        if (_this.options.explicitRoot) {
                            old = obj;
                            obj = {};
                            defineProperty(obj, nodeName, old);
                        }
                        _this.resultObject = obj;
                        _this.saxParser.ended = true;
                        return _this.emit("end", _this.resultObject);
                    }
                };
            }(this);
            ontext = function(_this) {
                return function(text) {
                    var charChild, s;
                    s = stack[stack.length - 1];
                    if (s) {
                        s[charkey] += text;
                        if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
                            s[_this.options.childkey] = s[_this.options.childkey] || [];
                            charChild = {
                                '#name': '__text__'
                            };
                            charChild[charkey] = text;
                            if (_this.options.normalize) {
                                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                            }
                            s[_this.options.childkey].push(charChild);
                        }
                        return s;
                    }
                };
            }(this);
            this.saxParser.ontext = ontext;
            return this.saxParser.oncdata = function(_this) {
                return function(text) {
                    var s;
                    s = ontext(text);
                    if (s) {
                        return s.cdata = true;
                    }
                };
            }(this);
        };
        Parser.prototype.parseString = function(str, cb) {
            var err;
            if (cb != null && typeof cb === "function") {
                this.on("end", function(result) {
                    this.reset();
                    return cb(null, result);
                });
                this.on("error", function(err) {
                    this.reset();
                    return cb(err);
                });
            }
            try {
                str = str.toString();
                if (str.trim() === '') {
                    this.emit("end", null);
                    return true;
                }
                str = bom.stripBOM(str);
                if (this.options.async) {
                    this.remaining = str;
                    setImmediate(this.processAsync);
                    return this.saxParser;
                }
                return this.saxParser.write(str).close();
            } catch (error1) {
                err = error1;
                if (!(this.saxParser.errThrown || this.saxParser.ended)) {
                    this.emit('error', err);
                    return this.saxParser.errThrown = true;
                } else if (this.saxParser.ended) {
                    throw err;
                }
            }
        };
        Parser.prototype.parseStringPromise = function(str) {
            return new Promise(function(_this) {
                return function(resolve, reject) {
                    return _this.parseString(str, function(err, value) {
                        if (err) {
                            return reject(err);
                        } else {
                            return resolve(value);
                        }
                    });
                };
            }(this));
        };
        return Parser;
    }(events);
    exports.parseString = function(str, a, b) {
        var cb, options, parser;
        if (b != null) {
            if (typeof b === 'function') {
                cb = b;
            }
            if (typeof a === 'object') {
                options = a;
            }
        } else {
            if (typeof a === 'function') {
                cb = a;
            }
            options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
    };
    exports.parseStringPromise = function(str, a) {
        var options, parser;
        if (typeof a === 'object') {
            options = a;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
    };
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/xml2js/lib/xml2js.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Generated by CoffeeScript 1.12.7
(function() {
    "use strict";
    var builder, defaults, parser, processors, extend = function(child, parent) {
        for(var key in parent){
            if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    }, hasProp = {}.hasOwnProperty;
    defaults = __turbopack_context__.r("[project]/node_modules/xml2js/lib/defaults.js [app-route] (ecmascript)");
    builder = __turbopack_context__.r("[project]/node_modules/xml2js/lib/builder.js [app-route] (ecmascript)");
    parser = __turbopack_context__.r("[project]/node_modules/xml2js/lib/parser.js [app-route] (ecmascript)");
    processors = __turbopack_context__.r("[project]/node_modules/xml2js/lib/processors.js [app-route] (ecmascript)");
    exports.defaults = defaults.defaults;
    exports.processors = processors;
    exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
            this.message = message;
        }
        return ValidationError;
    }(Error);
    exports.Builder = builder.Builder;
    exports.Parser = parser.Parser;
    exports.parseString = parser.parseString;
    exports.parseStringPromise = parser.parseStringPromise;
}).call(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/sax/lib/sax.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

;
(function(sax) {
    // wrapper for non-node envs
    sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
    };
    sax.SAXParser = SAXParser;
    sax.SAXStream = SAXStream;
    sax.createStream = createStream;
    // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
    // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
    // since that's the earliest that a buffer overrun could occur.  This way, checks are
    // as rare as required, but as often as necessary to ensure never crossing this bound.
    // Furthermore, buffers are only tested at most once per write(), so passing a very
    // large string into write() might have undesirable effects, but this is manageable by
    // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
    // edge case, result in creating at most one complete copy of the string passed in.
    // Set to Infinity to have unlimited buffers.
    sax.MAX_BUFFER_LENGTH = 64 * 1024;
    var buffers = [
        'comment',
        'sgmlDecl',
        'textNode',
        'tagName',
        'doctype',
        'procInstName',
        'procInstBody',
        'entity',
        'attribName',
        'attribValue',
        'cdata',
        'script'
    ];
    sax.EVENTS = [
        'text',
        'processinginstruction',
        'sgmldeclaration',
        'doctype',
        'comment',
        'opentagstart',
        'attribute',
        'opentag',
        'closetag',
        'opencdata',
        'cdata',
        'closecdata',
        'error',
        'end',
        'ready',
        'script',
        'opennamespace',
        'closenamespace'
    ];
    function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
            return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = '';
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase';
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        // namespaces form a prototype chain.
        // it always points at the current tag,
        // which protos to its parent tag.
        if (parser.opt.xmlns) {
            parser.ns = Object.create(rootNS);
        }
        // disallow unquoted attribute values if not otherwise configured
        // and strict mode is true
        if (parser.opt.unquotedAttributeValues === undefined) {
            parser.opt.unquotedAttributeValues = !strict;
        }
        // mostly just for error reporting
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
            parser.position = parser.line = parser.column = 0;
        }
        emit(parser, 'onready');
    }
    if (!Object.create) {
        Object.create = function(o) {
            function F() {}
            F.prototype = o;
            var newf = new F();
            return newf;
        };
    }
    if (!Object.keys) {
        Object.keys = function(o) {
            var a = [];
            for(var i in o)if (o.hasOwnProperty(i)) a.push(i);
            return a;
        };
    }
    function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for(var i = 0, l = buffers.length; i < l; i++){
            var len = parser[buffers[i]].length;
            if (len > maxAllowed) {
                // Text/cdata nodes can get big, and since they're buffered,
                // we can get here under normal conditions.
                // Avoid issues by emitting the text node now,
                // so at least it won't get any bigger.
                switch(buffers[i]){
                    case 'textNode':
                        closeText(parser);
                        break;
                    case 'cdata':
                        emitNode(parser, 'oncdata', parser.cdata);
                        parser.cdata = '';
                        break;
                    case 'script':
                        emitNode(parser, 'onscript', parser.script);
                        parser.script = '';
                        break;
                    default:
                        error(parser, 'Max buffer length exceeded: ' + buffers[i]);
                }
            }
            maxActual = Math.max(maxActual, len);
        }
        // schedule the next check for the earliest possible buffer overrun.
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
    }
    function clearBuffers(parser) {
        for(var i = 0, l = buffers.length; i < l; i++){
            parser[buffers[i]] = '';
        }
    }
    function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== '') {
            emitNode(parser, 'oncdata', parser.cdata);
            parser.cdata = '';
        }
        if (parser.script !== '') {
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
    }
    SAXParser.prototype = {
        end: function() {
            end(this);
        },
        write: write,
        resume: function() {
            this.error = null;
            return this;
        },
        close: function() {
            return this.write(null);
        },
        flush: function() {
            flushBuffers(this);
        }
    };
    var Stream;
    try {
        Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
    } catch (ex) {
        Stream = function() {};
    }
    if (!Stream) Stream = function() {};
    var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== 'error' && ev !== 'end';
    });
    function createStream(strict, opt) {
        return new SAXStream(strict, opt);
    }
    function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
            return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
            me.emit('end');
        };
        this._parser.onerror = function(er) {
            me.emit('error', er);
            // if didn't throw, then means error was handled.
            // go ahead and clear error, so we can write again.
            me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
            Object.defineProperty(me, 'on' + ev, {
                get: function() {
                    return me._parser['on' + ev];
                },
                set: function(h) {
                    if (!h) {
                        me.removeAllListeners(ev);
                        me._parser['on' + ev] = h;
                        return h;
                    }
                    me.on(ev, h);
                },
                enumerable: true,
                configurable: false
            });
        });
    }
    SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
            value: SAXStream
        }
    });
    SAXStream.prototype.write = function(data) {
        if (typeof Buffer === 'function' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(data)) {
            if (!this._decoder) {
                var SD = __turbopack_context__.r("[externals]/string_decoder [external] (string_decoder, cjs)").StringDecoder;
                this._decoder = new SD('utf8');
            }
            data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit('data', data);
        return true;
    };
    SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
            this.write(chunk);
        }
        this._parser.end();
        return true;
    };
    SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
            me._parser['on' + ev] = function() {
                var args = arguments.length === 1 ? [
                    arguments[0]
                ] : Array.apply(null, arguments);
                args.splice(0, 0, ev);
                me.emit.apply(me, args);
            };
        }
        return Stream.prototype.on.call(me, ev, handler);
    };
    // this really needs to be replaced with character classes.
    // XML allows all manner of ridiculous numbers and digits.
    var CDATA = '[CDATA[';
    var DOCTYPE = 'DOCTYPE';
    var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';
    var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';
    var rootNS = {
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
    };
    // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
    // This implementation works on strings, a single character at a time
    // as such, it cannot ever support astral-plane characters (10000-EFFFF)
    // without a significant breaking change to either this  parser, or the
    // JavaScript language.  Implementation of an emoji-capable xml parser
    // is left as an exercise for the reader.
    var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
    function isWhitespace(c) {
        return c === ' ' || c === '\n' || c === '\r' || c === '\t';
    }
    function isQuote(c) {
        return c === '"' || c === "'";
    }
    function isAttribEnd(c) {
        return c === '>' || isWhitespace(c);
    }
    function isMatch(regex, c) {
        return regex.test(c);
    }
    function notMatch(regex, c) {
        return !isMatch(regex, c);
    }
    var S = 0;
    sax.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
    };
    sax.XML_ENTITIES = {
        amp: '&',
        gt: '>',
        lt: '<',
        quot: '"',
        apos: "'"
    };
    sax.ENTITIES = {
        amp: '&',
        gt: '>',
        lt: '<',
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
    };
    Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s = typeof e === 'number' ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s;
    });
    for(var s in sax.STATE){
        sax.STATE[sax.STATE[s]] = s;
    }
    // shorthand
    S = sax.STATE;
    function emit(parser, event, data) {
        parser[event] && parser[event](data);
    }
    function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
    }
    function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, 'ontext', parser.textNode);
        parser.textNode = '';
    }
    function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, ' ');
        return text;
    }
    function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
            er += '\nLine: ' + parser.line + '\nColumn: ' + parser.column + '\nChar: ' + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, 'onerror', er);
        return parser;
    }
    function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag');
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
            error(parser, 'Unexpected end');
        }
        closeText(parser);
        parser.c = '';
        parser.closed = true;
        emit(parser, 'onend');
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
    }
    function strictFail(parser, message) {
        if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
            throw new Error('bad call to strictFail');
        }
        if (parser.strict) {
            error(parser, message);
        }
    }
    function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = {
            name: parser.tagName,
            attributes: {}
        };
        // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
        if (parser.opt.xmlns) {
            tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, 'onopentagstart', tag);
    }
    function qname(name, attribute) {
        var i = name.indexOf(':');
        var qualName = i < 0 ? [
            '',
            name
        ] : name.split(':');
        var prefix = qualName[0];
        var local = qualName[1];
        // <x "xmlns"="http://foo">
        if (attribute && name === 'xmlns') {
            prefix = 'xmlns';
            local = '';
        }
        return {
            prefix: prefix,
            local: local
        };
    }
    function attrib(parser) {
        if (!parser.strict) {
            parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
            parser.attribName = parser.attribValue = '';
            return;
        }
        if (parser.opt.xmlns) {
            var qn = qname(parser.attribName, true);
            var prefix = qn.prefix;
            var local = qn.local;
            if (prefix === 'xmlns') {
                // namespace binding attribute. push the binding into scope
                if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
                    strictFail(parser, 'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
                    strictFail(parser, 'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' + 'Actual: ' + parser.attribValue);
                } else {
                    var tag = parser.tag;
                    var parent = parser.tags[parser.tags.length - 1] || parser;
                    if (tag.ns === parent.ns) {
                        tag.ns = Object.create(parent.ns);
                    }
                    tag.ns[local] = parser.attribValue;
                }
            }
            // defer onattribute events until all attributes have been seen
            // so any new bindings can take effect. preserve attribute order
            // so deferred events can be emitted in document order
            parser.attribList.push([
                parser.attribName,
                parser.attribValue
            ]);
        } else {
            // in non-xmlns mode, we can emit the event right away
            parser.tag.attributes[parser.attribName] = parser.attribValue;
            emitNode(parser, 'onattribute', {
                name: parser.attribName,
                value: parser.attribValue
            });
        }
        parser.attribName = parser.attribValue = '';
    }
    function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
            // emit namespace binding events
            var tag = parser.tag;
            // add namespace info to tag
            var qn = qname(parser.tagName);
            tag.prefix = qn.prefix;
            tag.local = qn.local;
            tag.uri = tag.ns[qn.prefix] || '';
            if (tag.prefix && !tag.uri) {
                strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(parser.tagName));
                tag.uri = qn.prefix;
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (tag.ns && parent.ns !== tag.ns) {
                Object.keys(tag.ns).forEach(function(p) {
                    emitNode(parser, 'onopennamespace', {
                        prefix: p,
                        uri: tag.ns[p]
                    });
                });
            }
            // handle deferred onattribute events
            // Note: do not apply default ns to attributes:
            //   http://www.w3.org/TR/REC-xml-names/#defaulting
            for(var i = 0, l = parser.attribList.length; i < l; i++){
                var nv = parser.attribList[i];
                var name = nv[0];
                var value = nv[1];
                var qualName = qname(name, true);
                var prefix = qualName.prefix;
                var local = qualName.local;
                var uri = prefix === '' ? '' : tag.ns[prefix] || '';
                var a = {
                    name: name,
                    value: value,
                    prefix: prefix,
                    local: local,
                    uri: uri
                };
                // if there's any attributes with an undefined namespace,
                // then fail on them now.
                if (prefix && prefix !== 'xmlns' && !uri) {
                    strictFail(parser, 'Unbound namespace prefix: ' + JSON.stringify(prefix));
                    a.uri = prefix;
                }
                parser.tag.attributes[name] = a;
                emitNode(parser, 'onattribute', a);
            }
            parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        // process the tag
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, 'onopentag', parser.tag);
        if (!selfClosing) {
            // special case for <script> in non-strict mode.
            if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
                parser.state = S.SCRIPT;
            } else {
                parser.state = S.TEXT;
            }
            parser.tag = null;
            parser.tagName = '';
        }
        parser.attribName = parser.attribValue = '';
        parser.attribList.length = 0;
    }
    function closeTag(parser) {
        if (!parser.tagName) {
            strictFail(parser, 'Weird empty close tag.');
            parser.textNode += '</>';
            parser.state = S.TEXT;
            return;
        }
        if (parser.script) {
            if (parser.tagName !== 'script') {
                parser.script += '</' + parser.tagName + '>';
                parser.tagName = '';
                parser.state = S.SCRIPT;
                return;
            }
            emitNode(parser, 'onscript', parser.script);
            parser.script = '';
        }
        // first make sure that the closing tag actually exists.
        // <a><b></c></b></a> will close everything, otherwise.
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
            tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while(t--){
            var close = parser.tags[t];
            if (close.name !== closeTo) {
                // fail the first time in strict mode
                strictFail(parser, 'Unexpected close tag');
            } else {
                break;
            }
        }
        // didn't find it.  we already failed for strict, so just abort.
        if (t < 0) {
            strictFail(parser, 'Unmatched closing tag: ' + parser.tagName);
            parser.textNode += '</' + parser.tagName + '>';
            parser.state = S.TEXT;
            return;
        }
        parser.tagName = tagName;
        var s = parser.tags.length;
        while(s-- > t){
            var tag = parser.tag = parser.tags.pop();
            parser.tagName = parser.tag.name;
            emitNode(parser, 'onclosetag', parser.tagName);
            var x = {};
            for(var i in tag.ns){
                x[i] = tag.ns[i];
            }
            var parent = parser.tags[parser.tags.length - 1] || parser;
            if (parser.opt.xmlns && tag.ns !== parent.ns) {
                // remove namespace bindings introduced by tag
                Object.keys(tag.ns).forEach(function(p) {
                    var n = tag.ns[p];
                    emitNode(parser, 'onclosenamespace', {
                        prefix: p,
                        uri: n
                    });
                });
            }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = '';
        parser.attribList.length = 0;
        parser.state = S.TEXT;
    }
    function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = '';
        if (parser.ENTITIES[entity]) {
            return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
            return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === '#') {
            if (entity.charAt(1) === 'x') {
                entity = entity.slice(2);
                num = parseInt(entity, 16);
                numStr = num.toString(16);
            } else {
                entity = entity.slice(1);
                num = parseInt(entity, 10);
                numStr = num.toString(10);
            }
        }
        entity = entity.replace(/^0+/, '');
        if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 0x10ffff) {
            strictFail(parser, 'Invalid character entity');
            return '&' + parser.entity + ';';
        }
        return String.fromCodePoint(num);
    }
    function beginWhiteSpace(parser, c) {
        if (c === '<') {
            parser.state = S.OPEN_WAKA;
            parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
            // have to process this as a text node.
            // weird, but happens.
            strictFail(parser, 'Non-whitespace before first tag.');
            parser.textNode = c;
            parser.state = S.TEXT;
        }
    }
    function charAt(chunk, i) {
        var result = '';
        if (i < chunk.length) {
            result = chunk.charAt(i);
        }
        return result;
    }
    function write(chunk) {
        var parser = this;
        if (this.error) {
            throw this.error;
        }
        if (parser.closed) {
            return error(parser, 'Cannot write after close. Assign an onready handler.');
        }
        if (chunk === null) {
            return end(parser);
        }
        if (typeof chunk === 'object') {
            chunk = chunk.toString();
        }
        var i = 0;
        var c = '';
        while(true){
            c = charAt(chunk, i++);
            parser.c = c;
            if (!c) {
                break;
            }
            if (parser.trackPosition) {
                parser.position++;
                if (c === '\n') {
                    parser.line++;
                    parser.column = 0;
                } else {
                    parser.column++;
                }
            }
            switch(parser.state){
                case S.BEGIN:
                    parser.state = S.BEGIN_WHITESPACE;
                    if (c === '\uFEFF') {
                        continue;
                    }
                    beginWhiteSpace(parser, c);
                    continue;
                case S.BEGIN_WHITESPACE:
                    beginWhiteSpace(parser, c);
                    continue;
                case S.TEXT:
                    if (parser.sawRoot && !parser.closedRoot) {
                        var starti = i - 1;
                        while(c && c !== '<' && c !== '&'){
                            c = charAt(chunk, i++);
                            if (c && parser.trackPosition) {
                                parser.position++;
                                if (c === '\n') {
                                    parser.line++;
                                    parser.column = 0;
                                } else {
                                    parser.column++;
                                }
                            }
                        }
                        parser.textNode += chunk.substring(starti, i - 1);
                    }
                    if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else {
                        if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                            strictFail(parser, 'Text data outside of root node.');
                        }
                        if (c === '&') {
                            parser.state = S.TEXT_ENTITY;
                        } else {
                            parser.textNode += c;
                        }
                    }
                    continue;
                case S.SCRIPT:
                    // only non-strict
                    if (c === '<') {
                        parser.state = S.SCRIPT_ENDING;
                    } else {
                        parser.script += c;
                    }
                    continue;
                case S.SCRIPT_ENDING:
                    if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                    } else {
                        parser.script += '<' + c;
                        parser.state = S.SCRIPT;
                    }
                    continue;
                case S.OPEN_WAKA:
                    // either a /, ?, !, or text is coming next.
                    if (c === '!') {
                        parser.state = S.SGML_DECL;
                        parser.sgmlDecl = '';
                    } else if (isWhitespace(c)) {
                    // wait for it...
                    } else if (isMatch(nameStart, c)) {
                        parser.state = S.OPEN_TAG;
                        parser.tagName = c;
                    } else if (c === '/') {
                        parser.state = S.CLOSE_TAG;
                        parser.tagName = '';
                    } else if (c === '?') {
                        parser.state = S.PROC_INST;
                        parser.procInstName = parser.procInstBody = '';
                    } else {
                        strictFail(parser, 'Unencoded <');
                        // if there was some whitespace, then add that in.
                        if (parser.startTagPosition + 1 < parser.position) {
                            var pad = parser.position - parser.startTagPosition;
                            c = new Array(pad).join(' ') + c;
                        }
                        parser.textNode += '<' + c;
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.SGML_DECL:
                    if (parser.sgmlDecl + c === '--') {
                        parser.state = S.COMMENT;
                        parser.comment = '';
                        parser.sgmlDecl = '';
                        continue;
                    }
                    if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.doctype += '<!' + parser.sgmlDecl + c;
                        parser.sgmlDecl = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                        emitNode(parser, 'onopencdata');
                        parser.state = S.CDATA;
                        parser.sgmlDecl = '';
                        parser.cdata = '';
                    } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                        parser.state = S.DOCTYPE;
                        if (parser.doctype || parser.sawRoot) {
                            strictFail(parser, 'Inappropriately located doctype declaration');
                        }
                        parser.doctype = '';
                        parser.sgmlDecl = '';
                    } else if (c === '>') {
                        emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl);
                        parser.sgmlDecl = '';
                        parser.state = S.TEXT;
                    } else if (isQuote(c)) {
                        parser.state = S.SGML_DECL_QUOTED;
                        parser.sgmlDecl += c;
                    } else {
                        parser.sgmlDecl += c;
                    }
                    continue;
                case S.SGML_DECL_QUOTED:
                    if (c === parser.q) {
                        parser.state = S.SGML_DECL;
                        parser.q = '';
                    }
                    parser.sgmlDecl += c;
                    continue;
                case S.DOCTYPE:
                    if (c === '>') {
                        parser.state = S.TEXT;
                        emitNode(parser, 'ondoctype', parser.doctype);
                        parser.doctype = true; // just remember that we saw it.
                    } else {
                        parser.doctype += c;
                        if (c === '[') {
                            parser.state = S.DOCTYPE_DTD;
                        } else if (isQuote(c)) {
                            parser.state = S.DOCTYPE_QUOTED;
                            parser.q = c;
                        }
                    }
                    continue;
                case S.DOCTYPE_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.q = '';
                        parser.state = S.DOCTYPE;
                    }
                    continue;
                case S.DOCTYPE_DTD:
                    if (c === ']') {
                        parser.doctype += c;
                        parser.state = S.DOCTYPE;
                    } else if (c === '<') {
                        parser.state = S.OPEN_WAKA;
                        parser.startTagPosition = parser.position;
                    } else if (isQuote(c)) {
                        parser.doctype += c;
                        parser.state = S.DOCTYPE_DTD_QUOTED;
                        parser.q = c;
                    } else {
                        parser.doctype += c;
                    }
                    continue;
                case S.DOCTYPE_DTD_QUOTED:
                    parser.doctype += c;
                    if (c === parser.q) {
                        parser.state = S.DOCTYPE_DTD;
                        parser.q = '';
                    }
                    continue;
                case S.COMMENT:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDING;
                    } else {
                        parser.comment += c;
                    }
                    continue;
                case S.COMMENT_ENDING:
                    if (c === '-') {
                        parser.state = S.COMMENT_ENDED;
                        parser.comment = textopts(parser.opt, parser.comment);
                        if (parser.comment) {
                            emitNode(parser, 'oncomment', parser.comment);
                        }
                        parser.comment = '';
                    } else {
                        parser.comment += '-' + c;
                        parser.state = S.COMMENT;
                    }
                    continue;
                case S.COMMENT_ENDED:
                    if (c !== '>') {
                        strictFail(parser, 'Malformed comment');
                        // allow <!-- blah -- bloo --> in non-strict mode,
                        // which is a comment of " blah -- bloo "
                        parser.comment += '--' + c;
                        parser.state = S.COMMENT;
                    } else if (parser.doctype && parser.doctype !== true) {
                        parser.state = S.DOCTYPE_DTD;
                    } else {
                        parser.state = S.TEXT;
                    }
                    continue;
                case S.CDATA:
                    var starti = i - 1;
                    while(c && c !== ']'){
                        c = charAt(chunk, i++);
                        if (c && parser.trackPosition) {
                            parser.position++;
                            if (c === '\n') {
                                parser.line++;
                                parser.column = 0;
                            } else {
                                parser.column++;
                            }
                        }
                    }
                    parser.cdata += chunk.substring(starti, i - 1);
                    if (c === ']') {
                        parser.state = S.CDATA_ENDING;
                    }
                    continue;
                case S.CDATA_ENDING:
                    if (c === ']') {
                        parser.state = S.CDATA_ENDING_2;
                    } else {
                        parser.cdata += ']' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.CDATA_ENDING_2:
                    if (c === '>') {
                        if (parser.cdata) {
                            emitNode(parser, 'oncdata', parser.cdata);
                        }
                        emitNode(parser, 'onclosecdata');
                        parser.cdata = '';
                        parser.state = S.TEXT;
                    } else if (c === ']') {
                        parser.cdata += ']';
                    } else {
                        parser.cdata += ']]' + c;
                        parser.state = S.CDATA;
                    }
                    continue;
                case S.PROC_INST:
                    if (c === '?') {
                        parser.state = S.PROC_INST_ENDING;
                    } else if (isWhitespace(c)) {
                        parser.state = S.PROC_INST_BODY;
                    } else {
                        parser.procInstName += c;
                    }
                    continue;
                case S.PROC_INST_BODY:
                    if (!parser.procInstBody && isWhitespace(c)) {
                        continue;
                    } else if (c === '?') {
                        parser.state = S.PROC_INST_ENDING;
                    } else {
                        parser.procInstBody += c;
                    }
                    continue;
                case S.PROC_INST_ENDING:
                    if (c === '>') {
                        emitNode(parser, 'onprocessinginstruction', {
                            name: parser.procInstName,
                            body: parser.procInstBody
                        });
                        parser.procInstName = parser.procInstBody = '';
                        parser.state = S.TEXT;
                    } else {
                        parser.procInstBody += '?' + c;
                        parser.state = S.PROC_INST_BODY;
                    }
                    continue;
                case S.OPEN_TAG:
                    if (isMatch(nameBody, c)) {
                        parser.tagName += c;
                    } else {
                        newTag(parser);
                        if (c === '>') {
                            openTag(parser);
                        } else if (c === '/') {
                            parser.state = S.OPEN_TAG_SLASH;
                        } else {
                            if (!isWhitespace(c)) {
                                strictFail(parser, 'Invalid character in tag name');
                            }
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.OPEN_TAG_SLASH:
                    if (c === '>') {
                        openTag(parser, true);
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Forward-slash in opening tag not followed by >');
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.ATTRIB:
                    // haven't read the attribute name yet.
                    if (isWhitespace(c)) {
                        continue;
                    } else if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else if (isMatch(nameStart, c)) {
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_NAME:
                    if (c === '=') {
                        parser.state = S.ATTRIB_VALUE;
                    } else if (c === '>') {
                        strictFail(parser, 'Attribute without value');
                        parser.attribValue = parser.attribName;
                        attrib(parser);
                        openTag(parser);
                    } else if (isWhitespace(c)) {
                        parser.state = S.ATTRIB_NAME_SAW_WHITE;
                    } else if (isMatch(nameBody, c)) {
                        parser.attribName += c;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_NAME_SAW_WHITE:
                    if (c === '=') {
                        parser.state = S.ATTRIB_VALUE;
                    } else if (isWhitespace(c)) {
                        continue;
                    } else {
                        strictFail(parser, 'Attribute without value');
                        parser.tag.attributes[parser.attribName] = '';
                        parser.attribValue = '';
                        emitNode(parser, 'onattribute', {
                            name: parser.attribName,
                            value: ''
                        });
                        parser.attribName = '';
                        if (c === '>') {
                            openTag(parser);
                        } else if (isMatch(nameStart, c)) {
                            parser.attribName = c;
                            parser.state = S.ATTRIB_NAME;
                        } else {
                            strictFail(parser, 'Invalid attribute name');
                            parser.state = S.ATTRIB;
                        }
                    }
                    continue;
                case S.ATTRIB_VALUE:
                    if (isWhitespace(c)) {
                        continue;
                    } else if (isQuote(c)) {
                        parser.q = c;
                        parser.state = S.ATTRIB_VALUE_QUOTED;
                    } else {
                        if (!parser.opt.unquotedAttributeValues) {
                            error(parser, 'Unquoted attribute value');
                        }
                        parser.state = S.ATTRIB_VALUE_UNQUOTED;
                        parser.attribValue = c;
                    }
                    continue;
                case S.ATTRIB_VALUE_QUOTED:
                    if (c !== parser.q) {
                        if (c === '&') {
                            parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                        } else {
                            parser.attribValue += c;
                        }
                        continue;
                    }
                    attrib(parser);
                    parser.q = '';
                    parser.state = S.ATTRIB_VALUE_CLOSED;
                    continue;
                case S.ATTRIB_VALUE_CLOSED:
                    if (isWhitespace(c)) {
                        parser.state = S.ATTRIB;
                    } else if (c === '>') {
                        openTag(parser);
                    } else if (c === '/') {
                        parser.state = S.OPEN_TAG_SLASH;
                    } else if (isMatch(nameStart, c)) {
                        strictFail(parser, 'No whitespace between attributes');
                        parser.attribName = c;
                        parser.attribValue = '';
                        parser.state = S.ATTRIB_NAME;
                    } else {
                        strictFail(parser, 'Invalid attribute name');
                    }
                    continue;
                case S.ATTRIB_VALUE_UNQUOTED:
                    if (!isAttribEnd(c)) {
                        if (c === '&') {
                            parser.state = S.ATTRIB_VALUE_ENTITY_U;
                        } else {
                            parser.attribValue += c;
                        }
                        continue;
                    }
                    attrib(parser);
                    if (c === '>') {
                        openTag(parser);
                    } else {
                        parser.state = S.ATTRIB;
                    }
                    continue;
                case S.CLOSE_TAG:
                    if (!parser.tagName) {
                        if (isWhitespace(c)) {
                            continue;
                        } else if (notMatch(nameStart, c)) {
                            if (parser.script) {
                                parser.script += '</' + c;
                                parser.state = S.SCRIPT;
                            } else {
                                strictFail(parser, 'Invalid tagname in closing tag.');
                            }
                        } else {
                            parser.tagName = c;
                        }
                    } else if (c === '>') {
                        closeTag(parser);
                    } else if (isMatch(nameBody, c)) {
                        parser.tagName += c;
                    } else if (parser.script) {
                        parser.script += '</' + parser.tagName;
                        parser.tagName = '';
                        parser.state = S.SCRIPT;
                    } else {
                        if (!isWhitespace(c)) {
                            strictFail(parser, 'Invalid tagname in closing tag');
                        }
                        parser.state = S.CLOSE_TAG_SAW_WHITE;
                    }
                    continue;
                case S.CLOSE_TAG_SAW_WHITE:
                    if (isWhitespace(c)) {
                        continue;
                    }
                    if (c === '>') {
                        closeTag(parser);
                    } else {
                        strictFail(parser, 'Invalid characters in closing tag');
                    }
                    continue;
                case S.TEXT_ENTITY:
                case S.ATTRIB_VALUE_ENTITY_Q:
                case S.ATTRIB_VALUE_ENTITY_U:
                    var returnState;
                    var buffer;
                    switch(parser.state){
                        case S.TEXT_ENTITY:
                            returnState = S.TEXT;
                            buffer = 'textNode';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_Q:
                            returnState = S.ATTRIB_VALUE_QUOTED;
                            buffer = 'attribValue';
                            break;
                        case S.ATTRIB_VALUE_ENTITY_U:
                            returnState = S.ATTRIB_VALUE_UNQUOTED;
                            buffer = 'attribValue';
                            break;
                    }
                    if (c === ';') {
                        var parsedEntity = parseEntity(parser);
                        if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                            parser.entity = '';
                            parser.state = returnState;
                            parser.write(parsedEntity);
                        } else {
                            parser[buffer] += parsedEntity;
                            parser.entity = '';
                            parser.state = returnState;
                        }
                    } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                        parser.entity += c;
                    } else {
                        strictFail(parser, 'Invalid character in entity name');
                        parser[buffer] += '&' + parser.entity + c;
                        parser.entity = '';
                        parser.state = returnState;
                    }
                    continue;
                default:
                    /* istanbul ignore next */ {
                        throw new Error(parser, 'Unknown state: ' + parser.state);
                    }
            }
        } // while
        if (parser.position >= parser.bufferCheckPosition) {
            checkBufferLength(parser);
        }
        return parser;
    }
    /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */ /* istanbul ignore next */ if (!String.fromCodePoint) {
        ;
        (function() {
            var stringFromCharCode = String.fromCharCode;
            var floor = Math.floor;
            var fromCodePoint = function() {
                var MAX_SIZE = 0x4000;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index = -1;
                var length = arguments.length;
                if (!length) {
                    return '';
                }
                var result = '';
                while(++index < length){
                    var codePoint = Number(arguments[index]);
                    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                    codePoint < 0 || // not a valid Unicode code point
                    codePoint > 0x10ffff || // not a valid Unicode code point
                    floor(codePoint) !== codePoint // not an integer
                    ) {
                        throw RangeError('Invalid code point: ' + codePoint);
                    }
                    if (codePoint <= 0xffff) {
                        // BMP code point
                        codeUnits.push(codePoint);
                    } else {
                        // Astral code point; split in surrogate halves
                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                        codePoint -= 0x10000;
                        highSurrogate = (codePoint >> 10) + 0xd800;
                        lowSurrogate = codePoint % 0x400 + 0xdc00;
                        codeUnits.push(highSurrogate, lowSurrogate);
                    }
                    if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                        result += stringFromCharCode.apply(null, codeUnits);
                        codeUnits.length = 0;
                    }
                }
                return result;
            };
            /* istanbul ignore next */ if (Object.defineProperty) {
                Object.defineProperty(String, 'fromCodePoint', {
                    value: fromCodePoint,
                    configurable: true,
                    writable: true
                });
            } else {
                String.fromCodePoint = fromCodePoint;
            }
        })();
    }
})(("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : exports);
}),
"[project]/node_modules/agent-base/dist/helpers.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.req = exports.json = exports.toBuffer = void 0;
const http = __importStar(__turbopack_context__.r("[externals]/http [external] (http, cjs)"));
const https = __importStar(__turbopack_context__.r("[externals]/https [external] (https, cjs)"));
async function toBuffer(stream) {
    let length = 0;
    const chunks = [];
    for await (const chunk of stream){
        length += chunk.length;
        chunks.push(chunk);
    }
    return Buffer.concat(chunks, length);
}
exports.toBuffer = toBuffer;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function json(stream) {
    const buf = await toBuffer(stream);
    const str = buf.toString('utf8');
    try {
        return JSON.parse(str);
    } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
    }
}
exports.json = json;
function req(url, opts = {}) {
    const href = typeof url === 'string' ? url : url.href;
    const req1 = (href.startsWith('https:') ? https : http).request(url, opts);
    const promise = new Promise((resolve, reject)=>{
        req1.once('response', resolve).once('error', reject).end();
    });
    req1.then = promise.then.bind(promise);
    return req1;
}
exports.req = req; //# sourceMappingURL=helpers.js.map
}),
"[project]/node_modules/agent-base/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Agent = void 0;
const net = __importStar(__turbopack_context__.r("[externals]/net [external] (net, cjs)"));
const http = __importStar(__turbopack_context__.r("[externals]/http [external] (http, cjs)"));
const https_1 = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
__exportStar(__turbopack_context__.r("[project]/node_modules/agent-base/dist/helpers.js [app-route] (ecmascript)"), exports);
const INTERNAL = Symbol('AgentBaseInternalState');
class Agent extends http.Agent {
    constructor(opts){
        super(opts);
        this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */ isSecureEndpoint(options) {
        if (options) {
            // First check the `secureEndpoint` property explicitly, since this
            // means that a parent `Agent` is "passing through" to this instance.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (typeof options.secureEndpoint === 'boolean') {
                return options.secureEndpoint;
            }
            // If no explicit `secure` endpoint, check if `protocol` property is
            // set. This will usually be the case since using a full string URL
            // or `URL` instance should be the most common usage.
            if (typeof options.protocol === 'string') {
                return options.protocol === 'https:';
            }
        }
        // Finally, if no `protocol` property was set, then fall back to
        // checking the stack trace of the current call stack, and try to
        // detect the "https" module.
        const { stack } = new Error();
        if (typeof stack !== 'string') return false;
        return stack.split('\n').some((l)=>l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name) {
        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no
        // need to create a fake socket because Node.js native connection pooling
        // will never be invoked.
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
            return null;
        }
        // All instances of `sockets` are expected TypeScript errors. The
        // alternative is to add it as a private property of this class but that
        // will break TypeScript subclassing.
        if (!this.sockets[name]) {
            // @ts-expect-error `sockets` is readonly in `@types/node`
            this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({
            writable: false
        });
        this.sockets[name].push(fakeSocket);
        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`
        this.totalSocketCount++;
        return fakeSocket;
    }
    decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
            return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
            sockets.splice(index, 1);
            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`
            this.totalSocketCount--;
            if (sockets.length === 0) {
                // @ts-expect-error `sockets` is readonly in `@types/node`
                delete this.sockets[name];
            }
        }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
        const secureEndpoint = this.isSecureEndpoint(options);
        if (secureEndpoint) {
            // @ts-expect-error `getName()` isn't defined in `@types/node`
            return https_1.Agent.prototype.getName.call(this, options);
        }
        // @ts-expect-error `getName()` isn't defined in `@types/node`
        return super.getName(options);
    }
    createSocket(req, options, cb) {
        const connectOpts = {
            ...options,
            secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(()=>this.connect(req, connectOpts)).then((socket)=>{
            this.decrementSockets(name, fakeSocket);
            if (socket instanceof http.Agent) {
                try {
                    // @ts-expect-error `addRequest()` isn't defined in `@types/node`
                    return socket.addRequest(req, connectOpts);
                } catch (err) {
                    return cb(err);
                }
            }
            this[INTERNAL].currentSocket = socket;
            // @ts-expect-error `createSocket()` isn't defined in `@types/node`
            super.createSocket(req, options, cb);
        }, (err)=>{
            this.decrementSockets(name, fakeSocket);
            cb(err);
        });
    }
    createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = undefined;
        if (!socket) {
            throw new Error('No socket was returned in the `connect()` function');
        }
        return socket;
    }
    get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === 'https:' ? 443 : 80);
    }
    set defaultPort(v) {
        if (this[INTERNAL]) {
            this[INTERNAL].defaultPort = v;
        }
    }
    get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? 'https:' : 'http:');
    }
    set protocol(v) {
        if (this[INTERNAL]) {
            this[INTERNAL].protocol = v;
        }
    }
}
exports.Agent = Agent; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/https-proxy-agent/dist/parse-proxy-response.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseProxyResponse = void 0;
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject)=>{
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b) ondata(b);
            else socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('readable', read);
        }
        function onend() {
            cleanup();
            debug('onend');
            reject(new Error('Proxy connection ended before receiving CONNECT response'));
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\r\n');
            const firstLine = headerParts.shift();
            if (!firstLine) {
                socket.destroy();
                return reject(new Error('No header received from proxy CONNECT response'));
            }
            const firstLineParts = firstLine.split(' ');
            const statusCode = +firstLineParts[1];
            const statusText = firstLineParts.slice(2).join(' ');
            const headers = {};
            for (const header of headerParts){
                if (!header) continue;
                const firstColon = header.indexOf(':');
                if (firstColon === -1) {
                    socket.destroy();
                    return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
                }
                const key = header.slice(0, firstColon).toLowerCase();
                const value = header.slice(firstColon + 1).trimStart();
                const current = headers[key];
                if (typeof current === 'string') {
                    headers[key] = [
                        current,
                        value
                    ];
                } else if (Array.isArray(current)) {
                    current.push(value);
                } else {
                    headers[key] = value;
                }
            }
            debug('got proxy server response: %o %o', firstLine, headers);
            cleanup();
            resolve({
                connect: {
                    statusCode,
                    statusText,
                    headers
                },
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('end', onend);
        read();
    });
}
exports.parseProxyResponse = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map
}),
"[project]/node_modules/https-proxy-agent/dist/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpsProxyAgent = void 0;
const net = __importStar(__turbopack_context__.r("[externals]/net [external] (net, cjs)"));
const tls = __importStar(__turbopack_context__.r("[externals]/tls [external] (tls, cjs)"));
const assert_1 = __importDefault(__turbopack_context__.r("[externals]/assert [external] (assert, cjs)"));
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)"));
const agent_base_1 = __turbopack_context__.r("[project]/node_modules/agent-base/dist/index.js [app-route] (ecmascript)");
const url_1 = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const parse_proxy_response_1 = __turbopack_context__.r("[project]/node_modules/https-proxy-agent/dist/parse-proxy-response.js [app-route] (ecmascript)");
const debug = (0, debug_1.default)('https-proxy-agent');
const setServernameFromNonIpHost = (options)=>{
    if (options.servername === undefined && options.host && !net.isIP(options.host)) {
        return {
            ...options,
            servername: options.host
        };
    }
    return options;
};
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 */ class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts){
        super(opts);
        this.options = {
            path: undefined
        };
        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);
        // Trim off the brackets from IPv6 addresses
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === 'https:' ? 443 : 80;
        this.connectOpts = {
            // Attempt to negotiate http/1.1 for proxy servers that support http/2
            ALPNProtocols: [
                'http/1.1'
            ],
            ...opts ? omit(opts, 'headers') : null,
            host,
            port
        };
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     */ async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
            throw new TypeError('No "host" provided');
        }
        // Create a socket connection to the proxy server.
        let socket;
        if (proxy.protocol === 'https:') {
            debug('Creating `tls.Socket`: %o', this.connectOpts);
            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
        } else {
            debug('Creating `net.Socket`: %o', this.connectOpts);
            socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === 'function' ? this.proxyHeaders() : {
            ...this.proxyHeaders
        };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
        // Inject the `Proxy-Authorization` header if necessary.
        if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers['Proxy-Connection']) {
            headers['Proxy-Connection'] = this.keepAlive ? 'Keep-Alive' : 'close';
        }
        for (const name of Object.keys(headers)){
            payload += `${name}: ${headers[name]}\r\n`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r\n`);
        const { connect, buffered } = await proxyResponsePromise;
        req.emit('proxyConnect', connect);
        this.emit('proxyConnect', connect, req);
        if (connect.statusCode === 200) {
            req.once('socket', resume);
            if (opts.secureEndpoint) {
                // The proxy is connecting to a TLS server, so upgrade
                // this socket connection to a TLS connection.
                debug('Upgrading socket connection to TLS');
                return tls.connect({
                    ...omit(setServernameFromNonIpHost(opts), 'host', 'path', 'port'),
                    socket
                });
            }
            return socket;
        }
        // Some other status code that's not 200... need to re-play the HTTP
        // header "data" events onto the socket once the HTTP machinery is
        // attached so that the node core `http` can parse and handle the
        // error status code.
        // Close the original socket, and a new "fake" socket is returned
        // instead, so that the proxy doesn't get the HTTP request
        // written to it (which may contain `Authorization` headers or other
        // sensitive data).
        //
        // See: https://hackerone.com/reports/541502
        socket.destroy();
        const fakeSocket = new net.Socket({
            writable: false
        });
        fakeSocket.readable = true;
        // Need to wait for the "socket" event to re-play the "data" events.
        req.once('socket', (s)=>{
            debug('Replaying proxy buffer for failed request');
            (0, assert_1.default)(s.listenerCount('data') > 0);
            // Replay the "buffered" Buffer onto the fake `socket`, since at
            // this point the HTTP module machinery has been hooked up for
            // the user.
            s.push(buffered);
            s.push(null);
        });
        return fakeSocket;
    }
}
HttpsProxyAgent.protocols = [
    'http',
    'https'
];
exports.HttpsProxyAgent = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for(key in obj){
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/rfdc/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = rfdc;
function copyBuffer(cur) {
    if (cur instanceof Buffer) {
        return Buffer.from(cur);
    }
    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
}
function rfdc(opts) {
    opts = opts || {};
    if (opts.circles) return rfdcCircles(opts);
    const constructorHandlers = new Map();
    constructorHandlers.set(Date, (o)=>new Date(o));
    constructorHandlers.set(Map, (o, fn)=>new Map(cloneArray(Array.from(o), fn)));
    constructorHandlers.set(Set, (o, fn)=>new Set(cloneArray(Array.from(o), fn)));
    if (opts.constructorHandlers) {
        for (const handler of opts.constructorHandlers){
            constructorHandlers.set(handler[0], handler[1]);
        }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone;
    //TURBOPACK unreachable
    ;
    function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for(let i = 0; i < keys.length; i++){
            const k = keys[i];
            const cur = a[k];
            if (typeof cur !== 'object' || cur === null) {
                a2[k] = cur;
            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                a2[k] = handler(cur, fn);
            } else if (ArrayBuffer.isView(cur)) {
                a2[k] = copyBuffer(cur);
            } else {
                a2[k] = fn(cur);
            }
        }
        return a2;
    }
    function clone(o) {
        if (typeof o !== 'object' || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
            return handler(o, clone);
        }
        const o2 = {};
        for(const k in o){
            if (Object.hasOwnProperty.call(o, k) === false) continue;
            const cur = o[k];
            if (typeof cur !== 'object' || cur === null) {
                o2[k] = cur;
            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                o2[k] = handler(cur, clone);
            } else if (ArrayBuffer.isView(cur)) {
                o2[k] = copyBuffer(cur);
            } else {
                o2[k] = clone(cur);
            }
        }
        return o2;
    }
    function cloneProto(o) {
        if (typeof o !== 'object' || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
            return handler(o, cloneProto);
        }
        const o2 = {};
        for(const k in o){
            const cur = o[k];
            if (typeof cur !== 'object' || cur === null) {
                o2[k] = cur;
            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                o2[k] = handler(cur, cloneProto);
            } else if (ArrayBuffer.isView(cur)) {
                o2[k] = copyBuffer(cur);
            } else {
                o2[k] = cloneProto(cur);
            }
        }
        return o2;
    }
}
function rfdcCircles(opts) {
    const refs = [];
    const refsNew = [];
    const constructorHandlers = new Map();
    constructorHandlers.set(Date, (o)=>new Date(o));
    constructorHandlers.set(Map, (o, fn)=>new Map(cloneArray(Array.from(o), fn)));
    constructorHandlers.set(Set, (o, fn)=>new Set(cloneArray(Array.from(o), fn)));
    if (opts.constructorHandlers) {
        for (const handler of opts.constructorHandlers){
            constructorHandlers.set(handler[0], handler[1]);
        }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone;
    //TURBOPACK unreachable
    ;
    function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for(let i = 0; i < keys.length; i++){
            const k = keys[i];
            const cur = a[k];
            if (typeof cur !== 'object' || cur === null) {
                a2[k] = cur;
            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                a2[k] = handler(cur, fn);
            } else if (ArrayBuffer.isView(cur)) {
                a2[k] = copyBuffer(cur);
            } else {
                const index = refs.indexOf(cur);
                if (index !== -1) {
                    a2[k] = refsNew[index];
                } else {
                    a2[k] = fn(cur);
                }
            }
        }
        return a2;
    }
    function clone(o) {
        if (typeof o !== 'object' || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
            return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for(const k in o){
            if (Object.hasOwnProperty.call(o, k) === false) continue;
            const cur = o[k];
            if (typeof cur !== 'object' || cur === null) {
                o2[k] = cur;
            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                o2[k] = handler(cur, clone);
            } else if (ArrayBuffer.isView(cur)) {
                o2[k] = copyBuffer(cur);
            } else {
                const i = refs.indexOf(cur);
                if (i !== -1) {
                    o2[k] = refsNew[i];
                } else {
                    o2[k] = clone(cur);
                }
            }
        }
        refs.pop();
        refsNew.pop();
        return o2;
    }
    function cloneProto(o) {
        if (typeof o !== 'object' || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
            return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for(const k in o){
            const cur = o[k];
            if (typeof cur !== 'object' || cur === null) {
                o2[k] = cur;
            } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
                o2[k] = handler(cur, cloneProto);
            } else if (ArrayBuffer.isView(cur)) {
                o2[k] = copyBuffer(cur);
            } else {
                const i = refs.indexOf(cur);
                if (i !== -1) {
                    o2[k] = refsNew[i];
                } else {
                    o2[k] = cloneProto(cur);
                }
            }
        }
        refs.pop();
        refsNew.pop();
        return o2;
    }
}
}),
"[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:configuration');
const preProcessingListeners = [];
const listeners = [];
const not = (thing)=>!thing;
const anObject = (thing)=>thing && typeof thing === 'object' && !Array.isArray(thing);
const validIdentifier = (thing)=>/^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
const anInteger = (thing)=>thing && typeof thing === 'number' && Number.isInteger(thing);
const addListener = (fn)=>{
    listeners.push(fn);
    debug(`Added listener, now ${listeners.length} listeners`);
};
const addPreProcessingListener = (fn)=>{
    preProcessingListeners.push(fn);
    debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
};
const throwExceptionIf = (config, checks, message)=>{
    const tests = Array.isArray(checks) ? checks : [
        checks
    ];
    tests.forEach((test)=>{
        if (test) {
            throw new Error(`Problem with log4js configuration: (${util.inspect(config, {
                depth: 5
            })}) - ${message}`);
        }
    });
};
const configure = (candidate)=>{
    debug('New configuration to be validated: ', candidate);
    throwExceptionIf(candidate, not(anObject(candidate)), 'must be an object.');
    debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
    preProcessingListeners.forEach((listener)=>listener(candidate));
    debug('Configuration pre-processing finished.');
    debug(`Calling configuration listeners (${listeners.length})`);
    listeners.forEach((listener)=>listener(candidate));
    debug('Configuration finished.');
};
module.exports = {
    configure,
    addListener,
    addPreProcessingListener,
    throwExceptionIf,
    anObject,
    anInteger,
    validIdentifier,
    not
};
}),
"[project]/node_modules/log4js/lib/layouts.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const dateFormat = __turbopack_context__.r("[project]/node_modules/date-format/lib/index.js [app-route] (ecmascript)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:layouts');
const styles = {
    // styles
    bold: [
        1,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    inverse: [
        7,
        27
    ],
    // grayscale
    white: [
        37,
        39
    ],
    grey: [
        90,
        39
    ],
    black: [
        90,
        39
    ],
    // colors
    blue: [
        34,
        39
    ],
    cyan: [
        36,
        39
    ],
    green: [
        32,
        39
    ],
    magenta: [
        35,
        39
    ],
    red: [
        91,
        39
    ],
    yellow: [
        33,
        39
    ]
};
function colorizeStart(style) {
    return style ? `\x1B[${styles[style][0]}m` : '';
}
function colorizeEnd(style) {
    return style ? `\x1B[${styles[style][1]}m` : '';
}
/**
 * Taken from masylum's fork (https://github.com/masylum/log4js-node)
 */ function colorize(str, style) {
    return colorizeStart(style) + str + colorizeEnd(style);
}
function timestampLevelAndCategory(loggingEvent, colour) {
    return colorize(util.format('[%s] [%s] %s - ', dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);
}
/**
 * BasicLayout is a simple layout for storing the logs. The logs are stored
 * in following format:
 * <pre>
 * [startTime] [logLevel] categoryName - message\n
 * </pre>
 *
 * @author Stephan Strittmatter
 */ function basicLayout(loggingEvent) {
    return timestampLevelAndCategory(loggingEvent) + util.format(...loggingEvent.data);
}
/**
 * colouredLayout - taken from masylum's fork.
 * same as basicLayout, but with colours.
 */ function colouredLayout(loggingEvent) {
    return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util.format(...loggingEvent.data);
}
function messagePassThroughLayout(loggingEvent) {
    return util.format(...loggingEvent.data);
}
function dummyLayout(loggingEvent) {
    return loggingEvent.data[0];
}
/**
 * PatternLayout
 * Format for specifiers is %[padding].[truncation][field]{[format]}
 * e.g. %5.10p - left pad the log level by 5 characters, up to a max of 10
 * both padding and truncation can be negative.
 * Negative truncation = trunc from end of string
 * Positive truncation = trunc from start of string
 * Negative padding = pad right
 * Positive padding = pad left
 *
 * Fields can be any of:
 *  - %r time in toLocaleTimeString format
 *  - %p log level
 *  - %c log category
 *  - %h hostname
 *  - %m log data
 *  - %m{l} where l is an integer, log data.slice(l)
 *  - %m{l,u} where l and u are integers, log data.slice(l, u)
 *  - %d date in constious formats
 *  - %% %
 *  - %n newline
 *  - %z pid
 *  - %f filename
 *  - %l line number
 *  - %o column postion
 *  - %s call stack
 *  - %C class name [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
 *  - %M method or function name [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
 *  - %A method or function alias [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
 *  - %F fully qualified caller name [#1316](https://github.com/log4js-node/log4js-node/pull/1316)
 *  - %x{<tokenname>} add dynamic tokens to your log. Tokens are specified in the tokens parameter
 *  - %X{<tokenname>} add dynamic tokens to your log. Tokens are specified in logger context
 * You can use %[ and %] to define a colored block.
 *
 * Tokens are specified as simple key:value objects.
 * The key represents the token name whereas the value can be a string or function
 * which is called to extract the value to put in the log message. If token is not
 * found, it doesn't replace the field.
 *
 * A sample token would be: { 'pid' : function() { return process.pid; } }
 *
 * Takes a pattern string, array of tokens and returns a layout function.
 * @return {Function}
 * @param pattern
 * @param tokens
 * @param timezoneOffset
 *
 * @authors ['Stephan Strittmatter', 'Jan Schmidle']
 */ function patternLayout(pattern, tokens) {
    const TTCC_CONVERSION_PATTERN = '%r %p %c - %m%n';
    const regex = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflosCMAF%])(\{([^}]+)\})?|([^%]+)/;
    pattern = pattern || TTCC_CONVERSION_PATTERN;
    function categoryName(loggingEvent, specifier) {
        let loggerName = loggingEvent.categoryName;
        if (specifier) {
            const precision = parseInt(specifier, 10);
            const loggerNameBits = loggerName.split('.');
            if (precision < loggerNameBits.length) {
                loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join('.');
            }
        }
        return loggerName;
    }
    function formatAsDate(loggingEvent, specifier) {
        let format = dateFormat.ISO8601_FORMAT;
        if (specifier) {
            format = specifier;
            // Pick up special cases
            switch(format){
                case 'ISO8601':
                case 'ISO8601_FORMAT':
                    format = dateFormat.ISO8601_FORMAT;
                    break;
                case 'ISO8601_WITH_TZ_OFFSET':
                case 'ISO8601_WITH_TZ_OFFSET_FORMAT':
                    format = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
                    break;
                case 'ABSOLUTE':
                    process.emitWarning('Pattern %d{ABSOLUTE} is deprecated in favor of %d{ABSOLUTETIME}. ' + 'Please use %d{ABSOLUTETIME} instead.', 'DeprecationWarning', 'log4js-node-DEP0003');
                    debug('[log4js-node-DEP0003]', 'DEPRECATION: Pattern %d{ABSOLUTE} is deprecated and replaced by %d{ABSOLUTETIME}.');
                // falls through
                case 'ABSOLUTETIME':
                case 'ABSOLUTETIME_FORMAT':
                    format = dateFormat.ABSOLUTETIME_FORMAT;
                    break;
                case 'DATE':
                    process.emitWarning('Pattern %d{DATE} is deprecated due to the confusion it causes when used. ' + 'Please use %d{DATETIME} instead.', 'DeprecationWarning', 'log4js-node-DEP0004');
                    debug('[log4js-node-DEP0004]', 'DEPRECATION: Pattern %d{DATE} is deprecated and replaced by %d{DATETIME}.');
                // falls through
                case 'DATETIME':
                case 'DATETIME_FORMAT':
                    format = dateFormat.DATETIME_FORMAT;
                    break;
            }
        }
        // Format the date
        return dateFormat.asString(format, loggingEvent.startTime);
    }
    function hostname() {
        return os.hostname().toString();
    }
    function formatMessage(loggingEvent, specifier) {
        let dataSlice = loggingEvent.data;
        if (specifier) {
            const [lowerBound, upperBound] = specifier.split(',');
            dataSlice = dataSlice.slice(lowerBound, upperBound);
        }
        return util.format(...dataSlice);
    }
    function endOfLine() {
        return os.EOL;
    }
    function logLevel(loggingEvent) {
        return loggingEvent.level.toString();
    }
    function startTime(loggingEvent) {
        return dateFormat.asString('hh:mm:ss', loggingEvent.startTime);
    }
    function startColour(loggingEvent) {
        return colorizeStart(loggingEvent.level.colour);
    }
    function endColour(loggingEvent) {
        return colorizeEnd(loggingEvent.level.colour);
    }
    function percent() {
        return '%';
    }
    function pid(loggingEvent) {
        return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
    }
    function clusterInfo() {
        // this used to try to return the master and worker pids,
        // but it would never have worked because master pid is not available to workers
        // leaving this here to maintain compatibility for patterns
        return pid();
    }
    function userDefined(loggingEvent, specifier) {
        if (typeof tokens[specifier] !== 'undefined') {
            return typeof tokens[specifier] === 'function' ? tokens[specifier](loggingEvent) : tokens[specifier];
        }
        return null;
    }
    function contextDefined(loggingEvent, specifier) {
        const resolver = loggingEvent.context[specifier];
        if (typeof resolver !== 'undefined') {
            return typeof resolver === 'function' ? resolver(loggingEvent) : resolver;
        }
        return null;
    }
    function fileName(loggingEvent, specifier) {
        let filename = loggingEvent.fileName || '';
        // support for ESM as it uses url instead of path for file
        /* istanbul ignore next: unsure how to simulate ESM for test coverage */ const convertFileURLToPath = function(filepath) {
            const urlPrefix = 'file://';
            if (filepath.startsWith(urlPrefix)) {
                // https://nodejs.org/api/url.html#urlfileurltopathurl
                if (typeof url.fileURLToPath === 'function') {
                    filepath = url.fileURLToPath(filepath);
                } else {
                    // posix: file:///hello/world/foo.txt -> /hello/world/foo.txt -> /hello/world/foo.txt
                    // win32: file:///C:/path/foo.txt     -> /C:/path/foo.txt     -> \C:\path\foo.txt     -> C:\path\foo.txt
                    // win32: file://nas/foo.txt          -> //nas/foo.txt        -> nas\foo.txt          -> \\nas\foo.txt
                    filepath = path.normalize(filepath.replace(new RegExp(`^${urlPrefix}`), ''));
                    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
                    ;
                }
            }
            return filepath;
        };
        filename = convertFileURLToPath(filename);
        if (specifier) {
            const fileDepth = parseInt(specifier, 10);
            const fileList = filename.split(path.sep);
            if (fileList.length > fileDepth) {
                filename = fileList.slice(-fileDepth).join(path.sep);
            }
        }
        return filename;
    }
    function lineNumber(loggingEvent) {
        return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : '';
    }
    function columnNumber(loggingEvent) {
        return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : '';
    }
    function callStack(loggingEvent) {
        return loggingEvent.callStack || '';
    }
    function className(loggingEvent) {
        return loggingEvent.className || '';
    }
    function functionName(loggingEvent) {
        return loggingEvent.functionName || '';
    }
    function functionAlias(loggingEvent) {
        return loggingEvent.functionAlias || '';
    }
    function callerName(loggingEvent) {
        return loggingEvent.callerName || '';
    }
    const replacers = {
        c: categoryName,
        d: formatAsDate,
        h: hostname,
        m: formatMessage,
        n: endOfLine,
        p: logLevel,
        r: startTime,
        '[': startColour,
        ']': endColour,
        y: clusterInfo,
        z: pid,
        '%': percent,
        x: userDefined,
        X: contextDefined,
        f: fileName,
        l: lineNumber,
        o: columnNumber,
        s: callStack,
        C: className,
        M: functionName,
        A: functionAlias,
        F: callerName
    };
    function replaceToken(conversionCharacter, loggingEvent, specifier) {
        return replacers[conversionCharacter](loggingEvent, specifier);
    }
    function truncate(truncation, toTruncate) {
        let len;
        if (truncation) {
            len = parseInt(truncation.slice(1), 10);
            // negative truncate length means truncate from end of string
            return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
        }
        return toTruncate;
    }
    function pad(padding, toPad) {
        let len;
        if (padding) {
            if (padding.charAt(0) === '-') {
                len = parseInt(padding.slice(1), 10);
                // Right pad with spaces
                while(toPad.length < len){
                    toPad += ' ';
                }
            } else {
                len = parseInt(padding, 10);
                // Left pad with spaces
                while(toPad.length < len){
                    toPad = ` ${toPad}`;
                }
            }
        }
        return toPad;
    }
    function truncateAndPad(toTruncAndPad, truncation, padding) {
        let replacement = toTruncAndPad;
        replacement = truncate(truncation, replacement);
        replacement = pad(padding, replacement);
        return replacement;
    }
    return function(loggingEvent) {
        let formattedString = '';
        let result;
        let searchString = pattern;
        while((result = regex.exec(searchString)) !== null){
            // const matchedString = result[0];
            const padding = result[1];
            const truncation = result[2];
            const conversionCharacter = result[3];
            const specifier = result[5];
            const text = result[6];
            // Check if the pattern matched was just normal text
            if (text) {
                formattedString += text.toString();
            } else {
                // Create a raw replacement string based on the conversion
                // character and specifier
                const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
                formattedString += truncateAndPad(replacement, truncation, padding);
            }
            searchString = searchString.slice(result.index + result[0].length);
        }
        return formattedString;
    };
}
const layoutMakers = {
    messagePassThrough () {
        return messagePassThroughLayout;
    },
    basic () {
        return basicLayout;
    },
    colored () {
        return colouredLayout;
    },
    coloured () {
        return colouredLayout;
    },
    pattern (config) {
        return patternLayout(config && config.pattern, config && config.tokens);
    },
    dummy () {
        return dummyLayout;
    }
};
module.exports = {
    basicLayout,
    messagePassThroughLayout,
    patternLayout,
    colouredLayout,
    coloredLayout: colouredLayout,
    dummyLayout,
    addLayout (name, serializerGenerator) {
        layoutMakers[name] = serializerGenerator;
    },
    layout (name, config) {
        return layoutMakers[name] && layoutMakers[name](config);
    }
};
}),
"[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const configuration = __turbopack_context__.r("[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)");
const validColours = [
    'white',
    'grey',
    'black',
    'blue',
    'cyan',
    'green',
    'magenta',
    'red',
    'yellow'
];
class Level {
    constructor(level, levelStr, colour){
        this.level = level;
        this.levelStr = levelStr;
        this.colour = colour;
    }
    toString() {
        return this.levelStr;
    }
    /**
   * converts given String to corresponding Level
   * @param {(Level|string)} sArg -- String value of Level OR Log4js.Level
   * @param {Level} [defaultLevel] -- default Level, if no String representation
   * @return {Level}
   */ static getLevel(sArg, defaultLevel) {
        if (!sArg) {
            return defaultLevel;
        }
        if (sArg instanceof Level) {
            return sArg;
        }
        // a json-serialised level won't be an instance of Level (see issue #768)
        if (sArg instanceof Object && sArg.levelStr) {
            sArg = sArg.levelStr;
        }
        return Level[sArg.toString().toUpperCase()] || defaultLevel;
    }
    static addLevels(customLevels) {
        if (customLevels) {
            const levels = Object.keys(customLevels);
            levels.forEach((l)=>{
                const levelStr = l.toUpperCase();
                Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);
                const existingLevelIndex = Level.levels.findIndex((lvl)=>lvl.levelStr === levelStr);
                if (existingLevelIndex > -1) {
                    Level.levels[existingLevelIndex] = Level[levelStr];
                } else {
                    Level.levels.push(Level[levelStr]);
                }
            });
            Level.levels.sort((a, b)=>a.level - b.level);
        }
    }
    isLessThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === 'string') {
            otherLevel = Level.getLevel(otherLevel);
        }
        return this.level <= otherLevel.level;
    }
    isGreaterThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === 'string') {
            otherLevel = Level.getLevel(otherLevel);
        }
        return this.level >= otherLevel.level;
    }
    isEqualTo(otherLevel) {
        if (typeof otherLevel === 'string') {
            otherLevel = Level.getLevel(otherLevel);
        }
        return this.level === otherLevel.level;
    }
}
Level.levels = [];
Level.addLevels({
    ALL: {
        value: Number.MIN_VALUE,
        colour: 'grey'
    },
    TRACE: {
        value: 5000,
        colour: 'blue'
    },
    DEBUG: {
        value: 10000,
        colour: 'cyan'
    },
    INFO: {
        value: 20000,
        colour: 'green'
    },
    WARN: {
        value: 30000,
        colour: 'yellow'
    },
    ERROR: {
        value: 40000,
        colour: 'red'
    },
    FATAL: {
        value: 50000,
        colour: 'magenta'
    },
    MARK: {
        value: 9007199254740992,
        colour: 'grey'
    },
    OFF: {
        value: Number.MAX_VALUE,
        colour: 'grey'
    }
});
configuration.addListener((config)=>{
    const levelConfig = config.levels;
    if (levelConfig) {
        configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig)), 'levels must be an object');
        const newLevels = Object.keys(levelConfig);
        newLevels.forEach((l)=>{
            configuration.throwExceptionIf(config, configuration.not(configuration.validIdentifier(l)), `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);
            configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig[l])), `level "${l}" must be an object`);
            configuration.throwExceptionIf(config, configuration.not(levelConfig[l].value), `level "${l}" must have a 'value' property`);
            configuration.throwExceptionIf(config, configuration.not(configuration.anInteger(levelConfig[l].value)), `level "${l}".value must have an integer value`);
            configuration.throwExceptionIf(config, configuration.not(levelConfig[l].colour), `level "${l}" must have a 'colour' property`);
            configuration.throwExceptionIf(config, configuration.not(validColours.indexOf(levelConfig[l].colour) > -1), `level "${l}".colour must be one of ${validColours.join(', ')}`);
        });
    }
});
configuration.addListener((config)=>{
    Level.addLevels(config.levels);
});
module.exports = Level;
}),
"[project]/node_modules/log4js/lib/LoggingEvent.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint max-classes-per-file: ["error", 2] */ /* eslint no-underscore-dangle: ["error", { "allow": ["_getLocationKeys"] }] */ const flatted = __turbopack_context__.r("[project]/node_modules/flatted/cjs/index.js [app-route] (ecmascript)");
const levels = __turbopack_context__.r("[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)");
class SerDe {
    constructor(){
        const deserialise = {
            __LOG4JS_undefined__: undefined,
            __LOG4JS_NaN__: Number('abc'),
            __LOG4JS_Infinity__: 1 / 0,
            '__LOG4JS_-Infinity__': -1 / 0
        };
        this.deMap = deserialise;
        this.serMap = {};
        Object.keys(this.deMap).forEach((key)=>{
            const value = this.deMap[key];
            this.serMap[value] = key;
        });
    }
    canSerialise(key) {
        if (typeof key === 'string') return false;
        return key in this.serMap;
    }
    serialise(key) {
        if (this.canSerialise(key)) return this.serMap[key];
        return key;
    }
    canDeserialise(key) {
        return key in this.deMap;
    }
    deserialise(key) {
        if (this.canDeserialise(key)) return this.deMap[key];
        return key;
    }
}
const serde = new SerDe();
/**
 * @name LoggingEvent
 * @namespace Log4js
 */ class LoggingEvent {
    /**
   * Models a logging event.
   * @constructor
   * @param {string} categoryName name of category
   * @param {Log4js.Level} level level of message
   * @param {Array} data objects to log
   * @param {Error} [error]
   * @author Seth Chisamore
   */ constructor(categoryName, level, data, context, location, error){
        this.startTime = new Date();
        this.categoryName = categoryName;
        this.data = data;
        this.level = level;
        this.context = Object.assign({}, context); // eslint-disable-line prefer-object-spread
        this.pid = process.pid;
        this.error = error;
        if (typeof location !== 'undefined') {
            if (!location || typeof location !== 'object' || Array.isArray(location)) throw new TypeError('Invalid location type passed to LoggingEvent constructor');
            this.constructor._getLocationKeys().forEach((key)=>{
                if (typeof location[key] !== 'undefined') this[key] = location[key];
            });
        }
    }
    /** @private */ static _getLocationKeys() {
        return [
            'fileName',
            'lineNumber',
            'columnNumber',
            'callStack',
            'className',
            'functionName',
            'functionAlias',
            'callerName'
        ];
    }
    serialise() {
        return flatted.stringify(this, (key, value)=>{
            // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.
            // The following allows us to serialize errors (semi) correctly.
            if (value instanceof Error) {
                // eslint-disable-next-line prefer-object-spread
                value = Object.assign({
                    message: value.message,
                    stack: value.stack
                }, value);
            }
            // JSON.stringify({a: Number('abc'), b: 1/0, c: -1/0}) returns {a: null, b: null, c: null}.
            // The following allows us to serialize to NaN, Infinity and -Infinity correctly.
            // JSON.stringify([undefined]) returns [null].
            // The following allows us to serialize to undefined correctly.
            return serde.serialise(value);
        });
    }
    static deserialise(serialised) {
        let event;
        try {
            const rehydratedEvent = flatted.parse(serialised, (key, value)=>{
                if (value && value.message && value.stack) {
                    const fakeError = new Error(value);
                    Object.keys(value).forEach((k)=>{
                        fakeError[k] = value[k];
                    });
                    value = fakeError;
                }
                return serde.deserialise(value);
            });
            this._getLocationKeys().forEach((key)=>{
                if (typeof rehydratedEvent[key] !== 'undefined') {
                    if (!rehydratedEvent.location) rehydratedEvent.location = {};
                    rehydratedEvent.location[key] = rehydratedEvent[key];
                }
            });
            event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context, rehydratedEvent.location, rehydratedEvent.error);
            event.startTime = new Date(rehydratedEvent.startTime);
            event.pid = rehydratedEvent.pid;
            if (rehydratedEvent.cluster) {
                event.cluster = rehydratedEvent.cluster;
            }
        } catch (e) {
            event = new LoggingEvent('log4js', levels.ERROR, [
                'Unable to parse log:',
                serialised,
                'because: ',
                e
            ]);
        }
        return event;
    }
}
module.exports = LoggingEvent;
}),
"[project]/node_modules/log4js/lib/clustering.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:clustering');
const LoggingEvent = __turbopack_context__.r("[project]/node_modules/log4js/lib/LoggingEvent.js [app-route] (ecmascript)");
const configuration = __turbopack_context__.r("[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)");
let disabled = false;
let cluster = null;
try {
    // eslint-disable-next-line global-require
    cluster = __turbopack_context__.r("[externals]/cluster [external] (cluster, cjs)");
} catch (e) {
    debug('cluster module not present');
    disabled = true;
}
const listeners = [];
let pm2 = false;
let pm2InstanceVar = 'NODE_APP_INSTANCE';
const isPM2Master = ()=>pm2 && process.env[pm2InstanceVar] === '0';
const isMaster = ()=>disabled || cluster && cluster.isMaster || isPM2Master();
const sendToListeners = (logEvent)=>{
    listeners.forEach((l)=>l(logEvent));
};
// in a multi-process node environment, worker loggers will use
// process.send
const receiver = (worker, message)=>{
    // prior to node v6, the worker parameter was not passed (args were message, handle)
    debug('cluster message received from worker ', worker, ': ', message);
    if (worker.topic && worker.data) {
        message = worker;
        worker = undefined;
    }
    if (message && message.topic && message.topic === 'log4js:message') {
        debug('received message: ', message.data);
        const logEvent = LoggingEvent.deserialise(message.data);
        sendToListeners(logEvent);
    }
};
if (!disabled) {
    configuration.addListener((config)=>{
        // clear out the listeners, because configure has been called.
        listeners.length = 0;
        ({ pm2, disableClustering: disabled, pm2InstanceVar = 'NODE_APP_INSTANCE' } = config);
        debug(`clustering disabled ? ${disabled}`);
        debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
        debug(`pm2 enabled ? ${pm2}`);
        debug(`pm2InstanceVar = ${pm2InstanceVar}`);
        debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
        // just in case configure is called after shutdown
        if (pm2) {
            process.removeListener('message', receiver);
        }
        if (cluster && cluster.removeListener) {
            cluster.removeListener('message', receiver);
        }
        if (disabled || config.disableClustering) {
            debug('Not listening for cluster messages, because clustering disabled.');
        } else if (isPM2Master()) {
            // PM2 cluster support
            // PM2 runs everything as workers - install pm2-intercom for this to work.
            // we only want one of the app instances to write logs
            debug('listening for PM2 broadcast messages');
            process.on('message', receiver);
        } else if (cluster && cluster.isMaster) {
            debug('listening for cluster messages');
            cluster.on('message', receiver);
        } else {
            debug('not listening for messages, because we are not a master process');
        }
    });
}
module.exports = {
    onlyOnMaster: (fn, notMaster)=>isMaster() ? fn() : notMaster,
    isMaster,
    send: (msg)=>{
        if (isMaster()) {
            sendToListeners(msg);
        } else {
            if (!pm2) {
                msg.cluster = {
                    workerId: cluster.worker.id,
                    worker: process.pid
                };
            }
            process.send({
                topic: 'log4js:message',
                data: msg.serialise()
            });
        }
    },
    onMessage: (listener)=>{
        listeners.push(listener);
    }
};
}),
"[project]/node_modules/log4js/lib/appenders/adapters.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function maxFileSizeUnitTransform(maxLogSize) {
    if (typeof maxLogSize === 'number' && Number.isInteger(maxLogSize)) {
        return maxLogSize;
    }
    const units = {
        K: 1024,
        M: 1024 * 1024,
        G: 1024 * 1024 * 1024
    };
    const validUnit = Object.keys(units);
    const unit = maxLogSize.slice(-1).toLocaleUpperCase();
    const value = maxLogSize.slice(0, -1).trim();
    if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
        throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
    } else {
        return value * units[unit];
    }
}
function adapter(configAdapter, config) {
    const newConfig = Object.assign({}, config); // eslint-disable-line prefer-object-spread
    Object.keys(configAdapter).forEach((key)=>{
        if (newConfig[key]) {
            newConfig[key] = configAdapter[key](config[key]);
        }
    });
    return newConfig;
}
function fileAppenderAdapter(config) {
    const configAdapter = {
        maxLogSize: maxFileSizeUnitTransform
    };
    return adapter(configAdapter, config);
}
const adapters = {
    dateFile: fileAppenderAdapter,
    file: fileAppenderAdapter,
    fileSync: fileAppenderAdapter
};
module.exports.modifyConfig = (config)=>adapters[config.type] ? adapters[config.type](config) : config;
}),
"[project]/node_modules/log4js/lib/appenders/console.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// eslint-disable-next-line no-console
const consoleLog = console.log.bind(console);
function consoleAppender(layout, timezoneOffset) {
    return (loggingEvent)=>{
        consoleLog(layout(loggingEvent, timezoneOffset));
    };
}
function configure(config, layouts) {
    let layout = layouts.colouredLayout;
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    return consoleAppender(layout, config.timezoneOffset);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/stdout.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function stdoutAppender(layout, timezoneOffset) {
    return (loggingEvent)=>{
        process.stdout.write(`${layout(loggingEvent, timezoneOffset)}\n`);
    };
}
function configure(config, layouts) {
    let layout = layouts.colouredLayout;
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    return stdoutAppender(layout, config.timezoneOffset);
}
exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/stderr.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function stderrAppender(layout, timezoneOffset) {
    return (loggingEvent)=>{
        process.stderr.write(`${layout(loggingEvent, timezoneOffset)}\n`);
    };
}
function configure(config, layouts) {
    let layout = layouts.colouredLayout;
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    return stderrAppender(layout, config.timezoneOffset);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/logLevelFilter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

function logLevelFilter(minLevelString, maxLevelString, appender, levels) {
    const minLevel = levels.getLevel(minLevelString);
    const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
    return (logEvent)=>{
        const eventLevel = logEvent.level;
        if (minLevel.isLessThanOrEqualTo(eventLevel) && maxLevel.isGreaterThanOrEqualTo(eventLevel)) {
            appender(logEvent);
        }
    };
}
function configure(config, layouts, findAppender, levels) {
    const appender = findAppender(config.appender);
    return logLevelFilter(config.level, config.maxLevel, appender, levels);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/categoryFilter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:categoryFilter');
function categoryFilter(excludes, appender) {
    if (typeof excludes === 'string') excludes = [
        excludes
    ];
    return (logEvent)=>{
        debug(`Checking ${logEvent.categoryName} against ${excludes}`);
        if (excludes.indexOf(logEvent.categoryName) === -1) {
            debug('Not excluded, sending to appender');
            appender(logEvent);
        }
    };
}
function configure(config, layouts, findAppender) {
    const appender = findAppender(config.appender);
    return categoryFilter(config.exclude, appender);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/noLogFilter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:noLogFilter');
/**
 * The function removes empty or null regexp from the array
 * @param {string[]} regexp
 * @returns {string[]} a filtered string array with not empty or null regexp
 */ function removeNullOrEmptyRegexp(regexp) {
    const filtered = regexp.filter((el)=>el != null && el !== '');
    return filtered;
}
/**
 * Returns a function that will exclude the events in case they match
 * with the regular expressions provided
 * @param {(string|string[])} filters contains the regexp that will be used for the evaluation
 * @param {*} appender
 * @returns {function}
 */ function noLogFilter(filters, appender) {
    return (logEvent)=>{
        debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
        if (typeof filters === 'string') {
            filters = [
                filters
            ];
        }
        filters = removeNullOrEmptyRegexp(filters);
        const regex = new RegExp(filters.join('|'), 'i');
        if (filters.length === 0 || logEvent.data.findIndex((value)=>regex.test(value)) < 0) {
            debug('Not excluded, sending to appender');
            appender(logEvent);
        }
    };
}
function configure(config, layouts, findAppender) {
    const appender = findAppender(config.appender);
    return noLogFilter(config.exclude, appender);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/file.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:file');
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const streams = __turbopack_context__.r("[project]/node_modules/streamroller/lib/index.js [app-route] (ecmascript)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const eol = os.EOL;
let mainSighupListenerStarted = false;
const sighupListeners = new Set();
function mainSighupHandler() {
    sighupListeners.forEach((app)=>{
        app.sighupHandler();
    });
}
/**
 * File Appender writing the logs to a text file. Supports rolling of logs by size.
 *
 * @param file the file log messages will be written to
 * @param layout a function that takes a logEvent and returns a string
 *   (defaults to basicLayout).
 * @param logSize - the maximum size (in bytes) for a log file,
 *   if not provided then logs won't be rotated.
 * @param numBackups - the number of log files to keep after logSize
 *   has been reached (default 5)
 * @param options - options to be passed to the underlying stream
 * @param timezoneOffset - optional timezone offset in minutes (default system local)
 */ function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {
    if (typeof file !== 'string' || file.length === 0) {
        throw new Error(`Invalid filename: ${file}`);
    } else if (file.endsWith(path.sep)) {
        throw new Error(`Filename is a directory: ${file}`);
    } else if (file.indexOf(`~${path.sep}`) === 0) {
        // handle ~ expansion: https://github.com/nodejs/node/issues/684
        // exclude ~ and ~filename as these can be valid files
        file = file.replace('~', os.homedir());
    }
    file = path.normalize(file);
    numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
    debug('Creating file appender (', file, ', ', logSize, ', ', numBackups, ', ', options, ', ', timezoneOffset, ')');
    function openTheStream(filePath, fileSize, numFiles, opt) {
        const stream = new streams.RollingFileStream(filePath, fileSize, numFiles, opt);
        stream.on('error', (err)=>{
            // eslint-disable-next-line no-console
            console.error('log4js.fileAppender - Writing to file %s, error happened ', filePath, err);
        });
        stream.on('drain', ()=>{
            process.emit('log4js:pause', false);
        });
        return stream;
    }
    let writer = openTheStream(file, logSize, numBackups, options);
    const app = function(loggingEvent) {
        if (!writer.writable) {
            return;
        }
        if (options.removeColor === true) {
            // eslint-disable-next-line no-control-regex
            const regex = /\x1b[[0-9;]*m/g;
            loggingEvent.data = loggingEvent.data.map((d)=>{
                if (typeof d === 'string') return d.replace(regex, '');
                return d;
            });
        }
        if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, 'utf8')) {
            process.emit('log4js:pause', true);
        }
    };
    app.reopen = function() {
        writer.end(()=>{
            writer = openTheStream(file, logSize, numBackups, options);
        });
    };
    app.sighupHandler = function() {
        debug('SIGHUP handler called.');
        app.reopen();
    };
    app.shutdown = function(complete) {
        sighupListeners.delete(app);
        if (sighupListeners.size === 0 && mainSighupListenerStarted) {
            process.removeListener('SIGHUP', mainSighupHandler);
            mainSighupListenerStarted = false;
        }
        writer.end('', 'utf-8', complete);
    };
    // On SIGHUP, close and reopen all files. This allows this appender to work with
    // logrotate. Note that if you are using logrotate, you should not set
    // `logSize`.
    sighupListeners.add(app);
    if (!mainSighupListenerStarted) {
        process.on('SIGHUP', mainSighupHandler);
        mainSighupListenerStarted = true;
    }
    return app;
}
function configure(config, layouts) {
    let layout = layouts.basicLayout;
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    // security default (instead of relying on streamroller default)
    config.mode = config.mode || 0o600;
    return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config, config.timezoneOffset);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/dateFile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const streams = __turbopack_context__.r("[project]/node_modules/streamroller/lib/index.js [app-route] (ecmascript)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const eol = os.EOL;
function openTheStream(filename, pattern, options) {
    const stream = new streams.DateRollingFileStream(filename, pattern, options);
    stream.on('error', (err)=>{
        // eslint-disable-next-line no-console
        console.error('log4js.dateFileAppender - Writing to file %s, error happened ', filename, err);
    });
    stream.on('drain', ()=>{
        process.emit('log4js:pause', false);
    });
    return stream;
}
/**
 * File appender that rolls files according to a date pattern.
 * @param filename base filename.
 * @param pattern the format that will be added to the end of filename when rolling,
 *          also used to check when to roll files - defaults to '.yyyy-MM-dd'
 * @param layout layout function for log messages - defaults to basicLayout
 * @param options - options to be passed to the underlying stream
 * @param timezoneOffset - optional timezone offset in minutes (default system local)
 */ function appender(filename, pattern, layout, options, timezoneOffset) {
    // the options for file appender use maxLogSize, but the docs say any file appender
    // options should work for dateFile as well.
    options.maxSize = options.maxLogSize;
    const writer = openTheStream(filename, pattern, options);
    const app = function(logEvent) {
        if (!writer.writable) {
            return;
        }
        if (!writer.write(layout(logEvent, timezoneOffset) + eol, 'utf8')) {
            process.emit('log4js:pause', true);
        }
    };
    app.shutdown = function(complete) {
        writer.end('', 'utf-8', complete);
    };
    return app;
}
function configure(config, layouts) {
    let layout = layouts.basicLayout;
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    if (!config.alwaysIncludePattern) {
        config.alwaysIncludePattern = false;
    }
    // security default (instead of relying on streamroller default)
    config.mode = config.mode || 0o600;
    return appender(config.filename, config.pattern, layout, config, config.timezoneOffset);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/fileSync.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:fileSync');
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const eol = os.EOL;
function touchFile(file, options) {
    // attempt to create the directory
    const mkdir = (dir)=>{
        try {
            return fs.mkdirSync(dir, {
                recursive: true
            });
        } catch (e) {
            // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)
            // recursive creation of parent first
            if (e.code === 'ENOENT') {
                mkdir(path.dirname(dir));
                return mkdir(dir);
            }
            // throw error for all except EEXIST and EROFS (read-only filesystem)
            if (e.code !== 'EEXIST' && e.code !== 'EROFS') {
                throw e;
            } else {
                try {
                    if (fs.statSync(dir).isDirectory()) {
                        return dir;
                    }
                    throw e;
                } catch (err) {
                    throw e;
                }
            }
        }
    };
    mkdir(path.dirname(file));
    // try to throw EISDIR, EROFS, EACCES
    fs.appendFileSync(file, '', {
        mode: options.mode,
        flag: options.flags
    });
}
class RollingFileSync {
    constructor(filename, maxLogSize, backups, options){
        debug('In RollingFileStream');
        if (maxLogSize < 0) {
            throw new Error(`maxLogSize (${maxLogSize}) should be > 0`);
        }
        this.filename = filename;
        this.size = maxLogSize;
        this.backups = backups;
        this.options = options;
        this.currentSize = 0;
        function currentFileSize(file) {
            let fileSize = 0;
            try {
                fileSize = fs.statSync(file).size;
            } catch (e) {
                // file does not exist
                touchFile(file, options);
            }
            return fileSize;
        }
        this.currentSize = currentFileSize(this.filename);
    }
    shouldRoll() {
        debug('should roll with current size %d, and max size %d', this.currentSize, this.size);
        return this.currentSize >= this.size;
    }
    roll(filename) {
        const that = this;
        const nameMatcher = new RegExp(`^${path.basename(filename)}`);
        function justTheseFiles(item) {
            return nameMatcher.test(item);
        }
        function index(filename_) {
            return parseInt(filename_.slice(`${path.basename(filename)}.`.length), 10) || 0;
        }
        function byIndex(a, b) {
            return index(a) - index(b);
        }
        function increaseFileIndex(fileToRename) {
            const idx = index(fileToRename);
            debug(`Index of ${fileToRename} is ${idx}`);
            if (that.backups === 0) {
                fs.truncateSync(filename, 0);
            } else if (idx < that.backups) {
                // on windows, you can get a EEXIST error if you rename a file to an existing file
                // so, we'll try to delete the file we're renaming to first
                try {
                    fs.unlinkSync(`${filename}.${idx + 1}`);
                } catch (e) {
                // ignore err: if we could not delete, it's most likely that it doesn't exist
                }
                debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
                fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
            }
        }
        function renameTheFiles() {
            // roll the backups (rename file.n to file.n+1, where n <= numBackups)
            debug('Renaming the old files');
            const files = fs.readdirSync(path.dirname(filename));
            files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
        }
        debug('Rolling, rolling, rolling');
        renameTheFiles();
    }
    // eslint-disable-next-line no-unused-vars
    write(chunk, encoding) {
        const that = this;
        function writeTheChunk() {
            debug('writing the chunk to the file');
            that.currentSize += chunk.length;
            fs.appendFileSync(that.filename, chunk);
        }
        debug('in write');
        if (this.shouldRoll()) {
            this.currentSize = 0;
            this.roll(this.filename);
        }
        writeTheChunk();
    }
}
/**
 * File Appender writing the logs to a text file. Supports rolling of logs by size.
 *
 * @param file the file log messages will be written to
 * @param layout a function that takes a logevent and returns a string
 *   (defaults to basicLayout).
 * @param logSize - the maximum size (in bytes) for a log file,
 *   if not provided then logs won't be rotated.
 * @param numBackups - the number of log files to keep after logSize
 *   has been reached (default 5)
 * @param options - options to be passed to the underlying stream
 * @param timezoneOffset - optional timezone offset in minutes (default system local)
 */ function fileAppender(file, layout, logSize, numBackups, options, timezoneOffset) {
    if (typeof file !== 'string' || file.length === 0) {
        throw new Error(`Invalid filename: ${file}`);
    } else if (file.endsWith(path.sep)) {
        throw new Error(`Filename is a directory: ${file}`);
    } else if (file.indexOf(`~${path.sep}`) === 0) {
        // handle ~ expansion: https://github.com/nodejs/node/issues/684
        // exclude ~ and ~filename as these can be valid files
        file = file.replace('~', os.homedir());
    }
    file = path.normalize(file);
    numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
    debug('Creating fileSync appender (', file, ', ', logSize, ', ', numBackups, ', ', options, ', ', timezoneOffset, ')');
    function openTheStream(filePath, fileSize, numFiles) {
        let stream;
        if (fileSize) {
            stream = new RollingFileSync(filePath, fileSize, numFiles, options);
        } else {
            stream = ((f)=>{
                // touch the file to apply flags (like w to truncate the file)
                touchFile(f, options);
                return {
                    write (data) {
                        fs.appendFileSync(f, data);
                    }
                };
            })(filePath);
        }
        return stream;
    }
    const logFile = openTheStream(file, logSize, numBackups);
    return (loggingEvent)=>{
        logFile.write(layout(loggingEvent, timezoneOffset) + eol);
    };
}
function configure(config, layouts) {
    let layout = layouts.basicLayout;
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    const options = {
        flags: config.flags || 'a',
        encoding: config.encoding || 'utf8',
        mode: config.mode || 0o600
    };
    return fileAppender(config.filename, layout, config.maxLogSize, config.backups, options, config.timezoneOffset);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/tcp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:tcp');
const net = __turbopack_context__.r("[externals]/net [external] (net, cjs)");
function appender(config, layout) {
    let canWrite = false;
    const buffer = [];
    let socket;
    let shutdownAttempts = 3;
    let endMsg = '__LOG4JS__';
    function write(loggingEvent) {
        debug('Writing log event to socket');
        canWrite = socket.write(`${layout(loggingEvent)}${endMsg}`, 'utf8');
    }
    function emptyBuffer() {
        let evt;
        debug('emptying buffer');
        while(evt = buffer.shift()){
            write(evt);
        }
    }
    function createSocket() {
        debug(`appender creating socket to ${config.host || 'localhost'}:${config.port || 5000}`);
        endMsg = `${config.endMsg || '__LOG4JS__'}`;
        socket = net.createConnection(config.port || 5000, config.host || 'localhost');
        socket.on('connect', ()=>{
            debug('socket connected');
            emptyBuffer();
            canWrite = true;
        });
        socket.on('drain', ()=>{
            debug('drain event received, emptying buffer');
            canWrite = true;
            emptyBuffer();
        });
        socket.on('timeout', socket.end.bind(socket));
        socket.on('error', (e)=>{
            debug('connection error', e);
            canWrite = false;
            emptyBuffer();
        });
        socket.on('close', createSocket);
    }
    createSocket();
    function log(loggingEvent) {
        if (canWrite) {
            write(loggingEvent);
        } else {
            debug('buffering log event because it cannot write at the moment');
            buffer.push(loggingEvent);
        }
    }
    log.shutdown = function(cb) {
        debug('shutdown called');
        if (buffer.length && shutdownAttempts) {
            debug('buffer has items, waiting 100ms to empty');
            shutdownAttempts -= 1;
            setTimeout(()=>{
                log.shutdown(cb);
            }, 100);
        } else {
            socket.removeAllListeners('close');
            socket.end(cb);
        }
    };
    return log;
}
function configure(config, layouts) {
    debug(`configure with config = ${config}`);
    let layout = function(loggingEvent) {
        return loggingEvent.serialise();
    };
    if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
    }
    return appender(config, layout);
}
module.exports.configure = configure;
}),
"[project]/node_modules/log4js/lib/appenders/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:appenders');
const configuration = __turbopack_context__.r("[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)");
const clustering = __turbopack_context__.r("[project]/node_modules/log4js/lib/clustering.js [app-route] (ecmascript)");
const levels = __turbopack_context__.r("[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)");
const layouts = __turbopack_context__.r("[project]/node_modules/log4js/lib/layouts.js [app-route] (ecmascript)");
const adapters = __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/adapters.js [app-route] (ecmascript)");
// pre-load the core appenders so that webpack can find them
const coreAppenders = new Map();
coreAppenders.set('console', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/console.js [app-route] (ecmascript)"));
coreAppenders.set('stdout', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/stdout.js [app-route] (ecmascript)"));
coreAppenders.set('stderr', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/stderr.js [app-route] (ecmascript)"));
coreAppenders.set('logLevelFilter', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/logLevelFilter.js [app-route] (ecmascript)"));
coreAppenders.set('categoryFilter', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/categoryFilter.js [app-route] (ecmascript)"));
coreAppenders.set('noLogFilter', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/noLogFilter.js [app-route] (ecmascript)"));
coreAppenders.set('file', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/file.js [app-route] (ecmascript)"));
coreAppenders.set('dateFile', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/dateFile.js [app-route] (ecmascript)"));
coreAppenders.set('fileSync', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/fileSync.js [app-route] (ecmascript)"));
coreAppenders.set('tcp', __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/tcp.js [app-route] (ecmascript)"));
const appenders = new Map();
const tryLoading = (modulePath, config)=>{
    let resolvedPath;
    try {
        const modulePathCJS = `${modulePath}.cjs`;
        resolvedPath = (()=>{
            const e = new Error("Cannot find module 'unknown'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
        debug('Loading module from ', modulePathCJS);
    } catch (e) {
        resolvedPath = modulePath;
        debug('Loading module from ', modulePath);
    }
    try {
        // eslint-disable-next-line global-require, import/no-dynamic-require
        return (()=>{
            const e = new Error("Cannot find module as expression is too dynamic");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
        })();
    } catch (e) {
        // if the module was found, and we still got an error, then raise it
        configuration.throwExceptionIf(config, e.code !== 'MODULE_NOT_FOUND', `appender "${modulePath}" could not be loaded (error was: ${e})`);
        return undefined;
    }
};
const loadAppenderModule = (type, config)=>coreAppenders.get(type) || tryLoading(`./${type}`, config) || tryLoading(type, config) || /*TURBOPACK member replacement*/ __turbopack_context__.t.main && /*TURBOPACK member replacement*/ __turbopack_context__.t.main.filename && tryLoading(path.join(path.dirname(/*TURBOPACK member replacement*/ __turbopack_context__.t.main.filename), type), config) || tryLoading(path.join(process.cwd(), type), config);
const appendersLoading = new Set();
const getAppender = (name, config)=>{
    if (appenders.has(name)) return appenders.get(name);
    if (!config.appenders[name]) return false;
    if (appendersLoading.has(name)) throw new Error(`Dependency loop detected for appender ${name}.`);
    appendersLoading.add(name);
    debug(`Creating appender ${name}`);
    // eslint-disable-next-line no-use-before-define
    const appender = createAppender(name, config);
    appendersLoading.delete(name);
    appenders.set(name, appender);
    return appender;
};
const createAppender = (name, config)=>{
    const appenderConfig = config.appenders[name];
    const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
    configuration.throwExceptionIf(config, configuration.not(appenderModule), `appender "${name}" is not valid (type "${appenderConfig.type}" could not be found)`);
    if (appenderModule.appender) {
        process.emitWarning(`Appender ${appenderConfig.type} exports an appender function.`, 'DeprecationWarning', 'log4js-node-DEP0001');
        debug('[log4js-node-DEP0001]', `DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
    }
    if (appenderModule.shutdown) {
        process.emitWarning(`Appender ${appenderConfig.type} exports a shutdown function.`, 'DeprecationWarning', 'log4js-node-DEP0002');
        debug('[log4js-node-DEP0002]', `DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
    }
    debug(`${name}: clustering.isMaster ? ${clustering.isMaster()}`);
    debug(// eslint-disable-next-line global-require
    `${name}: appenderModule is ${__turbopack_context__.r("[externals]/util [external] (util, cjs)").inspect(appenderModule)}`);
    return clustering.onlyOnMaster(()=>{
        debug(`calling appenderModule.configure for ${name} / ${appenderConfig.type}`);
        return appenderModule.configure(adapters.modifyConfig(appenderConfig), layouts, (appender)=>getAppender(appender, config), levels);
    }, /* istanbul ignore next: fn never gets called by non-master yet needed to pass config validation */ ()=>{});
};
const setup = (config)=>{
    appenders.clear();
    appendersLoading.clear();
    if (!config) {
        return;
    }
    const usedAppenders = [];
    Object.values(config.categories).forEach((category)=>{
        usedAppenders.push(...category.appenders);
    });
    Object.keys(config.appenders).forEach((name)=>{
        // dodgy hard-coding of special case for tcp-server and multiprocess which may not have
        // any categories associated with it, but needs to be started up anyway
        if (usedAppenders.includes(name) || config.appenders[name].type === 'tcp-server' || config.appenders[name].type === 'multiprocess') {
            getAppender(name, config);
        }
    });
};
const init = ()=>{
    setup();
};
init();
configuration.addListener((config)=>{
    configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.appenders)), 'must have a property "appenders" of type object.');
    const appenderNames = Object.keys(config.appenders);
    configuration.throwExceptionIf(config, configuration.not(appenderNames.length), 'must define at least one appender.');
    appenderNames.forEach((name)=>{
        configuration.throwExceptionIf(config, configuration.not(config.appenders[name].type), `appender "${name}" is not valid (must be an object with property "type")`);
    });
});
configuration.addListener(setup);
module.exports = appenders;
module.exports.init = init;
}),
"[project]/node_modules/log4js/lib/categories.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:categories');
const configuration = __turbopack_context__.r("[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)");
const levels = __turbopack_context__.r("[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)");
const appenders = __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/index.js [app-route] (ecmascript)");
const categories = new Map();
/**
 * Add inherited config to this category.  That includes extra appenders from parent,
 * and level, if none is set on this category.
 * This is recursive, so each parent also gets loaded with inherited appenders.
 * Inheritance is blocked if a category has inherit=false
 * @param  {*} config
 * @param  {*} category the child category
 * @param  {string} categoryName dotted path to category
 * @return {void}
 */ function inheritFromParent(config, category, categoryName) {
    if (category.inherit === false) return;
    const lastDotIndex = categoryName.lastIndexOf('.');
    if (lastDotIndex < 0) return; // category is not a child
    const parentCategoryName = categoryName.slice(0, lastDotIndex);
    let parentCategory = config.categories[parentCategoryName];
    if (!parentCategory) {
        // parent is missing, so implicitly create it, so that it can inherit from its parents
        parentCategory = {
            inherit: true,
            appenders: []
        };
    }
    // make sure parent has had its inheritance taken care of before pulling its properties to this child
    inheritFromParent(config, parentCategory, parentCategoryName);
    // if the parent is not in the config (because we just created it above),
    // and it inherited a valid configuration, add it to config.categories
    if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {
        config.categories[parentCategoryName] = parentCategory;
    }
    category.appenders = category.appenders || [];
    category.level = category.level || parentCategory.level;
    // merge in appenders from parent (parent is already holding its inherited appenders)
    parentCategory.appenders.forEach((ap)=>{
        if (!category.appenders.includes(ap)) {
            category.appenders.push(ap);
        }
    });
    category.parent = parentCategory;
}
/**
 * Walk all categories in the config, and pull down any configuration from parent to child.
 * This includes inherited appenders, and level, where level is not set.
 * Inheritance is skipped where a category has inherit=false.
 * @param  {*} config
 */ function addCategoryInheritance(config) {
    if (!config.categories) return;
    const categoryNames = Object.keys(config.categories);
    categoryNames.forEach((name)=>{
        const category = config.categories[name];
        // add inherited appenders and level to this category
        inheritFromParent(config, category, name);
    });
}
configuration.addPreProcessingListener((config)=>addCategoryInheritance(config));
configuration.addListener((config)=>{
    configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property "categories" of type object.');
    const categoryNames = Object.keys(config.categories);
    configuration.throwExceptionIf(config, configuration.not(categoryNames.length), 'must define at least one category.');
    categoryNames.forEach((name)=>{
        const category = config.categories[name];
        configuration.throwExceptionIf(config, [
            configuration.not(category.appenders),
            configuration.not(category.level)
        ], `category "${name}" is not valid (must be an object with properties "appenders" and "level")`);
        configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category "${name}" is not valid (appenders must be an array of appender names)`);
        configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category "${name}" is not valid (appenders must contain at least one appender name)`);
        if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {
            configuration.throwExceptionIf(config, typeof category.enableCallStack !== 'boolean', `category "${name}" is not valid (enableCallStack must be boolean type)`);
        }
        category.appenders.forEach((appender)=>{
            configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category "${name}" is not valid (appender "${appender}" is not defined)`);
        });
        configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category "${name}" is not valid (level "${category.level}" not recognised;` + ` valid levels are ${levels.levels.join(', ')})`);
    });
    configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a "default" category.');
});
const setup = (config)=>{
    categories.clear();
    if (!config) {
        return;
    }
    const categoryNames = Object.keys(config.categories);
    categoryNames.forEach((name)=>{
        const category = config.categories[name];
        const categoryAppenders = [];
        category.appenders.forEach((appender)=>{
            categoryAppenders.push(appenders.get(appender));
            debug(`Creating category ${name}`);
            categories.set(name, {
                appenders: categoryAppenders,
                level: levels.getLevel(category.level),
                enableCallStack: category.enableCallStack || false
            });
        });
    });
};
const init = ()=>{
    setup();
};
init();
configuration.addListener(setup);
const configForCategory = (category)=>{
    debug(`configForCategory: searching for config for ${category}`);
    if (categories.has(category)) {
        debug(`configForCategory: ${category} exists in config, returning it`);
        return categories.get(category);
    }
    let sourceCategoryConfig;
    if (category.indexOf('.') > 0) {
        debug(`configForCategory: ${category} has hierarchy, cloning from parents`);
        sourceCategoryConfig = {
            ...configForCategory(category.slice(0, category.lastIndexOf('.')))
        };
    } else {
        if (!categories.has('default')) {
            setup({
                categories: {
                    default: {
                        appenders: [
                            'out'
                        ],
                        level: 'OFF'
                    }
                }
            });
        }
        debug('configForCategory: cloning default category');
        sourceCategoryConfig = {
            ...categories.get('default')
        };
    }
    categories.set(category, sourceCategoryConfig);
    return sourceCategoryConfig;
};
const appendersForCategory = (category)=>configForCategory(category).appenders;
const getLevelForCategory = (category)=>configForCategory(category).level;
const setLevelForCategory = (category, level)=>{
    configForCategory(category).level = level;
};
const getEnableCallStackForCategory = (category)=>configForCategory(category).enableCallStack === true;
const setEnableCallStackForCategory = (category, useCallStack)=>{
    configForCategory(category).enableCallStack = useCallStack;
};
module.exports = categories;
module.exports = Object.assign(module.exports, {
    appendersForCategory,
    getLevelForCategory,
    setLevelForCategory,
    getEnableCallStackForCategory,
    setEnableCallStackForCategory,
    init
});
}),
"[project]/node_modules/log4js/lib/logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint no-underscore-dangle: ["error", { "allow": ["_log"] }] */ const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:logger');
const LoggingEvent = __turbopack_context__.r("[project]/node_modules/log4js/lib/LoggingEvent.js [app-route] (ecmascript)");
const levels = __turbopack_context__.r("[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)");
const clustering = __turbopack_context__.r("[project]/node_modules/log4js/lib/clustering.js [app-route] (ecmascript)");
const categories = __turbopack_context__.r("[project]/node_modules/log4js/lib/categories.js [app-route] (ecmascript)");
const configuration = __turbopack_context__.r("[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)");
const stackReg = /^(?:\s*)at (?:(.+) \()?(?:([^(]+?):(\d+):(\d+))\)?$/;
/**
 * The top entry is the Error
 */ const baseCallStackSkip = 1;
/**
 * The _log function is 3 levels deep, we need to skip those to make it to the callSite
 */ const defaultErrorCallStackSkip = 3;
/**
 *
 * @param {Error} data
 * @param {number} skipIdx
 * @returns {import('../types/log4js').CallStack | null}
 */ function defaultParseCallStack(data, skipIdx = defaultErrorCallStackSkip + baseCallStackSkip) {
    try {
        const stacklines = data.stack.split('\n').slice(skipIdx);
        if (!stacklines.length) {
            // There's no stack in this stack
            // Should we try a previous index if skipIdx was set?
            return null;
        }
        const lineMatch = stackReg.exec(stacklines[0]);
        /* istanbul ignore else: failsafe */ if (lineMatch && lineMatch.length === 5) {
            // extract class, function and alias names
            let className = '';
            let functionName = '';
            let functionAlias = '';
            if (lineMatch[1] && lineMatch[1] !== '') {
                // WARN: this will unset alias if alias is not present.
                [functionName, functionAlias] = lineMatch[1].replace(/[[\]]/g, '').split(' as ');
                functionAlias = functionAlias || '';
                if (functionName.includes('.')) [className, functionName] = functionName.split('.');
            }
            return {
                fileName: lineMatch[2],
                lineNumber: parseInt(lineMatch[3], 10),
                columnNumber: parseInt(lineMatch[4], 10),
                callStack: stacklines.join('\n'),
                className,
                functionName,
                functionAlias,
                callerName: lineMatch[1] || ''
            };
        // eslint-disable-next-line no-else-return
        } else {
            // will never get here unless nodejs has changes to Error
            console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console
        }
    } catch (err) {
        // will never get error unless nodejs has breaking changes to Error
        console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console
    }
    return null;
}
/**
 * Logger to log messages.
 * use {@see log4js#getLogger(String)} to get an instance.
 *
 * @name Logger
 * @namespace Log4js
 * @param name name of category to log to
 * @param level - the loglevel for the category
 * @param dispatch - the function which will receive the logevents
 *
 * @author Stephan Strittmatter
 */ class Logger {
    constructor(name){
        if (!name) {
            throw new Error('No category provided.');
        }
        this.category = name;
        this.context = {};
        /** @private */ this.callStackSkipIndex = 0;
        /** @private */ this.parseCallStack = defaultParseCallStack;
        debug(`Logger created (${this.category}, ${this.level})`);
    }
    get level() {
        return levels.getLevel(categories.getLevelForCategory(this.category), levels.OFF);
    }
    set level(level) {
        categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));
    }
    get useCallStack() {
        return categories.getEnableCallStackForCategory(this.category);
    }
    set useCallStack(bool) {
        categories.setEnableCallStackForCategory(this.category, bool === true);
    }
    get callStackLinesToSkip() {
        return this.callStackSkipIndex;
    }
    set callStackLinesToSkip(number) {
        if (typeof number !== 'number') {
            throw new TypeError('Must be a number');
        }
        if (number < 0) {
            throw new RangeError('Must be >= 0');
        }
        this.callStackSkipIndex = number;
    }
    log(level, ...args) {
        const logLevel = levels.getLevel(level);
        if (!logLevel) {
            if (configuration.validIdentifier(level) && args.length > 0) {
                // logLevel not found but of valid signature, WARN before fallback to INFO
                this.log(levels.WARN, 'log4js:logger.log: valid log-level not found as first parameter given:', level);
                this.log(levels.INFO, `[${level}]`, ...args);
            } else {
                // apart from fallback, allow .log(...args) to be synonym with .log("INFO", ...args)
                this.log(levels.INFO, level, ...args);
            }
        } else if (this.isLevelEnabled(logLevel)) {
            this._log(logLevel, args);
        }
    }
    isLevelEnabled(otherLevel) {
        return this.level.isLessThanOrEqualTo(otherLevel);
    }
    _log(level, data) {
        debug(`sending log data (${level}) to appenders`);
        const error = data.find((item)=>item instanceof Error);
        let callStack;
        if (this.useCallStack) {
            try {
                if (error) {
                    callStack = this.parseCallStack(error, this.callStackSkipIndex + baseCallStackSkip);
                }
            } catch (_err) {
            // Ignore Error and use the original method of creating a new Error.
            }
            callStack = callStack || this.parseCallStack(new Error(), this.callStackSkipIndex + defaultErrorCallStackSkip + baseCallStackSkip);
        }
        const loggingEvent = new LoggingEvent(this.category, level, data, this.context, callStack, error);
        clustering.send(loggingEvent);
    }
    addContext(key, value) {
        this.context[key] = value;
    }
    removeContext(key) {
        delete this.context[key];
    }
    clearContext() {
        this.context = {};
    }
    setParseCallStackFunction(parseFunction) {
        if (typeof parseFunction === 'function') {
            this.parseCallStack = parseFunction;
        } else if (typeof parseFunction === 'undefined') {
            this.parseCallStack = defaultParseCallStack;
        } else {
            throw new TypeError('Invalid type passed to setParseCallStackFunction');
        }
    }
}
function addLevelMethods(target) {
    const level = levels.getLevel(target);
    const levelStrLower = level.toString().toLowerCase();
    const levelMethod = levelStrLower.replace(/_([a-z])/g, (g)=>g[1].toUpperCase());
    const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
    Logger.prototype[`is${isLevelMethod}Enabled`] = function() {
        return this.isLevelEnabled(level);
    };
    Logger.prototype[levelMethod] = function(...args) {
        this.log(level, ...args);
    };
}
levels.levels.forEach(addLevelMethods);
configuration.addListener(()=>{
    levels.levels.forEach(addLevelMethods);
});
module.exports = Logger;
}),
"[project]/node_modules/log4js/lib/connect-logger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* eslint no-underscore-dangle: ["error", { "allow": ["__statusCode", "_remoteAddress", "__headers", "_logging"] }] */ const levels = __turbopack_context__.r("[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)");
const DEFAULT_FORMAT = ':remote-addr - -' + ' ":method :url HTTP/:http-version"' + ' :status :content-length ":referrer"' + ' ":user-agent"';
/**
 * Return request url path,
 * adding this function prevents the Cyclomatic Complexity,
 * for the assemble_tokens function at low, to pass the tests.
 *
 * @param  {IncomingMessage} req
 * @return {string}
 * @api private
 */ function getUrl(req) {
    return req.originalUrl || req.url;
}
/**
 * Adds custom {token, replacement} objects to defaults,
 * overwriting the defaults if any tokens clash
 *
 * @param  {IncomingMessage} req
 * @param  {ServerResponse} res
 * @param  {Array} customTokens
 *    [{ token: string-or-regexp, replacement: string-or-replace-function }]
 * @return {Array}
 */ function assembleTokens(req, res, customTokens) {
    const arrayUniqueTokens = (array)=>{
        const a = array.concat();
        for(let i = 0; i < a.length; ++i){
            for(let j = i + 1; j < a.length; ++j){
                // not === because token can be regexp object
                // eslint-disable-next-line eqeqeq
                if (a[i].token == a[j].token) {
                    a.splice(j--, 1); // eslint-disable-line no-plusplus
                }
            }
        }
        return a;
    };
    const defaultTokens = [];
    defaultTokens.push({
        token: ':url',
        replacement: getUrl(req)
    });
    defaultTokens.push({
        token: ':protocol',
        replacement: req.protocol
    });
    defaultTokens.push({
        token: ':hostname',
        replacement: req.hostname
    });
    defaultTokens.push({
        token: ':method',
        replacement: req.method
    });
    defaultTokens.push({
        token: ':status',
        replacement: res.__statusCode || res.statusCode
    });
    defaultTokens.push({
        token: ':response-time',
        replacement: res.responseTime
    });
    defaultTokens.push({
        token: ':date',
        replacement: new Date().toUTCString()
    });
    defaultTokens.push({
        token: ':referrer',
        replacement: req.headers.referer || req.headers.referrer || ''
    });
    defaultTokens.push({
        token: ':http-version',
        replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
    });
    defaultTokens.push({
        token: ':remote-addr',
        replacement: req.headers['x-forwarded-for'] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
    });
    defaultTokens.push({
        token: ':user-agent',
        replacement: req.headers['user-agent']
    });
    defaultTokens.push({
        token: ':content-length',
        replacement: res.getHeader('content-length') || res.__headers && res.__headers['Content-Length'] || '-'
    });
    defaultTokens.push({
        token: /:req\[([^\]]+)]/g,
        replacement (_, field) {
            return req.headers[field.toLowerCase()];
        }
    });
    defaultTokens.push({
        token: /:res\[([^\]]+)]/g,
        replacement (_, field) {
            return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
        }
    });
    return arrayUniqueTokens(customTokens.concat(defaultTokens));
}
/**
 * Return formatted log line.
 *
 * @param  {string} str
 * @param {Array} tokens
 * @return {string}
 * @api private
 */ function format(str, tokens) {
    for(let i = 0; i < tokens.length; i++){
        str = str.replace(tokens[i].token, tokens[i].replacement);
    }
    return str;
}
/**
 * Return RegExp Object about nolog
 *
 * @param  {(string|Array)} nolog
 * @return {RegExp}
 * @api private
 *
 * syntax
 *  1. String
 *   1.1 "\\.gif"
 *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.gif?fuga
 *         LOGGING http://example.com/hoge.agif
 *   1.2 in "\\.gif|\\.jpg$"
 *         NOT LOGGING http://example.com/hoge.gif and
 *           http://example.com/hoge.gif?fuga and http://example.com/hoge.jpg?fuga
 *         LOGGING http://example.com/hoge.agif,
 *           http://example.com/hoge.ajpg and http://example.com/hoge.jpg?hoge
 *   1.3 in "\\.(gif|jpe?g|png)$"
 *         NOT LOGGING http://example.com/hoge.gif and http://example.com/hoge.jpeg
 *         LOGGING http://example.com/hoge.gif?uid=2 and http://example.com/hoge.jpg?pid=3
 *  2. RegExp
 *   2.1 in /\.(gif|jpe?g|png)$/
 *         SAME AS 1.3
 *  3. Array
 *   3.1 ["\\.jpg$", "\\.png", "\\.gif"]
 *         SAME AS "\\.jpg|\\.png|\\.gif"
 */ function createNoLogCondition(nolog) {
    let regexp = null;
    if (nolog instanceof RegExp) {
        regexp = nolog;
    }
    if (typeof nolog === 'string') {
        regexp = new RegExp(nolog);
    }
    if (Array.isArray(nolog)) {
        // convert to strings
        const regexpsAsStrings = nolog.map((reg)=>reg.source ? reg.source : reg);
        regexp = new RegExp(regexpsAsStrings.join('|'));
    }
    return regexp;
}
/**
 * Allows users to define rules around status codes to assign them to a specific
 * logging level.
 * There are two types of rules:
 *   - RANGE: matches a code within a certain range
 *     E.g. { 'from': 200, 'to': 299, 'level': 'info' }
 *   - CONTAINS: matches a code to a set of expected codes
 *     E.g. { 'codes': [200, 203], 'level': 'debug' }
 * Note*: Rules are respected only in order of prescendence.
 *
 * @param {Number} statusCode
 * @param {Level} currentLevel
 * @param {Object} ruleSet
 * @return {Level}
 * @api private
 */ function matchRules(statusCode, currentLevel, ruleSet) {
    let level = currentLevel;
    if (ruleSet) {
        const matchedRule = ruleSet.find((rule)=>{
            let ruleMatched = false;
            if (rule.from && rule.to) {
                ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
            } else {
                ruleMatched = rule.codes.indexOf(statusCode) !== -1;
            }
            return ruleMatched;
        });
        if (matchedRule) {
            level = levels.getLevel(matchedRule.level, level);
        }
    }
    return level;
}
/**
 * Log requests with the given `options` or a `format` string.
 *
 * Options:
 *
 *   - `format`        Format string, see below for tokens
 *   - `level`         A log4js levels instance. Supports also 'auto'
 *   - `nolog`         A string or RegExp to exclude target logs or function(req, res): boolean
 *   - `statusRules`   A array of rules for setting specific logging levels base on status codes
 *   - `context`       Whether to add a response of express to the context
 *
 * Tokens:
 *
 *   - `:req[header]` ex: `:req[Accept]`
 *   - `:res[header]` ex: `:res[Content-Length]`
 *   - `:http-version`
 *   - `:response-time`
 *   - `:remote-addr`
 *   - `:date`
 *   - `:method`
 *   - `:url`
 *   - `:referrer`
 *   - `:user-agent`
 *   - `:status`
 *
 * @return {Function}
 * @param logger4js
 * @param options
 * @api public
 */ module.exports = function getLogger(logger4js, options) {
    if (typeof options === 'string' || typeof options === 'function') {
        options = {
            format: options
        };
    } else {
        options = options || {};
    }
    const thisLogger = logger4js;
    let level = levels.getLevel(options.level, levels.INFO);
    const fmt = options.format || DEFAULT_FORMAT;
    return (req, res, next)=>{
        // mount safety
        if (typeof req._logging !== 'undefined') return next();
        // nologs
        if (typeof options.nolog !== 'function') {
            const nolog = createNoLogCondition(options.nolog);
            if (nolog && nolog.test(req.originalUrl)) return next();
        }
        if (thisLogger.isLevelEnabled(level) || options.level === 'auto') {
            const start = new Date();
            const { writeHead } = res;
            // flag as logging
            req._logging = true;
            // proxy for statusCode.
            res.writeHead = (code, headers)=>{
                res.writeHead = writeHead;
                res.writeHead(code, headers);
                res.__statusCode = code;
                res.__headers = headers || {};
            };
            // hook on end request to emit the log entry of the HTTP request.
            let finished = false;
            const handler = ()=>{
                if (finished) {
                    return;
                }
                finished = true;
                // nologs
                if (typeof options.nolog === 'function') {
                    if (options.nolog(req, res) === true) {
                        req._logging = false;
                        return;
                    }
                }
                res.responseTime = new Date() - start;
                // status code response level handling
                if (res.statusCode && options.level === 'auto') {
                    level = levels.INFO;
                    if (res.statusCode >= 300) level = levels.WARN;
                    if (res.statusCode >= 400) level = levels.ERROR;
                }
                level = matchRules(res.statusCode, level, options.statusRules);
                const combinedTokens = assembleTokens(req, res, options.tokens || []);
                if (options.context) thisLogger.addContext('res', res);
                if (typeof fmt === 'function') {
                    const line = fmt(req, res, (str)=>format(str, combinedTokens));
                    if (line) thisLogger.log(level, line);
                } else {
                    thisLogger.log(level, format(fmt, combinedTokens));
                }
                if (options.context) thisLogger.removeContext('res');
            };
            res.on('end', handler);
            res.on('finish', handler);
            res.on('error', handler);
            res.on('close', handler);
        }
        // ensure next gets always called
        return next();
    };
};
}),
"[project]/node_modules/log4js/lib/appenders/recording.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:recording');
const recordedEvents = [];
function configure() {
    return function(logEvent) {
        debug(`received logEvent, number of events now ${recordedEvents.length + 1}`);
        debug('log event was ', logEvent);
        recordedEvents.push(logEvent);
    };
}
function replay() {
    return recordedEvents.slice();
}
function reset() {
    recordedEvents.length = 0;
}
module.exports = {
    configure,
    replay,
    playback: replay,
    reset,
    erase: reset
};
}),
"[project]/node_modules/log4js/lib/log4js.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * @fileoverview log4js is a library to log in JavaScript in similar manner
 * than in log4j for Java (but not really).
 *
 * <h3>Example:</h3>
 * <pre>
 *  const logging = require('log4js');
 *  const log = logging.getLogger('some-category');
 *
 *  //call the log
 *  log.trace('trace me' );
 * </pre>
 *
 * NOTE: the authors below are the original browser-based log4js authors
 * don't try to contact them about bugs in this version :)
 * @author Stephan Strittmatter - http://jroller.com/page/stritti
 * @author Seth Chisamore - http://www.chisamore.com
 * @since 2005-05-20
 * Website: http://log4js.berlios.de
 */ const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('log4js:main');
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const deepClone = __turbopack_context__.r("[project]/node_modules/rfdc/index.js [app-route] (ecmascript)")({
    proto: true
});
const configuration = __turbopack_context__.r("[project]/node_modules/log4js/lib/configuration.js [app-route] (ecmascript)");
const layouts = __turbopack_context__.r("[project]/node_modules/log4js/lib/layouts.js [app-route] (ecmascript)");
const levels = __turbopack_context__.r("[project]/node_modules/log4js/lib/levels.js [app-route] (ecmascript)");
const appenders = __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/index.js [app-route] (ecmascript)");
const categories = __turbopack_context__.r("[project]/node_modules/log4js/lib/categories.js [app-route] (ecmascript)");
const Logger = __turbopack_context__.r("[project]/node_modules/log4js/lib/logger.js [app-route] (ecmascript)");
const clustering = __turbopack_context__.r("[project]/node_modules/log4js/lib/clustering.js [app-route] (ecmascript)");
const connectLogger = __turbopack_context__.r("[project]/node_modules/log4js/lib/connect-logger.js [app-route] (ecmascript)");
const recordingModule = __turbopack_context__.r("[project]/node_modules/log4js/lib/appenders/recording.js [app-route] (ecmascript)");
let enabled = false;
function sendLogEventToAppender(logEvent) {
    if (!enabled) return;
    debug('Received log event ', logEvent);
    const categoryAppenders = categories.appendersForCategory(logEvent.categoryName);
    categoryAppenders.forEach((appender)=>{
        appender(logEvent);
    });
}
function loadConfigurationFile(filename) {
    debug(`Loading configuration from ${filename}`);
    try {
        return JSON.parse(fs.readFileSync(filename, 'utf8'));
    } catch (e) {
        throw new Error(`Problem reading config from file "${filename}". Error was ${e.message}`, e);
    }
}
function configure(configurationFileOrObject) {
    if (enabled) {
        // eslint-disable-next-line no-use-before-define
        shutdown();
    }
    let configObject = configurationFileOrObject;
    if (typeof configObject === 'string') {
        configObject = loadConfigurationFile(configurationFileOrObject);
    }
    debug(`Configuration is ${configObject}`);
    configuration.configure(deepClone(configObject));
    clustering.onMessage(sendLogEventToAppender);
    enabled = true;
    // eslint-disable-next-line no-use-before-define
    return log4js;
}
function isConfigured() {
    return enabled;
}
function recording() {
    return recordingModule;
}
/**
 * This callback type is called `shutdownCallback` and is displayed as a global symbol.
 *
 * @callback shutdownCallback
 * @param {Error} [error]
 */ /**
 * Shutdown all log appenders. This will first disable all writing to appenders
 * and then call the shutdown function each appender.
 *
 * @param {shutdownCallback} [callback] - The callback to be invoked once all appenders have
 *  shutdown. If an error occurs, the callback will be given the error object
 *  as the first argument.
 */ function shutdown(callback = ()=>{}) {
    if (typeof callback !== 'function') {
        throw new TypeError('Invalid callback passed to shutdown');
    }
    debug('Shutdown called. Disabling all log writing.');
    // First, disable all writing to appenders. This prevents appenders from
    // not being able to be drained because of run-away log writes.
    enabled = false;
    // Clone out to maintain a reference
    const appendersToCheck = Array.from(appenders.values());
    // Reset immediately to prevent leaks
    appenders.init();
    categories.init();
    // Count the number of shutdown functions
    const shutdownFunctions = appendersToCheck.reduce((accum, next)=>next.shutdown ? accum + 1 : accum, 0);
    if (shutdownFunctions === 0) {
        debug('No appenders with shutdown functions found.');
        callback();
    }
    let completed = 0;
    let error;
    debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
    function complete(err) {
        error = error || err;
        completed += 1;
        debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
        if (completed >= shutdownFunctions) {
            debug('All shutdown functions completed.');
            callback(error);
        }
    }
    // Call each of the shutdown functions
    appendersToCheck.filter((a)=>a.shutdown).forEach((a)=>a.shutdown(complete));
}
/**
 * Get a logger instance.
 * @static
 * @param {string} [category=default]
 * @return {Logger} instance of logger for the category
 */ function getLogger(category) {
    if (!enabled) {
        configure(process.env.LOG4JS_CONFIG || {
            appenders: {
                out: {
                    type: 'stdout'
                }
            },
            categories: {
                default: {
                    appenders: [
                        'out'
                    ],
                    level: 'OFF'
                }
            }
        });
    }
    return new Logger(category || 'default');
}
/**
 * @name log4js
 * @namespace Log4js
 * @property getLogger
 * @property configure
 * @property shutdown
 */ const log4js = {
    getLogger,
    configure,
    isConfigured,
    shutdown,
    connectLogger,
    levels,
    addLayout: layouts.addLayout,
    recording
};
module.exports = log4js;
}),
"[project]/node_modules/date-format/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function padWithZeros(vNumber, width) {
    var numAsString = vNumber.toString();
    while(numAsString.length < width){
        numAsString = "0" + numAsString;
    }
    return numAsString;
}
function addZero(vNumber) {
    return padWithZeros(vNumber, 2);
}
/**
 * Formats the TimeOffset
 * Thanks to http://www.svendtofte.com/code/date_format/
 * @private
 */ function offset(timezoneOffset) {
    var os = Math.abs(timezoneOffset);
    var h = String(Math.floor(os / 60));
    var m = String(os % 60);
    h = ("0" + h).slice(-2);
    m = ("0" + m).slice(-2);
    return timezoneOffset === 0 ? "Z" : (timezoneOffset < 0 ? "+" : "-") + h + ":" + m;
}
function asString(format, date) {
    if (typeof format !== "string") {
        date = format;
        format = module.exports.ISO8601_FORMAT;
    }
    if (!date) {
        date = module.exports.now();
    }
    // Issue # 14 - Per ISO8601 standard, the time string should be local time
    // with timezone info.
    // See https://en.wikipedia.org/wiki/ISO_8601 section "Time offsets from UTC"
    var vDay = addZero(date.getDate());
    var vMonth = addZero(date.getMonth() + 1);
    var vYearLong = addZero(date.getFullYear());
    var vYearShort = addZero(vYearLong.substring(2, 4));
    var vYear = format.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
    var vHour = addZero(date.getHours());
    var vMinute = addZero(date.getMinutes());
    var vSecond = addZero(date.getSeconds());
    var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
    var vTimeZone = offset(date.getTimezoneOffset());
    var formatted = format.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
    return formatted;
}
function setDatePart(date, part, value, local) {
    date['set' + (local ? '' : 'UTC') + part](value);
}
function extractDateParts(pattern, str, missingValuesDate) {
    // Javascript Date object doesn't support custom timezone.  Sets all felds as
    // GMT based to begin with.  If the timezone offset is provided, then adjust
    // it using provided timezone, otherwise, adjust it with the system timezone.
    var local = pattern.indexOf('O') < 0;
    var monthOverflow = false;
    var matchers = [
        {
            pattern: /y{1,4}/,
            regexp: "\\d{1,4}",
            fn: function(date, value) {
                setDatePart(date, 'FullYear', value, local);
            }
        },
        {
            pattern: /MM/,
            regexp: "\\d{1,2}",
            fn: function(date, value) {
                setDatePart(date, 'Month', value - 1, local);
                if (date.getMonth() !== value - 1) {
                    // in the event of 31 May --> 31 Feb --> 3 Mar
                    // this is correct behavior if no Date is involved
                    monthOverflow = true;
                }
            }
        },
        {
            pattern: /dd/,
            regexp: "\\d{1,2}",
            fn: function(date, value) {
                // in the event of 31 May --> 31 Feb --> 3 Mar
                // reset Mar back to Feb, before setting the Date
                if (monthOverflow) {
                    setDatePart(date, 'Month', date.getMonth() - 1, local);
                }
                setDatePart(date, 'Date', value, local);
            }
        },
        {
            pattern: /hh/,
            regexp: "\\d{1,2}",
            fn: function(date, value) {
                setDatePart(date, 'Hours', value, local);
            }
        },
        {
            pattern: /mm/,
            regexp: "\\d\\d",
            fn: function(date, value) {
                setDatePart(date, 'Minutes', value, local);
            }
        },
        {
            pattern: /ss/,
            regexp: "\\d\\d",
            fn: function(date, value) {
                setDatePart(date, 'Seconds', value, local);
            }
        },
        {
            pattern: /SSS/,
            regexp: "\\d\\d\\d",
            fn: function(date, value) {
                setDatePart(date, 'Milliseconds', value, local);
            }
        },
        {
            pattern: /O/,
            regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
            fn: function(date, value) {
                if (value === "Z") {
                    value = 0;
                } else {
                    value = value.replace(":", "");
                }
                var offset = Math.abs(value);
                var timezoneOffset = (value > 0 ? -1 : 1) * (offset % 100 + Math.floor(offset / 100) * 60);
                // Per ISO8601 standard: UTC = local time - offset
                //
                // For example, 2000-01-01T01:00:00-0700
                //   local time: 2000-01-01T01:00:00
                //   ==> UTC   : 2000-01-01T08:00:00 ( 01 - (-7) = 8 )
                //
                // To make it even more confusing, the date.getTimezoneOffset() is
                // opposite sign of offset string in the ISO8601 standard.  So if offset
                // is '-0700' the getTimezoneOffset() would be (+)420. The line above
                // calculates timezoneOffset to matche Javascript's behavior.
                //
                // The date/time of the input is actually the local time, so the date
                // object that was constructed is actually local time even thought the
                // UTC setters are used.  This means the date object's internal UTC
                // representation was wrong.  It needs to be fixed by substracting the
                // offset (or adding the offset minutes as they are opposite sign).
                //
                // Note: the time zone has to be processed after all other fields are
                // set.  The result would be incorrect if the offset was calculated
                // first then overriden by the other filed setters.
                date.setUTCMinutes(date.getUTCMinutes() + timezoneOffset);
            }
        }
    ];
    var parsedPattern = matchers.reduce(function(p, m) {
        if (m.pattern.test(p.regexp)) {
            m.index = p.regexp.match(m.pattern).index;
            p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
        } else {
            m.index = -1;
        }
        return p;
    }, {
        regexp: pattern,
        index: []
    });
    var dateFns = matchers.filter(function(m) {
        return m.index > -1;
    });
    dateFns.sort(function(a, b) {
        return a.index - b.index;
    });
    var matcher = new RegExp(parsedPattern.regexp);
    var matches = matcher.exec(str);
    if (matches) {
        var date = missingValuesDate || module.exports.now();
        dateFns.forEach(function(f, i) {
            f.fn(date, matches[i + 1]);
        });
        return date;
    }
    throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
}
function parse(pattern, str, missingValuesDate) {
    if (!pattern) {
        throw new Error("pattern must be supplied");
    }
    return extractDateParts(pattern, str, missingValuesDate);
}
/**
 * Used for testing - replace this function with a fixed date.
 */ function now() {
    return new Date();
}
module.exports = asString;
module.exports.asString = asString;
module.exports.parse = parse;
module.exports.now = now;
module.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
module.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
module.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
module.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
}),
"[project]/node_modules/flatted/cjs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/// <reference types="../types/index.d.ts" />
// (c) 2020-present Andrea Giammarchi
const { parse: $parse, stringify: $stringify } = JSON;
const { keys } = Object;
const Primitive = String; // it could be Number
const primitive = 'string'; // it could be 'number'
const ignore = {};
const object = 'object';
const noop = (_, value)=>value;
const primitives = (value)=>value instanceof Primitive ? Primitive(value) : value;
const Primitives = (_, value)=>typeof value === primitive ? new Primitive(value) : value;
const revive = (input, parsed, output, $)=>{
    const lazy = [];
    for(let ke = keys(output), { length } = ke, y = 0; y < length; y++){
        const k = ke[y];
        const value = output[k];
        if (value instanceof Primitive) {
            const tmp = input[value];
            if (typeof tmp === object && !parsed.has(tmp)) {
                parsed.add(tmp);
                output[k] = ignore;
                lazy.push({
                    k,
                    a: [
                        input,
                        parsed,
                        tmp,
                        $
                    ]
                });
            } else output[k] = $.call(output, k, tmp);
        } else if (output[k] !== ignore) output[k] = $.call(output, k, value);
    }
    for(let { length } = lazy, i = 0; i < length; i++){
        const { k, a } = lazy[i];
        output[k] = $.call(output, k, revive.apply(null, a));
    }
    return output;
};
const set = (known, input, value)=>{
    const index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
};
/**
 * Converts a specialized flatted string into a JS value.
 * @param {string} text
 * @param {(this: any, key: string, value: any) => any} [reviver]
 * @returns {any}
 */ const parse = (text, reviver)=>{
    const input = $parse(text, Primitives).map(primitives);
    const value = input[0];
    const $ = reviver || noop;
    const tmp = typeof value === object && value ? revive(input, new Set, value, $) : value;
    return $.call({
        '': tmp
    }, '', tmp);
};
exports.parse = parse;
/**
 * Converts a JS value into a specialized flatted string.
 * @param {any} value
 * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined} [replacer]
 * @param {string | number | undefined} [space]
 * @returns {string}
 */ const stringify = (value, replacer, space)=>{
    const $ = replacer && typeof replacer === object ? (k, v)=>k === '' || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
    const known = new Map;
    const input = [];
    const output = [];
    let i = +set(known, input, $.call({
        '': value
    }, '', value));
    let firstRun = !i;
    while(i < input.length){
        firstRun = true;
        output[i] = $stringify(input[i++], replace, space);
    }
    return '[' + output.join(',') + ']';
    //TURBOPACK unreachable
    ;
    function replace(key, value) {
        if (firstRun) {
            firstRun = !firstRun;
            return value;
        }
        const after = $.call(this, key, value);
        switch(typeof after){
            case object:
                if (after === null) return after;
            case primitive:
                return known.get(after) || set(known, input, after);
        }
        return after;
    }
};
exports.stringify = stringify;
/**
 * Converts a generic value into a JSON serializable object without losing recursion.
 * @param {any} value
 * @returns {any}
 */ const toJSON = (value)=>$parse(stringify(value));
exports.toJSON = toJSON;
/**
 * Converts a previously serialized object with recursion into a recursive one.
 * @param {any} value
 * @returns {any}
 */ const fromJSON = (value)=>parse($stringify(value));
exports.fromJSON = fromJSON;
}),
"[project]/node_modules/universalify/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.fromCallback = function(fn) {
    return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments);
        else {
            return new Promise((resolve, reject)=>{
                arguments[arguments.length] = (err, res)=>{
                    if (err) return reject(err);
                    resolve(res);
                };
                arguments.length++;
                fn.apply(this, arguments);
            });
        }
    }, 'name', {
        value: fn.name
    });
};
exports.fromPromise = function(fn) {
    return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== 'function') return fn.apply(this, arguments);
        else fn.apply(this, arguments).then((r)=>cb(null, r), cb);
    }, 'name', {
        value: fn.name
    });
};
}),
"[project]/node_modules/graceful-fs/polyfills.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var constants = __turbopack_context__.r("[externals]/constants [external] (constants, cjs)");
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!cwd) cwd = origCwd.call(process);
    return cwd;
};
try {
    process.cwd();
} catch (er) {}
// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
    var chdir = process.chdir;
    process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
module.exports = patch;
function patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
    }
    // lutimes implementation, or no-op
    if (!fs.lutimes) {
        patchLutimes(fs);
    }
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if (platform === "win32") {
        fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
            function rename(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                    if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                        setTimeout(function() {
                            fs.stat(to, function(stater, st) {
                                if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                else cb(er);
                            });
                        }, backoff);
                        if (backoff < 100) backoff += 10;
                        return;
                    }
                    if (cb) cb(er);
                });
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
            return rename;
        }(fs.rename);
    }
    // if read() returns EAGAIN, then just try it again.
    fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === 'function') {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
    }(fs.read);
    fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true){
                try {
                    return fs$readSync.call(fs, fd, buffer, offset, length, position);
                } catch (er) {
                    if (er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++;
                        continue;
                    }
                    throw er;
                }
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) {
                    try {
                        fs.closeSync(fd);
                    } catch (er) {}
                } else {
                    fs.closeSync(fd);
                }
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        } else if (fs.futimes) {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === 'function') {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000;
                if (stats.gid < 0) stats.gid += 0x100000000;
            }
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}
}),
"[project]/node_modules/graceful-fs/legacy-streams.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
module.exports = legacy;
function legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    //TURBOPACK unreachable
    ;
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = 'r';
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 64 * 1024;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.end === undefined) {
                this.end = Infinity;
            } else if ('number' !== typeof this.end) {
                throw TypeError('end must be a Number');
            }
            if (this.start > this.end) {
                throw new Error('start must be <= end');
            }
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit('error', err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit('open', fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = 'w';
        this.encoding = 'binary';
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
                throw TypeError('start must be a Number');
            }
            if (this.start < 0) {
                throw new Error('start must be >= zero');
            }
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}
}),
"[project]/node_modules/graceful-fs/clone.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = clone;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
};
function clone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Object) var copy = {
        __proto__: getPrototypeOf(obj)
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}
}),
"[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var polyfills = __turbopack_context__.r("[project]/node_modules/graceful-fs/polyfills.js [app-route] (ecmascript)");
var legacy = __turbopack_context__.r("[project]/node_modules/graceful-fs/legacy-streams.js [app-route] (ecmascript)");
var clone = __turbopack_context__.r("[project]/node_modules/graceful-fs/clone.js [app-route] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/* istanbul ignore next - node 0.x polyfill */ var gracefulQueue;
var previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
    gracefulQueue = Symbol.for('graceful-fs.queue');
    // This is used in testing by future versions
    previousSymbol = Symbol.for('graceful-fs.previous');
} else {
    gracefulQueue = '___graceful-fs.queue';
    previousSymbol = '___graceful-fs.previous';
}
function noop() {}
function publishQueue(context, queue) {
    Object.defineProperty(context, gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var debug = noop;
if (util.debuglog) debug = util.debuglog('gfs4');
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
    var m = util.format.apply(util, arguments);
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
    console.error(m);
};
// Once time initialization
if (!fs[gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var queue = /*TURBOPACK member replacement*/ __turbopack_context__.g[gracefulQueue] || [];
    publishQueue(fs, queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call(fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) {
                    resetQueue();
                }
                if (typeof cb === 'function') cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, previousSymbol, {
            value: fs$close
        });
        return close;
    }(fs.close);
    fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments);
            resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }(fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
        process.on('exit', function() {
            debug(fs[gracefulQueue]);
            __turbopack_context__.r("[externals]/assert [external] (assert, cjs)").equal(fs[gracefulQueue].length, 0);
        });
    }
}
if (!/*TURBOPACK member replacement*/ __turbopack_context__.g[gracefulQueue]) {
    publishQueue(/*TURBOPACK member replacement*/ __turbopack_context__.g, fs[gracefulQueue]);
}
module.exports = patch(clone(fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs);
    fs.__patched = true;
}
function patch(fs) {
    // Everything that references the open() function needs to be in here
    polyfills(fs);
    fs.gracefulify = patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$readFile(path, options, cb);
        //TURBOPACK unreachable
        ;
        function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        //TURBOPACK unreachable
        ;
        function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        //TURBOPACK unreachable
        ;
        function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$copyFile = fs.copyFile;
    if (fs$copyFile) fs.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
        if (typeof flags === 'function') {
            cb = flags;
            flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        //TURBOPACK unreachable
        ;
        function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function(err) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$copyFile,
                    [
                        src,
                        dest,
                        flags,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
        if (typeof options === 'function') cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
        } : function go$readdir(path, options, cb, startTime) {
            return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
        };
        return go$readdir(path, options, cb);
        //TURBOPACK unreachable
        ;
        function fs$readdirCallback(path, options, cb, startTime) {
            return function(err, files) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$readdir,
                    [
                        path,
                        options,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (files && files.sort) files.sort();
                    if (typeof cb === 'function') cb.call(this, err, files);
                }
            };
        }
    }
    if (process.version.substr(0, 4) === 'v0.8') {
        var legStreams = legacy(fs);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs.ReadStream;
    if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs.WriteStream;
    if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs, 'ReadStream', {
        get: function() {
            return ReadStream;
        },
        set: function(val) {
            ReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(fs, 'WriteStream', {
        get: function() {
            return WriteStream;
        },
        set: function(val) {
            WriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    // legacy names
    var FileReadStream = ReadStream;
    Object.defineProperty(fs, 'FileReadStream', {
        get: function() {
            return FileReadStream;
        },
        set: function(val) {
            FileReadStream = val;
        },
        enumerable: true,
        configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs, 'FileWriteStream', {
        get: function() {
            return FileWriteStream;
        },
        set: function(val) {
            FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
    });
    function ReadStream(path, options) {
        if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
        else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                if (that.autoClose) that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
                that.read();
            }
        });
    }
    function WriteStream(path, options) {
        if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
        else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
            if (err) {
                that.destroy();
                that.emit('error', err);
            } else {
                that.fd = fd;
                that.emit('open', fd);
            }
        });
    }
    function createReadStream(path, options) {
        return new fs.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
        return new fs.WriteStream(path, options);
    }
    var fs$open = fs.open;
    fs.open = open;
    function open(path, flags, mode, cb) {
        if (typeof mode === 'function') cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        //TURBOPACK unreachable
        ;
        function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function(err, fd) {
                if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                    go$open,
                    [
                        path,
                        flags,
                        mode,
                        cb
                    ],
                    err,
                    startTime || Date.now(),
                    Date.now()
                ]);
                else {
                    if (typeof cb === 'function') cb.apply(this, arguments);
                }
            });
        }
    }
    return fs;
}
function enqueue(elem) {
    debug('ENQUEUE', elem[0].name, elem[1]);
    fs[gracefulQueue].push(elem);
    retry();
}
// keep track of the timeout between retry() calls
var retryTimer;
// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue() {
    var now = Date.now();
    for(var i = 0; i < fs[gracefulQueue].length; ++i){
        // entries that are only a length of 2 are from an older version, don't
        // bother modifying those since they'll be retried anyway.
        if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now; // startTime
            fs[gracefulQueue][i][4] = now; // lastTime
        }
    }
    // call retry to make sure we're actively processing the queue
    retry();
}
function retry() {
    // clear the timer and remove it to help prevent unintended concurrency
    clearTimeout(retryTimer);
    retryTimer = undefined;
    if (fs[gracefulQueue].length === 0) return;
    var elem = fs[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    // these items may be unset if they were added by an older graceful-fs
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    // if we don't have a startTime we have no way of knowing if we've waited
    // long enough, so go ahead and retry this item now
    if (startTime === undefined) {
        debug('RETRY', fn.name, args);
        fn.apply(null, args);
    } else if (Date.now() - startTime >= 60000) {
        // it's been more than 60 seconds total, bail now
        debug('TIMEOUT', fn.name, args);
        var cb = args.pop();
        if (typeof cb === 'function') cb.call(null, err);
    } else {
        // the amount of time between the last attempt and right now
        var sinceAttempt = Date.now() - lastTime;
        // the amount of time between when we first tried, and when we last tried
        // rounded up to at least 1
        var sinceStart = Math.max(lastTime - startTime, 1);
        // backoff. wait longer than the total time we've been retrying, but only
        // up to a maximum of 100ms
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        // it's been long enough since the last retry, do it again
        if (sinceAttempt >= desiredDelay) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args.concat([
                startTime
            ]));
        } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem);
        }
    }
    // schedule our next run if one isn't already scheduled
    if (retryTimer === undefined) {
        retryTimer = setTimeout(retry, 0);
    }
}
}),
"[project]/node_modules/fs-extra/lib/fs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const api = [
    'access',
    'appendFile',
    'chmod',
    'chown',
    'close',
    'copyFile',
    'fchmod',
    'fchown',
    'fdatasync',
    'fstat',
    'fsync',
    'ftruncate',
    'futimes',
    'lchown',
    'lchmod',
    'link',
    'lstat',
    'mkdir',
    'mkdtemp',
    'open',
    'readFile',
    'readdir',
    'readlink',
    'realpath',
    'rename',
    'rmdir',
    'stat',
    'symlink',
    'truncate',
    'unlink',
    'utimes',
    'writeFile'
].filter((key)=>{
    // Some commands are not available on some systems. Ex:
    // fs.copyFile was added in Node.js v8.5.0
    // fs.mkdtemp was added in Node.js v5.10.0
    // fs.lchown is not available on at least some Linux
    return typeof fs[key] === 'function';
});
// Export all keys:
Object.keys(fs).forEach((key)=>{
    if (key === 'promises') {
        // fs.promises is a getter property that triggers ExperimentalWarning
        // Don't re-export it here, the getter is defined in "lib/index.js"
        return;
    }
    exports[key] = fs[key];
});
// Universalify async methods:
api.forEach((method)=>{
    exports[method] = u(fs[method]);
});
// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function(filename, callback) {
    if (typeof callback === 'function') {
        return fs.exists(filename, callback);
    }
    return new Promise((resolve)=>{
        return fs.exists(filename, resolve);
    });
};
// fs.read() & fs.write need special treatment due to multiple callback args
exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === 'function') {
        return fs.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve, reject)=>{
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer)=>{
            if (err) return reject(err);
            resolve({
                bytesRead,
                buffer
            });
        });
    });
};
// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === 'function') {
        return fs.write(fd, buffer, ...args);
    }
    return new Promise((resolve, reject)=>{
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer)=>{
            if (err) return reject(err);
            resolve({
                bytesWritten,
                buffer
            });
        });
    });
};
// fs.realpath.native only available in Node v9.2+
if (typeof fs.realpath.native === 'function') {
    exports.realpath.native = u(fs.realpath.native);
}
}),
"[project]/node_modules/fs-extra/lib/mkdirs/win32.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
// get drive on windows
function getRootPath(p) {
    p = path.normalize(path.resolve(p)).split(path.sep);
    if (p.length > 0) return p[0];
    return null;
}
// http://stackoverflow.com/a/62888/10333 contains more accurate
// TODO: expand to include the rest
const INVALID_PATH_CHARS = /[<>:"|?*]/;
function invalidWin32Path(p) {
    const rp = getRootPath(p);
    p = p.replace(rp, '');
    return INVALID_PATH_CHARS.test(p);
}
module.exports = {
    getRootPath,
    invalidWin32Path
};
}),
"[project]/node_modules/fs-extra/lib/mkdirs/mkdirs.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const invalidWin32Path = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/win32.js [app-route] (ecmascript)").invalidWin32Path;
const o777 = parseInt('0777', 8);
function mkdirs(p, opts, callback, made) {
    if (typeof opts === 'function') {
        callback = opts;
        opts = {};
    } else if (!opts || typeof opts !== 'object') {
        opts = {
            mode: opts
        };
    }
    if (process.platform === 'win32' && invalidWin32Path(p)) //TURBOPACK unreachable
    ;
    let mode = opts.mode;
    const xfs = opts.fs || fs;
    if (mode === undefined) {
        mode = o777 & ~process.umask();
    }
    if (!made) made = null;
    callback = callback || function() {};
    p = path.resolve(p);
    xfs.mkdir(p, mode, (er)=>{
        if (!er) {
            made = made || p;
            return callback(null, made);
        }
        switch(er.code){
            case 'ENOENT':
                if (path.dirname(p) === p) return callback(er);
                mkdirs(path.dirname(p), opts, (er, made)=>{
                    if (er) callback(er, made);
                    else mkdirs(p, opts, callback, made);
                });
                break;
            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
                xfs.stat(p, (er2, stat)=>{
                    // if the stat fails, then that's super weird.
                    // let the original error be the failure reason.
                    if (er2 || !stat.isDirectory()) callback(er, made);
                    else callback(null, made);
                });
                break;
        }
    });
}
module.exports = mkdirs;
}),
"[project]/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const invalidWin32Path = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/win32.js [app-route] (ecmascript)").invalidWin32Path;
const o777 = parseInt('0777', 8);
function mkdirsSync(p, opts, made) {
    if (!opts || typeof opts !== 'object') {
        opts = {
            mode: opts
        };
    }
    let mode = opts.mode;
    const xfs = opts.fs || fs;
    if (process.platform === 'win32' && invalidWin32Path(p)) //TURBOPACK unreachable
    ;
    if (mode === undefined) {
        mode = o777 & ~process.umask();
    }
    if (!made) made = null;
    p = path.resolve(p);
    try {
        xfs.mkdirSync(p, mode);
        made = made || p;
    } catch (err0) {
        if (err0.code === 'ENOENT') {
            if (path.dirname(p) === p) throw err0;
            made = mkdirsSync(path.dirname(p), opts, made);
            mkdirsSync(p, opts, made);
        } else {
            // In the case of any other error, just see if there's a dir there
            // already. If so, then hooray!  If not, then something is borked.
            let stat;
            try {
                stat = xfs.statSync(p);
            } catch (err1) {
                throw err0;
            }
            if (!stat.isDirectory()) throw err0;
        }
    }
    return made;
}
module.exports = mkdirsSync;
}),
"[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const mkdirs = u(__turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/mkdirs.js [app-route] (ecmascript)"));
const mkdirsSync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js [app-route] (ecmascript)");
module.exports = {
    mkdirs,
    mkdirsSync,
    // alias
    mkdirp: mkdirs,
    mkdirpSync: mkdirsSync,
    ensureDir: mkdirs,
    ensureDirSync: mkdirsSync
};
}),
"[project]/node_modules/fs-extra/lib/util/utimes.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
function hasMillisResSync() {
    let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2));
    tmpfile = path.join(os.tmpdir(), tmpfile);
    // 550 millis past UNIX epoch
    const d = new Date(1435410243862);
    fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141');
    const fd = fs.openSync(tmpfile, 'r+');
    fs.futimesSync(fd, d, d);
    fs.closeSync(fd);
    return fs.statSync(tmpfile).mtime > 1435410243000;
}
function hasMillisRes(callback) {
    let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2));
    tmpfile = path.join(os.tmpdir(), tmpfile);
    // 550 millis past UNIX epoch
    const d = new Date(1435410243862);
    fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', (err)=>{
        if (err) return callback(err);
        fs.open(tmpfile, 'r+', (err, fd)=>{
            if (err) return callback(err);
            fs.futimes(fd, d, d, (err)=>{
                if (err) return callback(err);
                fs.close(fd, (err)=>{
                    if (err) return callback(err);
                    fs.stat(tmpfile, (err, stats)=>{
                        if (err) return callback(err);
                        callback(null, stats.mtime > 1435410243000);
                    });
                });
            });
        });
    });
}
function timeRemoveMillis(timestamp) {
    if (typeof timestamp === 'number') {
        return Math.floor(timestamp / 1000) * 1000;
    } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1000) * 1000);
    } else {
        throw new Error('fs-extra: timeRemoveMillis() unknown parameter type');
    }
}
function utimesMillis(path, atime, mtime, callback) {
    // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
    fs.open(path, 'r+', (err, fd)=>{
        if (err) return callback(err);
        fs.futimes(fd, atime, mtime, (futimesErr)=>{
            fs.close(fd, (closeErr)=>{
                if (callback) callback(futimesErr || closeErr);
            });
        });
    });
}
function utimesMillisSync(path, atime, mtime) {
    const fd = fs.openSync(path, 'r+');
    fs.futimesSync(fd, atime, mtime);
    return fs.closeSync(fd);
}
module.exports = {
    hasMillisRes,
    hasMillisResSync,
    timeRemoveMillis,
    utimesMillis,
    utimesMillisSync
};
}),
"[project]/node_modules/fs-extra/lib/util/stat.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const NODE_VERSION_MAJOR_WITH_BIGINT = 10;
const NODE_VERSION_MINOR_WITH_BIGINT = 5;
const NODE_VERSION_PATCH_WITH_BIGINT = 0;
const nodeVersion = process.versions.node.split('.');
const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);
function nodeSupportsBigInt() {
    if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
        return true;
    } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
        if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
            return true;
        } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
            if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
                return true;
            }
        }
    }
    return false;
}
function getStats(src, dest, cb) {
    if (nodeSupportsBigInt()) {
        fs.stat(src, {
            bigint: true
        }, (err, srcStat)=>{
            if (err) return cb(err);
            fs.stat(dest, {
                bigint: true
            }, (err, destStat)=>{
                if (err) {
                    if (err.code === 'ENOENT') return cb(null, {
                        srcStat,
                        destStat: null
                    });
                    return cb(err);
                }
                return cb(null, {
                    srcStat,
                    destStat
                });
            });
        });
    } else {
        fs.stat(src, (err, srcStat)=>{
            if (err) return cb(err);
            fs.stat(dest, (err, destStat)=>{
                if (err) {
                    if (err.code === 'ENOENT') return cb(null, {
                        srcStat,
                        destStat: null
                    });
                    return cb(err);
                }
                return cb(null, {
                    srcStat,
                    destStat
                });
            });
        });
    }
}
function getStatsSync(src, dest) {
    let srcStat, destStat;
    if (nodeSupportsBigInt()) {
        srcStat = fs.statSync(src, {
            bigint: true
        });
    } else {
        srcStat = fs.statSync(src);
    }
    try {
        if (nodeSupportsBigInt()) {
            destStat = fs.statSync(dest, {
                bigint: true
            });
        } else {
            destStat = fs.statSync(dest);
        }
    } catch (err) {
        if (err.code === 'ENOENT') return {
            srcStat,
            destStat: null
        };
        throw err;
    }
    return {
        srcStat,
        destStat
    };
}
function checkPaths(src, dest, funcName, cb) {
    getStats(src, dest, (err, stats)=>{
        if (err) return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            return cb(new Error('Source and destination must not be the same.'));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, {
            srcStat,
            destStat
        });
    });
}
function checkPathsSync(src, dest, funcName) {
    const { srcStat, destStat } = getStatsSync(src, dest);
    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error('Source and destination must not be the same.');
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
    }
    return {
        srcStat,
        destStat
    };
}
// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths(src, srcStat, dest, funcName, cb) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();
    if (nodeSupportsBigInt()) {
        fs.stat(destParent, {
            bigint: true
        }, (err, destStat)=>{
            if (err) {
                if (err.code === 'ENOENT') return cb();
                return cb(err);
            }
            if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
    } else {
        fs.stat(destParent, (err, destStat)=>{
            if (err) {
                if (err.code === 'ENOENT') return cb();
                return cb(err);
            }
            if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
    }
}
function checkParentPathsSync(src, srcStat, dest, funcName) {
    const srcParent = path.resolve(path.dirname(src));
    const destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return;
    let destStat;
    try {
        if (nodeSupportsBigInt()) {
            destStat = fs.statSync(destParent, {
                bigint: true
            });
        } else {
            destStat = fs.statSync(destParent);
        }
    } catch (err) {
        if (err.code === 'ENOENT') return;
        throw err;
    }
    if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error(errMsg(src, dest, funcName));
    }
    return checkParentPathsSync(src, srcStat, destParent, funcName);
}
// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir(src, dest) {
    const srcArr = path.resolve(src).split(path.sep).filter((i)=>i);
    const destArr = path.resolve(dest).split(path.sep).filter((i)=>i);
    return srcArr.reduce((acc, cur, i)=>acc && destArr[i] === cur, true);
}
function errMsg(src, dest, funcName) {
    return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
}
module.exports = {
    checkPaths,
    checkPathsSync,
    checkParentPaths,
    checkParentPathsSync,
    isSrcSubdir
};
}),
"[project]/node_modules/fs-extra/lib/util/buffer.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable node/no-deprecated-api */ module.exports = function(size) {
    if (typeof Buffer.allocUnsafe === 'function') {
        try {
            return Buffer.allocUnsafe(size);
        } catch (e) {
            return new Buffer(size);
        }
    }
    return new Buffer(size);
};
}),
"[project]/node_modules/fs-extra/lib/copy-sync/copy-sync.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const mkdirpSync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)").mkdirsSync;
const utimesSync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/utimes.js [app-route] (ecmascript)").utimesMillisSync;
const stat = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/stat.js [app-route] (ecmascript)");
function copySync(src, dest, opts) {
    if (typeof opts === 'function') {
        opts = {
            filter: opts
        };
    }
    opts = opts || {};
    opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
    opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber
    // Warn about using preserveTimestamps on 32-bit node
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy');
    stat.checkParentPathsSync(src, srcStat, dest, 'copy');
    return handleFilterAndCopy(destStat, src, dest, opts);
}
function handleFilterAndCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest)) return;
    const destParent = path.dirname(dest);
    if (!fs.existsSync(destParent)) mkdirpSync(destParent);
    return startCopy(destStat, src, dest, opts);
}
function startCopy(destStat, src, dest, opts) {
    if (opts.filter && !opts.filter(src, dest)) return;
    return getStats(destStat, src, dest, opts);
}
function getStats(destStat, src, dest, opts) {
    const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
    const srcStat = statSync(src);
    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
    else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
}
function onFile(srcStat, destStat, src, dest, opts) {
    if (!destStat) return copyFile(srcStat, src, dest, opts);
    return mayCopyFile(srcStat, src, dest, opts);
}
function mayCopyFile(srcStat, src, dest, opts) {
    if (opts.overwrite) {
        fs.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
    } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
    }
}
function copyFile(srcStat, src, dest, opts) {
    if (typeof fs.copyFileSync === 'function') {
        fs.copyFileSync(src, dest);
        fs.chmodSync(dest, srcStat.mode);
        if (opts.preserveTimestamps) {
            return utimesSync(dest, srcStat.atime, srcStat.mtime);
        }
        return;
    }
    return copyFileFallback(srcStat, src, dest, opts);
}
function copyFileFallback(srcStat, src, dest, opts) {
    const BUF_LENGTH = 64 * 1024;
    const _buff = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/buffer.js [app-route] (ecmascript)")(BUF_LENGTH);
    const fdr = fs.openSync(src, 'r');
    const fdw = fs.openSync(dest, 'w', srcStat.mode);
    let pos = 0;
    while(pos < srcStat.size){
        const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
    }
    if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime);
    fs.closeSync(fdr);
    fs.closeSync(fdw);
}
function onDir(srcStat, destStat, src, dest, opts) {
    if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts);
    if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
    }
    return copyDir(src, dest, opts);
}
function mkDirAndCopy(srcStat, src, dest, opts) {
    fs.mkdirSync(dest);
    copyDir(src, dest, opts);
    return fs.chmodSync(dest, srcStat.mode);
}
function copyDir(src, dest, opts) {
    fs.readdirSync(src).forEach((item)=>copyDirItem(item, src, dest, opts));
}
function copyDirItem(item, src, dest, opts) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy');
    return startCopy(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src, dest, opts) {
    let resolvedSrc = fs.readlinkSync(src);
    if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
    }
    if (!destStat) {
        return fs.symlinkSync(resolvedSrc, dest);
    } else {
        let resolvedDest;
        try {
            resolvedDest = fs.readlinkSync(dest);
        } catch (err) {
            // dest exists and is a regular file or directory,
            // Windows may throw UNKNOWN error. If dest already exists,
            // fs throws error anyway, so no need to guard against it here.
            if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);
            throw err;
        }
        if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        // prevent copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
            throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
    }
}
function copyLink(resolvedSrc, dest) {
    fs.unlinkSync(dest);
    return fs.symlinkSync(resolvedSrc, dest);
}
module.exports = copySync;
}),
"[project]/node_modules/fs-extra/lib/copy-sync/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    copySync: __turbopack_context__.r("[project]/node_modules/fs-extra/lib/copy-sync/copy-sync.js [app-route] (ecmascript)")
};
}),
"[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromPromise;
const fs = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/fs/index.js [app-route] (ecmascript)");
function pathExists(path) {
    return fs.access(path).then(()=>true).catch(()=>false);
}
module.exports = {
    pathExists: u(pathExists),
    pathExistsSync: fs.existsSync
};
}),
"[project]/node_modules/fs-extra/lib/copy/copy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const mkdirp = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)").mkdirs;
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
const utimes = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/utimes.js [app-route] (ecmascript)").utimesMillis;
const stat = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/stat.js [app-route] (ecmascript)");
function copy(src, dest, opts, cb) {
    if (typeof opts === 'function' && !cb) {
        cb = opts;
        opts = {};
    } else if (typeof opts === 'function') {
        opts = {
            filter: opts
        };
    }
    cb = cb || function() {};
    opts = opts || {};
    opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now
    opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber
    // Warn about using preserveTimestamps on 32-bit node
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    stat.checkPaths(src, dest, 'copy', (err, stats)=>{
        if (err) return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, 'copy', (err)=>{
            if (err) return cb(err);
            if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
            return checkParentDir(destStat, src, dest, opts, cb);
        });
    });
}
function checkParentDir(destStat, src, dest, opts, cb) {
    const destParent = path.dirname(dest);
    pathExists(destParent, (err, dirExists)=>{
        if (err) return cb(err);
        if (dirExists) return startCopy(destStat, src, dest, opts, cb);
        mkdirp(destParent, (err)=>{
            if (err) return cb(err);
            return startCopy(destStat, src, dest, opts, cb);
        });
    });
}
function handleFilter(onInclude, destStat, src, dest, opts, cb) {
    Promise.resolve(opts.filter(src, dest)).then((include)=>{
        if (include) return onInclude(destStat, src, dest, opts, cb);
        return cb();
    }, (error)=>cb(error));
}
function startCopy(destStat, src, dest, opts, cb) {
    if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb);
    return getStats(destStat, src, dest, opts, cb);
}
function getStats(destStat, src, dest, opts, cb) {
    const stat = opts.dereference ? fs.stat : fs.lstat;
    stat(src, (err, srcStat)=>{
        if (err) return cb(err);
        if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb);
    });
}
function onFile(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat) return copyFile(srcStat, src, dest, opts, cb);
    return mayCopyFile(srcStat, src, dest, opts, cb);
}
function mayCopyFile(srcStat, src, dest, opts, cb) {
    if (opts.overwrite) {
        fs.unlink(dest, (err)=>{
            if (err) return cb(err);
            return copyFile(srcStat, src, dest, opts, cb);
        });
    } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
    } else return cb();
}
function copyFile(srcStat, src, dest, opts, cb) {
    if (typeof fs.copyFile === 'function') {
        return fs.copyFile(src, dest, (err)=>{
            if (err) return cb(err);
            return setDestModeAndTimestamps(srcStat, dest, opts, cb);
        });
    }
    return copyFileFallback(srcStat, src, dest, opts, cb);
}
function copyFileFallback(srcStat, src, dest, opts, cb) {
    const rs = fs.createReadStream(src);
    rs.on('error', (err)=>cb(err)).once('open', ()=>{
        const ws = fs.createWriteStream(dest, {
            mode: srcStat.mode
        });
        ws.on('error', (err)=>cb(err)).on('open', ()=>rs.pipe(ws)).once('close', ()=>setDestModeAndTimestamps(srcStat, dest, opts, cb));
    });
}
function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
    fs.chmod(dest, srcStat.mode, (err)=>{
        if (err) return cb(err);
        if (opts.preserveTimestamps) {
            return utimes(dest, srcStat.atime, srcStat.mtime, cb);
        }
        return cb();
    });
}
function onDir(srcStat, destStat, src, dest, opts, cb) {
    if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb);
    if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
    }
    return copyDir(src, dest, opts, cb);
}
function mkDirAndCopy(srcStat, src, dest, opts, cb) {
    fs.mkdir(dest, (err)=>{
        if (err) return cb(err);
        copyDir(src, dest, opts, (err)=>{
            if (err) return cb(err);
            return fs.chmod(dest, srcStat.mode, cb);
        });
    });
}
function copyDir(src, dest, opts, cb) {
    fs.readdir(src, (err, items)=>{
        if (err) return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
    });
}
function copyDirItems(items, src, dest, opts, cb) {
    const item = items.pop();
    if (!item) return cb();
    return copyDirItem(items, item, src, dest, opts, cb);
}
function copyDirItem(items, item, src, dest, opts, cb) {
    const srcItem = path.join(src, item);
    const destItem = path.join(dest, item);
    stat.checkPaths(srcItem, destItem, 'copy', (err, stats)=>{
        if (err) return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err)=>{
            if (err) return cb(err);
            return copyDirItems(items, src, dest, opts, cb);
        });
    });
}
function onLink(destStat, src, dest, opts, cb) {
    fs.readlink(src, (err, resolvedSrc)=>{
        if (err) return cb(err);
        if (opts.dereference) {
            resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
            return fs.symlink(resolvedSrc, dest, cb);
        } else {
            fs.readlink(dest, (err, resolvedDest)=>{
                if (err) {
                    // dest exists and is a regular file or directory,
                    // Windows may throw UNKNOWN error. If dest already exists,
                    // fs throws error anyway, so no need to guard against it here.
                    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb);
                    return cb(err);
                }
                if (opts.dereference) {
                    resolvedDest = path.resolve(process.cwd(), resolvedDest);
                }
                if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                    return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
                }
                // do not copy if src is a subdir of dest since unlinking
                // dest in this case would result in removing src contents
                // and therefore a broken symlink would be created.
                if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                    return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
                }
                return copyLink(resolvedSrc, dest, cb);
            });
        }
    });
}
function copyLink(resolvedSrc, dest, cb) {
    fs.unlink(dest, (err)=>{
        if (err) return cb(err);
        return fs.symlink(resolvedSrc, dest, cb);
    });
}
module.exports = copy;
}),
"[project]/node_modules/fs-extra/lib/copy/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
module.exports = {
    copy: u(__turbopack_context__.r("[project]/node_modules/fs-extra/lib/copy/copy.js [app-route] (ecmascript)"))
};
}),
"[project]/node_modules/fs-extra/lib/remove/rimraf.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
const isWindows = process.platform === 'win32';
function defaults(options) {
    const methods = [
        'unlink',
        'chmod',
        'stat',
        'lstat',
        'rmdir',
        'readdir'
    ];
    methods.forEach((m)=>{
        options[m] = options[m] || fs[m];
        m = m + 'Sync';
        options[m] = options[m] || fs[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
}
function rimraf(p, options, cb) {
    let busyTries = 0;
    if (typeof options === 'function') {
        cb = options;
        options = {};
    }
    assert(p, 'rimraf: missing path');
    assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
    assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');
    assert(options, 'rimraf: invalid options argument provided');
    assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');
    defaults(options);
    rimraf_(p, options, function CB(er) {
        if (er) {
            if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') && busyTries < options.maxBusyTries) {
                busyTries++;
                const time = busyTries * 100;
                // try again, with the same exact callback as this one.
                return setTimeout(()=>rimraf_(p, options, CB), time);
            }
            // already gone
            if (er.code === 'ENOENT') er = null;
        }
        cb(er);
    });
}
// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    // sunos lets the root user unlink directories, which is... weird.
    // so we have to lstat here and make sure it's not a dir.
    options.lstat(p, (er, st)=>{
        if (er && er.code === 'ENOENT') {
            return cb(null);
        }
        // Windows can EPERM on stat.  Life is suffering.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
        if (st && st.isDirectory()) {
            return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er)=>{
            if (er) {
                if (er.code === 'ENOENT') {
                    return cb(null);
                }
                if (er.code === 'EPERM') {
                    return ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : rmdir(p, options, er, cb);
                }
                if (er.code === 'EISDIR') {
                    return rmdir(p, options, er, cb);
                }
            }
            return cb(er);
        });
    });
}
function fixWinEPERM(p, options, er, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    if (er) {
        assert(er instanceof Error);
    }
    options.chmod(p, 0o666, (er2)=>{
        if (er2) {
            cb(er2.code === 'ENOENT' ? null : er);
        } else {
            options.stat(p, (er3, stats)=>{
                if (er3) {
                    cb(er3.code === 'ENOENT' ? null : er);
                } else if (stats.isDirectory()) {
                    rmdir(p, options, er, cb);
                } else {
                    options.unlink(p, cb);
                }
            });
        }
    });
}
function fixWinEPERMSync(p, options, er) {
    let stats;
    assert(p);
    assert(options);
    if (er) {
        assert(er instanceof Error);
    }
    try {
        options.chmodSync(p, 0o666);
    } catch (er2) {
        if (er2.code === 'ENOENT') {
            return;
        } else {
            throw er;
        }
    }
    try {
        stats = options.statSync(p);
    } catch (er3) {
        if (er3.code === 'ENOENT') {
            return;
        } else {
            throw er;
        }
    }
    if (stats.isDirectory()) {
        rmdirSync(p, options, er);
    } else {
        options.unlinkSync(p);
    }
}
function rmdir(p, options, originalEr, cb) {
    assert(p);
    assert(options);
    if (originalEr) {
        assert(originalEr instanceof Error);
    }
    assert(typeof cb === 'function');
    // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
    // if we guessed wrong, and it's not a directory, then
    // raise the original error.
    options.rmdir(p, (er)=>{
        if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
            rmkids(p, options, cb);
        } else if (er && er.code === 'ENOTDIR') {
            cb(originalEr);
        } else {
            cb(er);
        }
    });
}
function rmkids(p, options, cb) {
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    options.readdir(p, (er, files)=>{
        if (er) return cb(er);
        let n = files.length;
        let errState;
        if (n === 0) return options.rmdir(p, cb);
        files.forEach((f)=>{
            rimraf(path.join(p, f), options, (er)=>{
                if (errState) {
                    return;
                }
                if (er) return cb(errState = er);
                if (--n === 0) {
                    options.rmdir(p, cb);
                }
            });
        });
    });
}
// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync(p, options) {
    let st;
    options = options || {};
    defaults(options);
    assert(p, 'rimraf: missing path');
    assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');
    assert(options, 'rimraf: missing options');
    assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');
    try {
        st = options.lstatSync(p);
    } catch (er) {
        if (er.code === 'ENOENT') {
            return;
        }
        // Windows can EPERM on stat.  Life is suffering.
        if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
        ;
    }
    try {
        // sunos lets the root user unlink directories, which is... weird.
        if (st && st.isDirectory()) {
            rmdirSync(p, options, null);
        } else {
            options.unlinkSync(p);
        }
    } catch (er) {
        if (er.code === 'ENOENT') {
            return;
        } else if (er.code === 'EPERM') {
            return ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : rmdirSync(p, options, er);
        } else if (er.code !== 'EISDIR') {
            throw er;
        }
        rmdirSync(p, options, er);
    }
}
function rmdirSync(p, options, originalEr) {
    assert(p);
    assert(options);
    if (originalEr) {
        assert(originalEr instanceof Error);
    }
    try {
        options.rmdirSync(p);
    } catch (er) {
        if (er.code === 'ENOTDIR') {
            throw originalEr;
        } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
            rmkidsSync(p, options);
        } else if (er.code !== 'ENOENT') {
            throw er;
        }
    }
}
function rmkidsSync(p, options) {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f)=>rimrafSync(path.join(p, f), options));
    if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
    ;
    else {
        const ret = options.rmdirSync(p, options);
        return ret;
    }
}
module.exports = rimraf;
rimraf.sync = rimrafSync;
}),
"[project]/node_modules/fs-extra/lib/remove/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const rimraf = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/remove/rimraf.js [app-route] (ecmascript)");
module.exports = {
    remove: u(rimraf),
    removeSync: rimraf.sync
};
}),
"[project]/node_modules/fs-extra/lib/empty/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const mkdir = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const remove = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/remove/index.js [app-route] (ecmascript)");
const emptyDir = u(function emptyDir(dir, callback) {
    callback = callback || function() {};
    fs.readdir(dir, (err, items)=>{
        if (err) return mkdir.mkdirs(dir, callback);
        items = items.map((item)=>path.join(dir, item));
        deleteItem();
        function deleteItem() {
            const item = items.pop();
            if (!item) return callback();
            remove.remove(item, (err)=>{
                if (err) return callback(err);
                deleteItem();
            });
        }
    });
});
function emptyDirSync(dir) {
    let items;
    try {
        items = fs.readdirSync(dir);
    } catch (err) {
        return mkdir.mkdirsSync(dir);
    }
    items.forEach((item)=>{
        item = path.join(dir, item);
        remove.removeSync(item);
    });
}
module.exports = {
    emptyDirSync,
    emptydirSync: emptyDirSync,
    emptyDir,
    emptydir: emptyDir
};
}),
"[project]/node_modules/fs-extra/lib/ensure/file.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const mkdir = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
function createFile(file, callback) {
    function makeFile() {
        fs.writeFile(file, '', (err)=>{
            if (err) return callback(err);
            callback();
        });
    }
    fs.stat(file, (err, stats)=>{
        if (!err && stats.isFile()) return callback();
        const dir = path.dirname(file);
        pathExists(dir, (err, dirExists)=>{
            if (err) return callback(err);
            if (dirExists) return makeFile();
            mkdir.mkdirs(dir, (err)=>{
                if (err) return callback(err);
                makeFile();
            });
        });
    });
}
function createFileSync(file) {
    let stats;
    try {
        stats = fs.statSync(file);
    } catch (e) {}
    if (stats && stats.isFile()) return;
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
    }
    fs.writeFileSync(file, '');
}
module.exports = {
    createFile: u(createFile),
    createFileSync
};
}),
"[project]/node_modules/fs-extra/lib/ensure/link.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const mkdir = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
function createLink(srcpath, dstpath, callback) {
    function makeLink(srcpath, dstpath) {
        fs.link(srcpath, dstpath, (err)=>{
            if (err) return callback(err);
            callback(null);
        });
    }
    pathExists(dstpath, (err, destinationExists)=>{
        if (err) return callback(err);
        if (destinationExists) return callback(null);
        fs.lstat(srcpath, (err)=>{
            if (err) {
                err.message = err.message.replace('lstat', 'ensureLink');
                return callback(err);
            }
            const dir = path.dirname(dstpath);
            pathExists(dir, (err, dirExists)=>{
                if (err) return callback(err);
                if (dirExists) return makeLink(srcpath, dstpath);
                mkdir.mkdirs(dir, (err)=>{
                    if (err) return callback(err);
                    makeLink(srcpath, dstpath);
                });
            });
        });
    });
}
function createLinkSync(srcpath, dstpath) {
    const destinationExists = fs.existsSync(dstpath);
    if (destinationExists) return undefined;
    try {
        fs.lstatSync(srcpath);
    } catch (err) {
        err.message = err.message.replace('lstat', 'ensureLink');
        throw err;
    }
    const dir = path.dirname(dstpath);
    const dirExists = fs.existsSync(dir);
    if (dirExists) return fs.linkSync(srcpath, dstpath);
    mkdir.mkdirsSync(dir);
    return fs.linkSync(srcpath, dstpath);
}
module.exports = {
    createLink: u(createLink),
    createLinkSync
};
}),
"[project]/node_modules/fs-extra/lib/ensure/symlink-paths.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */ function symlinkPaths(srcpath, dstpath, callback) {
    if (path.isAbsolute(srcpath)) {
        return fs.lstat(srcpath, (err)=>{
            if (err) {
                err.message = err.message.replace('lstat', 'ensureSymlink');
                return callback(err);
            }
            return callback(null, {
                'toCwd': srcpath,
                'toDst': srcpath
            });
        });
    } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists)=>{
            if (err) return callback(err);
            if (exists) {
                return callback(null, {
                    'toCwd': relativeToDst,
                    'toDst': srcpath
                });
            } else {
                return fs.lstat(srcpath, (err)=>{
                    if (err) {
                        err.message = err.message.replace('lstat', 'ensureSymlink');
                        return callback(err);
                    }
                    return callback(null, {
                        'toCwd': srcpath,
                        'toDst': path.relative(dstdir, srcpath)
                    });
                });
            }
        });
    }
}
function symlinkPathsSync(srcpath, dstpath) {
    let exists;
    if (path.isAbsolute(srcpath)) {
        exists = fs.existsSync(srcpath);
        if (!exists) throw new Error('absolute srcpath does not exist');
        return {
            'toCwd': srcpath,
            'toDst': srcpath
        };
    } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        exists = fs.existsSync(relativeToDst);
        if (exists) {
            return {
                'toCwd': relativeToDst,
                'toDst': srcpath
            };
        } else {
            exists = fs.existsSync(srcpath);
            if (!exists) throw new Error('relative srcpath does not exist');
            return {
                'toCwd': srcpath,
                'toDst': path.relative(dstdir, srcpath)
            };
        }
    }
}
module.exports = {
    symlinkPaths,
    symlinkPathsSync
};
}),
"[project]/node_modules/fs-extra/lib/ensure/symlink-type.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
function symlinkType(srcpath, type, callback) {
    callback = typeof type === 'function' ? type : callback;
    type = typeof type === 'function' ? false : type;
    if (type) return callback(null, type);
    fs.lstat(srcpath, (err, stats)=>{
        if (err) return callback(null, 'file');
        type = stats && stats.isDirectory() ? 'dir' : 'file';
        callback(null, type);
    });
}
function symlinkTypeSync(srcpath, type) {
    let stats;
    if (type) return type;
    try {
        stats = fs.lstatSync(srcpath);
    } catch (e) {
        return 'file';
    }
    return stats && stats.isDirectory() ? 'dir' : 'file';
}
module.exports = {
    symlinkType,
    symlinkTypeSync
};
}),
"[project]/node_modules/fs-extra/lib/ensure/symlink.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const _mkdirs = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const mkdirs = _mkdirs.mkdirs;
const mkdirsSync = _mkdirs.mkdirsSync;
const _symlinkPaths = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/ensure/symlink-paths.js [app-route] (ecmascript)");
const symlinkPaths = _symlinkPaths.symlinkPaths;
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
const _symlinkType = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/ensure/symlink-type.js [app-route] (ecmascript)");
const symlinkType = _symlinkType.symlinkType;
const symlinkTypeSync = _symlinkType.symlinkTypeSync;
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
function createSymlink(srcpath, dstpath, type, callback) {
    callback = typeof type === 'function' ? type : callback;
    type = typeof type === 'function' ? false : type;
    pathExists(dstpath, (err, destinationExists)=>{
        if (err) return callback(err);
        if (destinationExists) return callback(null);
        symlinkPaths(srcpath, dstpath, (err, relative)=>{
            if (err) return callback(err);
            srcpath = relative.toDst;
            symlinkType(relative.toCwd, type, (err, type)=>{
                if (err) return callback(err);
                const dir = path.dirname(dstpath);
                pathExists(dir, (err, dirExists)=>{
                    if (err) return callback(err);
                    if (dirExists) return fs.symlink(srcpath, dstpath, type, callback);
                    mkdirs(dir, (err)=>{
                        if (err) return callback(err);
                        fs.symlink(srcpath, dstpath, type, callback);
                    });
                });
            });
        });
    });
}
function createSymlinkSync(srcpath, dstpath, type) {
    const destinationExists = fs.existsSync(dstpath);
    if (destinationExists) return undefined;
    const relative = symlinkPathsSync(srcpath, dstpath);
    srcpath = relative.toDst;
    type = symlinkTypeSync(relative.toCwd, type);
    const dir = path.dirname(dstpath);
    const exists = fs.existsSync(dir);
    if (exists) return fs.symlinkSync(srcpath, dstpath, type);
    mkdirsSync(dir);
    return fs.symlinkSync(srcpath, dstpath, type);
}
module.exports = {
    createSymlink: u(createSymlink),
    createSymlinkSync
};
}),
"[project]/node_modules/fs-extra/lib/ensure/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const file = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/ensure/file.js [app-route] (ecmascript)");
const link = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/ensure/link.js [app-route] (ecmascript)");
const symlink = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/ensure/symlink.js [app-route] (ecmascript)");
module.exports = {
    // file
    createFile: file.createFile,
    createFileSync: file.createFileSync,
    ensureFile: file.createFile,
    ensureFileSync: file.createFileSync,
    // link
    createLink: link.createLink,
    createLinkSync: link.createLinkSync,
    ensureLink: link.createLink,
    ensureLinkSync: link.createLinkSync,
    // symlink
    createSymlink: symlink.createSymlink,
    createSymlinkSync: symlink.createSymlinkSync,
    ensureSymlink: symlink.createSymlink,
    ensureSymlinkSync: symlink.createSymlinkSync
};
}),
"[project]/node_modules/fs-extra/lib/json/jsonfile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const jsonFile = __turbopack_context__.r("[project]/node_modules/jsonfile/index.js [app-route] (ecmascript)");
module.exports = {
    // jsonfile exports
    readJson: u(jsonFile.readFile),
    readJsonSync: jsonFile.readFileSync,
    writeJson: u(jsonFile.writeFile),
    writeJsonSync: jsonFile.writeFileSync
};
}),
"[project]/node_modules/fs-extra/lib/json/output-json.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const mkdir = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
const jsonFile = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/json/jsonfile.js [app-route] (ecmascript)");
function outputJson(file, data, options, callback) {
    if (typeof options === 'function') {
        callback = options;
        options = {};
    }
    const dir = path.dirname(file);
    pathExists(dir, (err, itDoes)=>{
        if (err) return callback(err);
        if (itDoes) return jsonFile.writeJson(file, data, options, callback);
        mkdir.mkdirs(dir, (err)=>{
            if (err) return callback(err);
            jsonFile.writeJson(file, data, options, callback);
        });
    });
}
module.exports = outputJson;
}),
"[project]/node_modules/fs-extra/lib/json/output-json-sync.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const mkdir = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const jsonFile = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/json/jsonfile.js [app-route] (ecmascript)");
function outputJsonSync(file, data, options) {
    const dir = path.dirname(file);
    if (!fs.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
    }
    jsonFile.writeJsonSync(file, data, options);
}
module.exports = outputJsonSync;
}),
"[project]/node_modules/fs-extra/lib/json/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const jsonFile = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/json/jsonfile.js [app-route] (ecmascript)");
jsonFile.outputJson = u(__turbopack_context__.r("[project]/node_modules/fs-extra/lib/json/output-json.js [app-route] (ecmascript)"));
jsonFile.outputJsonSync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/json/output-json-sync.js [app-route] (ecmascript)");
// aliases
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
module.exports = jsonFile;
}),
"[project]/node_modules/fs-extra/lib/move-sync/move-sync.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const copySync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/copy-sync/index.js [app-route] (ecmascript)").copySync;
const removeSync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/remove/index.js [app-route] (ecmascript)").removeSync;
const mkdirpSync = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)").mkdirpSync;
const stat = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/stat.js [app-route] (ecmascript)");
function moveSync(src, dest, opts) {
    opts = opts || {};
    const overwrite = opts.overwrite || opts.clobber || false;
    const { srcStat } = stat.checkPathsSync(src, dest, 'move');
    stat.checkParentPathsSync(src, srcStat, dest, 'move');
    mkdirpSync(path.dirname(dest));
    return doRename(src, dest, overwrite);
}
function doRename(src, dest, overwrite) {
    if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
    }
    if (fs.existsSync(dest)) throw new Error('dest already exists.');
    return rename(src, dest, overwrite);
}
function rename(src, dest, overwrite) {
    try {
        fs.renameSync(src, dest);
    } catch (err) {
        if (err.code !== 'EXDEV') throw err;
        return moveAcrossDevice(src, dest, overwrite);
    }
}
function moveAcrossDevice(src, dest, overwrite) {
    const opts = {
        overwrite,
        errorOnExist: true
    };
    copySync(src, dest, opts);
    return removeSync(src);
}
module.exports = moveSync;
}),
"[project]/node_modules/fs-extra/lib/move-sync/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {
    moveSync: __turbopack_context__.r("[project]/node_modules/fs-extra/lib/move-sync/move-sync.js [app-route] (ecmascript)")
};
}),
"[project]/node_modules/fs-extra/lib/move/move.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const copy = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/copy/index.js [app-route] (ecmascript)").copy;
const remove = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/remove/index.js [app-route] (ecmascript)").remove;
const mkdirp = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)").mkdirp;
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
const stat = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/util/stat.js [app-route] (ecmascript)");
function move(src, dest, opts, cb) {
    if (typeof opts === 'function') {
        cb = opts;
        opts = {};
    }
    const overwrite = opts.overwrite || opts.clobber || false;
    stat.checkPaths(src, dest, 'move', (err, stats)=>{
        if (err) return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, 'move', (err)=>{
            if (err) return cb(err);
            mkdirp(path.dirname(dest), (err)=>{
                if (err) return cb(err);
                return doRename(src, dest, overwrite, cb);
            });
        });
    });
}
function doRename(src, dest, overwrite, cb) {
    if (overwrite) {
        return remove(dest, (err)=>{
            if (err) return cb(err);
            return rename(src, dest, overwrite, cb);
        });
    }
    pathExists(dest, (err, destExists)=>{
        if (err) return cb(err);
        if (destExists) return cb(new Error('dest already exists.'));
        return rename(src, dest, overwrite, cb);
    });
}
function rename(src, dest, overwrite, cb) {
    fs.rename(src, dest, (err)=>{
        if (!err) return cb();
        if (err.code !== 'EXDEV') return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
    });
}
function moveAcrossDevice(src, dest, overwrite, cb) {
    const opts = {
        overwrite,
        errorOnExist: true
    };
    copy(src, dest, opts, (err)=>{
        if (err) return cb(err);
        return remove(src, cb);
    });
}
module.exports = move;
}),
"[project]/node_modules/fs-extra/lib/move/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
module.exports = {
    move: u(__turbopack_context__.r("[project]/node_modules/fs-extra/lib/move/move.js [app-route] (ecmascript)"))
};
}),
"[project]/node_modules/fs-extra/lib/output/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const u = __turbopack_context__.r("[project]/node_modules/universalify/index.js [app-route] (ecmascript)").fromCallback;
const fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const mkdir = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)");
const pathExists = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)").pathExists;
function outputFile(file, data, encoding, callback) {
    if (typeof encoding === 'function') {
        callback = encoding;
        encoding = 'utf8';
    }
    const dir = path.dirname(file);
    pathExists(dir, (err, itDoes)=>{
        if (err) return callback(err);
        if (itDoes) return fs.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err)=>{
            if (err) return callback(err);
            fs.writeFile(file, data, encoding, callback);
        });
    });
}
function outputFileSync(file, ...args) {
    const dir = path.dirname(file);
    if (fs.existsSync(dir)) {
        return fs.writeFileSync(file, ...args);
    }
    mkdir.mkdirsSync(dir);
    fs.writeFileSync(file, ...args);
}
module.exports = {
    outputFile: u(outputFile),
    outputFileSync
};
}),
"[project]/node_modules/fs-extra/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Object.assign({}, __turbopack_context__.r("[project]/node_modules/fs-extra/lib/fs/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/copy-sync/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/copy/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/empty/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/ensure/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/json/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/mkdirs/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/move-sync/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/move/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/output/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/path-exists/index.js [app-route] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/fs-extra/lib/remove/index.js [app-route] (ecmascript)"));
// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.
const fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
    Object.defineProperty(module.exports, 'promises', {
        get () {
            return fs.promises;
        }
    });
}
}),
"[project]/node_modules/jsonfile/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

var _fs;
try {
    _fs = __turbopack_context__.r("[project]/node_modules/graceful-fs/graceful-fs.js [app-route] (ecmascript)");
} catch (_) {
    _fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
}
function readFile(file, options, callback) {
    if (callback == null) {
        callback = options;
        options = {};
    }
    if (typeof options === 'string') {
        options = {
            encoding: options
        };
    }
    options = options || {};
    var fs = options.fs || _fs;
    var shouldThrow = true;
    if ('throws' in options) {
        shouldThrow = options.throws;
    }
    fs.readFile(file, options, function(err, data) {
        if (err) return callback(err);
        data = stripBom(data);
        var obj;
        try {
            obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
            if (shouldThrow) {
                err2.message = file + ': ' + err2.message;
                return callback(err2);
            } else {
                return callback(null, null);
            }
        }
        callback(null, obj);
    });
}
function readFileSync(file, options) {
    options = options || {};
    if (typeof options === 'string') {
        options = {
            encoding: options
        };
    }
    var fs = options.fs || _fs;
    var shouldThrow = true;
    if ('throws' in options) {
        shouldThrow = options.throws;
    }
    try {
        var content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
    } catch (err) {
        if (shouldThrow) {
            err.message = file + ': ' + err.message;
            throw err;
        } else {
            return null;
        }
    }
}
function stringify(obj, options) {
    var spaces;
    var EOL = '\n';
    if (typeof options === 'object' && options !== null) {
        if (options.spaces) {
            spaces = options.spaces;
        }
        if (options.EOL) {
            EOL = options.EOL;
        }
    }
    var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
    return str.replace(/\n/g, EOL) + EOL;
}
function writeFile(file, obj, options, callback) {
    if (callback == null) {
        callback = options;
        options = {};
    }
    options = options || {};
    var fs = options.fs || _fs;
    var str = '';
    try {
        str = stringify(obj, options);
    } catch (err) {
        // Need to return whether a callback was passed or not
        if (callback) callback(err, null);
        return;
    }
    fs.writeFile(file, str, options, callback);
}
function writeFileSync(file, obj, options) {
    options = options || {};
    var fs = options.fs || _fs;
    var str = stringify(obj, options);
    // not sure if fs.writeFileSync returns anything, but just in case
    return fs.writeFileSync(file, str, options);
}
function stripBom(content) {
    // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
    if (Buffer.isBuffer(content)) content = content.toString('utf8');
    content = content.replace(/^\uFEFF/, '');
    return content;
}
var jsonfile = {
    readFile: readFile,
    readFileSync: readFileSync,
    writeFile: writeFile,
    writeFileSync: writeFileSync
};
module.exports = jsonfile;
}),
"[project]/node_modules/streamroller/lib/now.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

// allows us to inject a mock date in tests
module.exports = ()=>new Date();
}),
"[project]/node_modules/streamroller/lib/fileNameFormatter.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("streamroller:fileNameFormatter");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const ZIP_EXT = ".gz";
const DEFAULT_FILENAME_SEP = ".";
module.exports = ({ file, keepFileExt, needsIndex, alwaysIncludeDate, compress, fileNameSep })=>{
    let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
    const dirAndName = path.join(file.dir, file.name);
    const ext = (f)=>f + file.ext;
    const index = (f, i, d)=>(needsIndex || !d) && i ? f + FILENAME_SEP + i : f;
    const date = (f, i, d)=>{
        return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
    };
    const gzip = (f, i)=>i && compress ? f + ZIP_EXT : f;
    const parts = keepFileExt ? [
        date,
        index,
        ext,
        gzip
    ] : [
        ext,
        date,
        index,
        gzip
    ];
    return ({ date, index })=>{
        debug(`_formatFileName: date=${date}, index=${index}`);
        return parts.reduce((filename, part)=>part(filename, index, date), dirAndName);
    };
};
}),
"[project]/node_modules/streamroller/lib/fileNameParser.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("streamroller:fileNameParser");
const ZIP_EXT = ".gz";
const format = __turbopack_context__.r("[project]/node_modules/date-format/lib/index.js [app-route] (ecmascript)");
const DEFAULT_FILENAME_SEP = ".";
module.exports = ({ file, keepFileExt, pattern, fileNameSep })=>{
    let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
    // All these functions take two arguments: f, the filename, and p, the result placeholder
    // They return the filename with any matching parts removed.
    // The "zip" function, for instance, removes the ".gz" part of the filename (if present)
    const zip = (f, p)=>{
        if (f.endsWith(ZIP_EXT)) {
            debug("it is gzipped");
            p.isCompressed = true;
            return f.slice(0, -1 * ZIP_EXT.length);
        }
        return f;
    };
    const __NOT_MATCHING__ = "__NOT_MATCHING__";
    const extAtEnd = (f)=>{
        if (f.startsWith(file.name) && f.endsWith(file.ext)) {
            debug("it starts and ends with the right things");
            return f.slice(file.name.length + 1, -1 * file.ext.length);
        }
        return __NOT_MATCHING__;
    };
    const extInMiddle = (f)=>{
        if (f.startsWith(file.base)) {
            debug("it starts with the right things");
            return f.slice(file.base.length + 1);
        }
        return __NOT_MATCHING__;
    };
    const dateAndIndex = (f, p)=>{
        const items = f.split(FILENAME_SEP);
        let indexStr = items[items.length - 1];
        debug("items: ", items, ", indexStr: ", indexStr);
        let dateStr = f;
        if (indexStr !== undefined && indexStr.match(/^\d+$/)) {
            dateStr = f.slice(0, -1 * (indexStr.length + 1));
            debug(`dateStr is ${dateStr}`);
            if (pattern && !dateStr) {
                dateStr = indexStr;
                indexStr = "0";
            }
        } else {
            indexStr = "0";
        }
        try {
            // Two arguments for new Date() are intentional. This will set other date
            // components to minimal values in the current timezone instead of UTC,
            // as new Date(0) will do.
            const date = format.parse(pattern, dateStr, new Date(0, 0));
            if (format.asString(pattern, date) !== dateStr) return f;
            p.index = parseInt(indexStr, 10);
            p.date = dateStr;
            p.timestamp = date.getTime();
            return "";
        } catch (e) {
            //not a valid date, don't panic.
            debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
            return f;
        }
    };
    const index = (f, p)=>{
        if (f.match(/^\d+$/)) {
            debug("it has an index");
            p.index = parseInt(f, 10);
            return "";
        }
        return f;
    };
    let parts = [
        zip,
        keepFileExt ? extAtEnd : extInMiddle,
        pattern ? dateAndIndex : index
    ];
    return (filename)=>{
        let result = {
            filename,
            index: 0,
            isCompressed: false
        };
        // pass the filename through each of the file part parsers
        let whatsLeftOver = parts.reduce((remains, part)=>part(remains, result), filename);
        // if there's anything left after parsing, then it wasn't a valid filename
        return whatsLeftOver ? null : result;
    };
};
}),
"[project]/node_modules/streamroller/lib/moveAndMaybeCompressFile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")('streamroller:moveAndMaybeCompressFile');
const fs = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/index.js [app-route] (ecmascript)");
const zlib = __turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)");
const _parseOption = function(rawOptions) {
    const defaultOptions = {
        mode: parseInt("0600", 8),
        compress: false
    };
    const options = Object.assign({}, defaultOptions, rawOptions);
    debug(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options)}`);
    return options;
};
const moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, options)=>{
    options = _parseOption(options);
    if (sourceFilePath === targetFilePath) {
        debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
        return;
    }
    if (await fs.pathExists(sourceFilePath)) {
        debug(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${options.compress ? "with" : "without"} compress`);
        if (options.compress) {
            await new Promise((resolve, reject)=>{
                let isCreated = false;
                // to avoid concurrency, the forked process which can create the file will proceed (using flags wx)
                const writeStream = fs.createWriteStream(targetFilePath, {
                    mode: options.mode,
                    flags: "wx"
                })// wait until writable stream is valid before proceeding to read
                .on("open", ()=>{
                    isCreated = true;
                    const readStream = fs.createReadStream(sourceFilePath)// wait until readable stream is valid before piping
                    .on("open", ()=>{
                        readStream.pipe(zlib.createGzip()).pipe(writeStream);
                    }).on("error", (e)=>{
                        debug(`moveAndMaybeCompressFile: error reading ${sourceFilePath}`, e);
                        // manually close writable: https://nodejs.org/api/stream.html#readablepipedestination-options
                        writeStream.destroy(e);
                    });
                }).on("finish", ()=>{
                    debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
                    // delete sourceFilePath
                    fs.unlink(sourceFilePath).then(resolve).catch((e)=>{
                        debug(`moveAndMaybeCompressFile: error deleting ${sourceFilePath}, truncating instead`, e);
                        // fallback to truncate
                        fs.truncate(sourceFilePath).then(resolve).catch((e)=>{
                            debug(`moveAndMaybeCompressFile: error truncating ${sourceFilePath}`, e);
                            reject(e);
                        });
                    });
                }).on("error", (e)=>{
                    if (!isCreated) {
                        debug(`moveAndMaybeCompressFile: error creating ${targetFilePath}`, e);
                        // do not do anything if handled by another forked process
                        reject(e);
                    } else {
                        debug(`moveAndMaybeCompressFile: error writing ${targetFilePath}, deleting`, e);
                        // delete targetFilePath (taking as nothing happened)
                        fs.unlink(targetFilePath).then(()=>{
                            reject(e);
                        }).catch((e)=>{
                            debug(`moveAndMaybeCompressFile: error deleting ${targetFilePath}`, e);
                            reject(e);
                        });
                    }
                });
            }).catch(()=>{});
        } else {
            debug(`moveAndMaybeCompressFile: renaming ${sourceFilePath} to ${targetFilePath}`);
            try {
                await fs.move(sourceFilePath, targetFilePath, {
                    overwrite: true
                });
            } catch (e) {
                debug(`moveAndMaybeCompressFile: error renaming ${sourceFilePath} to ${targetFilePath}`, e);
                /* istanbul ignore else: no need to do anything if file does not exist */ if (e.code !== "ENOENT") {
                    debug(`moveAndMaybeCompressFile: trying copy+truncate instead`);
                    try {
                        await fs.copy(sourceFilePath, targetFilePath, {
                            overwrite: true
                        });
                        await fs.truncate(sourceFilePath);
                    } catch (e) {
                        debug(`moveAndMaybeCompressFile: error copy+truncate`, e);
                    }
                }
            }
        }
    }
};
module.exports = moveAndMaybeCompressFile;
}),
"[project]/node_modules/streamroller/lib/RollingFileWriteStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("streamroller:RollingFileWriteStream");
const fs = __turbopack_context__.r("[project]/node_modules/fs-extra/lib/index.js [app-route] (ecmascript)");
const path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const newNow = __turbopack_context__.r("[project]/node_modules/streamroller/lib/now.js [app-route] (ecmascript)");
const format = __turbopack_context__.r("[project]/node_modules/date-format/lib/index.js [app-route] (ecmascript)");
const { Writable } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const fileNameFormatter = __turbopack_context__.r("[project]/node_modules/streamroller/lib/fileNameFormatter.js [app-route] (ecmascript)");
const fileNameParser = __turbopack_context__.r("[project]/node_modules/streamroller/lib/fileNameParser.js [app-route] (ecmascript)");
const moveAndMaybeCompressFile = __turbopack_context__.r("[project]/node_modules/streamroller/lib/moveAndMaybeCompressFile.js [app-route] (ecmascript)");
const deleteFiles = (fileNames)=>{
    debug(`deleteFiles: files to delete: ${fileNames}`);
    return Promise.all(fileNames.map((f)=>fs.unlink(f).catch((e)=>{
            debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
        })));
};
/**
 * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.
 * RollingFileWriteStream inherits from stream.Writable
 */ class RollingFileWriteStream extends Writable {
    /**
   * Create a RollingFileWriteStream
   * @constructor
   * @param {string} filePath - The file path to write.
   * @param {object} options - The extra options
   * @param {number} options.numToKeep - The max numbers of files to keep.
   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.
   *                                   This should be more than 1024. The default is 0.
   *                                   If not specified or 0, then no log rolling will happen.
   * @param {string} options.mode - The mode of the files. The default is '0600'. Refer to stream.writable for more.
   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.
   * @param {boolean} options.compress - Whether to compress backup files.
   * @param {boolean} options.keepFileExt - Whether to keep the file extension.
   * @param {string} options.pattern - The date string pattern in the file name.
   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.
   */ constructor(filePath, options){
        debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
        if (typeof filePath !== "string" || filePath.length === 0) {
            throw new Error(`Invalid filename: ${filePath}`);
        } else if (filePath.endsWith(path.sep)) {
            throw new Error(`Filename is a directory: ${filePath}`);
        } else if (filePath.indexOf(`~${path.sep}`) === 0) {
            // handle ~ expansion: https://github.com/nodejs/node/issues/684
            // exclude ~ and ~filename as these can be valid files
            filePath = filePath.replace("~", os.homedir());
        }
        super(options);
        this.options = this._parseOption(options);
        this.fileObject = path.parse(filePath);
        if (this.fileObject.dir === "") {
            this.fileObject = path.parse(path.join(process.cwd(), filePath));
        }
        this.fileFormatter = fileNameFormatter({
            file: this.fileObject,
            alwaysIncludeDate: this.options.alwaysIncludePattern,
            needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
            compress: this.options.compress,
            keepFileExt: this.options.keepFileExt,
            fileNameSep: this.options.fileNameSep
        });
        this.fileNameParser = fileNameParser({
            file: this.fileObject,
            keepFileExt: this.options.keepFileExt,
            pattern: this.options.pattern,
            fileNameSep: this.options.fileNameSep
        });
        this.state = {
            currentSize: 0
        };
        if (this.options.pattern) {
            this.state.currentDate = format(this.options.pattern, newNow());
        }
        this.filename = this.fileFormatter({
            index: 0,
            date: this.state.currentDate
        });
        if ([
            "a",
            "a+",
            "as",
            "as+"
        ].includes(this.options.flags)) {
            this._setExistingSizeAndDate();
        }
        debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
    }
    _setExistingSizeAndDate() {
        try {
            const stats = fs.statSync(this.filename);
            this.state.currentSize = stats.size;
            if (this.options.pattern) {
                this.state.currentDate = format(this.options.pattern, stats.mtime);
            }
        } catch (e) {
            //file does not exist, that's fine - move along
            return;
        }
    }
    _parseOption(rawOptions) {
        const defaultOptions = {
            maxSize: 0,
            numToKeep: Number.MAX_SAFE_INTEGER,
            encoding: "utf8",
            mode: parseInt("0600", 8),
            flags: "a",
            compress: false,
            keepFileExt: false,
            alwaysIncludePattern: false
        };
        const options = Object.assign({}, defaultOptions, rawOptions);
        if (!options.maxSize) {
            delete options.maxSize;
        } else if (options.maxSize <= 0) {
            throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);
        }
        // options.numBackups will supercede options.numToKeep
        if (options.numBackups || options.numBackups === 0) {
            if (options.numBackups < 0) {
                throw new Error(`options.numBackups (${options.numBackups}) should be >= 0`);
            } else if (options.numBackups >= Number.MAX_SAFE_INTEGER) {
                // to cater for numToKeep (include the hot file) at Number.MAX_SAFE_INTEGER
                throw new Error(`options.numBackups (${options.numBackups}) should be < Number.MAX_SAFE_INTEGER`);
            } else {
                options.numToKeep = options.numBackups + 1;
            }
        } else if (options.numToKeep <= 0) {
            throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);
        }
        debug(`_parseOption: creating stream with option=${JSON.stringify(options)}`);
        return options;
    }
    _final(callback) {
        this.currentFileStream.end("", this.options.encoding, callback);
    }
    _write(chunk, encoding, callback) {
        this._shouldRoll().then(()=>{
            debug(`_write: writing chunk. ` + `file=${this.currentFileStream.path} ` + `state=${JSON.stringify(this.state)} ` + `chunk=${chunk}`);
            this.currentFileStream.write(chunk, encoding, (e)=>{
                this.state.currentSize += chunk.length;
                callback(e);
            });
        });
    }
    async _shouldRoll() {
        if (this._dateChanged() || this._tooBig()) {
            debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
            await this._roll();
        }
    }
    _dateChanged() {
        return this.state.currentDate && this.state.currentDate !== format(this.options.pattern, newNow());
    }
    _tooBig() {
        return this.state.currentSize >= this.options.maxSize;
    }
    _roll() {
        debug(`_roll: closing the current stream`);
        return new Promise((resolve, reject)=>{
            this.currentFileStream.end("", this.options.encoding, ()=>{
                this._moveOldFiles().then(resolve).catch(reject);
            });
        });
    }
    async _moveOldFiles() {
        const files = await this._getExistingFiles();
        const todaysFiles = this.state.currentDate ? files.filter((f)=>f.date === this.state.currentDate) : files;
        for(let i = todaysFiles.length; i >= 0; i--){
            debug(`_moveOldFiles: i = ${i}`);
            const sourceFilePath = this.fileFormatter({
                date: this.state.currentDate,
                index: i
            });
            const targetFilePath = this.fileFormatter({
                date: this.state.currentDate,
                index: i + 1
            });
            const moveAndCompressOptions = {
                compress: this.options.compress && i === 0,
                mode: this.options.mode
            };
            await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, moveAndCompressOptions);
        }
        this.state.currentSize = 0;
        this.state.currentDate = this.state.currentDate ? format(this.options.pattern, newNow()) : null;
        debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
        // wait for the file to be open before cleaning up old ones,
        // otherwise the daysToKeep calculations can be off
        await new Promise((resolve, reject)=>{
            this.currentFileStream.write("", "utf8", ()=>{
                this._clean().then(resolve).catch(reject);
            });
        });
    }
    // Sorted from the oldest to the latest
    async _getExistingFiles() {
        const files = await fs.readdir(this.fileObject.dir).catch(/* istanbul ignore next: will not happen on windows */ ()=>[]);
        debug(`_getExistingFiles: files=${files}`);
        const existingFileDetails = files.map((n)=>this.fileNameParser(n)).filter((n)=>n);
        const getKey = (n)=>(n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
        existingFileDetails.sort((a, b)=>getKey(a) - getKey(b));
        return existingFileDetails;
    }
    _renewWriteStream() {
        const filePath = this.fileFormatter({
            date: this.state.currentDate,
            index: 0
        });
        // attempt to create the directory
        const mkdir = (dir)=>{
            try {
                return fs.mkdirSync(dir, {
                    recursive: true
                });
            } // backward-compatible fs.mkdirSync for nodejs pre-10.12.0 (without recursive option)
            catch (e) {
                // recursive creation of parent first
                if (e.code === "ENOENT") {
                    mkdir(path.dirname(dir));
                    return mkdir(dir);
                }
                // throw error for all except EEXIST and EROFS (read-only filesystem)
                if (e.code !== "EEXIST" && e.code !== "EROFS") {
                    throw e;
                } else {
                    try {
                        if (fs.statSync(dir).isDirectory()) {
                            return dir;
                        }
                        throw e;
                    } catch (err) {
                        throw e;
                    }
                }
            }
        };
        mkdir(this.fileObject.dir);
        const ops = {
            flags: this.options.flags,
            encoding: this.options.encoding,
            mode: this.options.mode
        };
        const renameKey = function(obj, oldKey, newKey) {
            obj[newKey] = obj[oldKey];
            delete obj[oldKey];
            return obj;
        };
        // try to throw EISDIR, EROFS, EACCES
        fs.appendFileSync(filePath, "", renameKey({
            ...ops
        }, "flags", "flag"));
        this.currentFileStream = fs.createWriteStream(filePath, ops);
        this.currentFileStream.on("error", (e)=>{
            this.emit("error", e);
        });
    }
    async _clean() {
        const existingFileDetails = await this._getExistingFiles();
        debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
        debug("_clean: existing files are: ", existingFileDetails);
        if (this._tooManyFiles(existingFileDetails.length)) {
            const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep).map((f)=>path.format({
                    dir: this.fileObject.dir,
                    base: f.filename
                }));
            await deleteFiles(fileNamesToRemove);
        }
    }
    _tooManyFiles(numFiles) {
        return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
    }
}
module.exports = RollingFileWriteStream;
}),
"[project]/node_modules/streamroller/lib/RollingFileStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const RollingFileWriteStream = __turbopack_context__.r("[project]/node_modules/streamroller/lib/RollingFileWriteStream.js [app-route] (ecmascript)");
// just to adapt the previous version
class RollingFileStream extends RollingFileWriteStream {
    constructor(filename, size, backups, options){
        if (!options) {
            options = {};
        }
        if (size) {
            options.maxSize = size;
        }
        if (!options.numBackups && options.numBackups !== 0) {
            if (!backups && backups !== 0) {
                backups = 1;
            }
            options.numBackups = backups;
        }
        super(filename, options);
        this.backups = options.numBackups;
        this.size = this.options.maxSize;
    }
    get theStream() {
        return this.currentFileStream;
    }
}
module.exports = RollingFileStream;
}),
"[project]/node_modules/streamroller/lib/DateRollingFileStream.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

const RollingFileWriteStream = __turbopack_context__.r("[project]/node_modules/streamroller/lib/RollingFileWriteStream.js [app-route] (ecmascript)");
// just to adapt the previous version
class DateRollingFileStream extends RollingFileWriteStream {
    constructor(filename, pattern, options){
        if (pattern && typeof pattern === 'object') {
            options = pattern;
            pattern = null;
        }
        if (!options) {
            options = {};
        }
        if (!pattern) {
            pattern = 'yyyy-MM-dd';
        }
        options.pattern = pattern;
        if (!options.numBackups && options.numBackups !== 0) {
            if (!options.daysToKeep && options.daysToKeep !== 0) {
                options.daysToKeep = 1;
            } else {
                process.emitWarning("options.daysToKeep is deprecated due to the confusion it causes when used " + "together with file size rolling. Please use options.numBackups instead.", "DeprecationWarning", "streamroller-DEP0001");
            }
            options.numBackups = options.daysToKeep;
        } else {
            options.daysToKeep = options.numBackups;
        }
        super(filename, options);
        this.mode = this.options.mode;
    }
    get theStream() {
        return this.currentFileStream;
    }
}
module.exports = DateRollingFileStream;
}),
"[project]/node_modules/streamroller/lib/index.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    RollingFileWriteStream: __turbopack_context__.r("[project]/node_modules/streamroller/lib/RollingFileWriteStream.js [app-route] (ecmascript)"),
    RollingFileStream: __turbopack_context__.r("[project]/node_modules/streamroller/lib/RollingFileStream.js [app-route] (ecmascript)"),
    DateRollingFileStream: __turbopack_context__.r("[project]/node_modules/streamroller/lib/DateRollingFileStream.js [app-route] (ecmascript)")
};
}),
];

//# sourceMappingURL=node_modules_80650fa9._.js.map