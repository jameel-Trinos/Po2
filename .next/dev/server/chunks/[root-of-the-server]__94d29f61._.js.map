{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/lib/pdfStorage.ts"],"sourcesContent":["/**\n * In-memory storage for PDF documents\n * Stores PDFs temporarily for conversion operations\n * \n * Note: This is a simple in-memory solution. For production,\n * consider using Redis, S3, or a database.\n */\n\ninterface StoredPDF {\n  buffer: Buffer;\n  fileName: string;\n  uploadedAt: Date;\n}\n\n// In-memory storage Map\nconst pdfStorage = new Map<string, StoredPDF>();\n\n// Cleanup interval (remove PDFs older than 24 hours)\nconst CLEANUP_INTERVAL = 60 * 60 * 1000; // 1 hour (check every hour)\nconst MAX_AGE = 24 * 60 * 60 * 1000; // 24 hours (keep PDFs for 24 hours)\n\n// Periodic cleanup\nif (typeof setInterval !== 'undefined') {\n  setInterval(() => {\n    const now = new Date();\n    for (const [id, pdf] of pdfStorage.entries()) {\n      const age = now.getTime() - pdf.uploadedAt.getTime();\n      if (age > MAX_AGE) {\n        console.log(`üóëÔ∏è  Cleaning up old PDF: ${id} (${pdf.fileName})`);\n        pdfStorage.delete(id);\n      }\n    }\n  }, CLEANUP_INTERVAL);\n}\n\n/**\n * Store a PDF in memory\n */\nexport function storePDF(documentId: string, buffer: Buffer, fileName: string): void {\n  console.log(`üíæ Storing PDF: ${documentId} (${fileName}, ${buffer.length} bytes)`);\n  pdfStorage.set(documentId, {\n    buffer,\n    fileName,\n    uploadedAt: new Date(),\n  });\n}\n\n/**\n * Retrieve a stored PDF\n */\nexport function getPDF(documentId: string): { buffer: Buffer; fileName: string } | null {\n  const stored = pdfStorage.get(documentId);\n  if (!stored) {\n    console.log(`‚ùå PDF not found: ${documentId}`);\n    return null;\n  }\n  console.log(`‚úÖ Retrieved PDF: ${documentId} (${stored.fileName}, ${stored.buffer.length} bytes)`);\n  return {\n    buffer: stored.buffer,\n    fileName: stored.fileName,\n  };\n}\n\n/**\n * Delete a stored PDF\n */\nexport function deletePDF(documentId: string): boolean {\n  const deleted = pdfStorage.delete(documentId);\n  if (deleted) {\n    console.log(`üóëÔ∏è  Deleted PDF: ${documentId}`);\n  }\n  return deleted;\n}\n\n/**\n * Get storage statistics\n */\nexport function getStorageStats(): { count: number; totalSize: number } {\n  let totalSize = 0;\n  for (const pdf of pdfStorage.values()) {\n    totalSize += pdf.buffer.length;\n  }\n  return {\n    count: pdfStorage.size,\n    totalSize,\n  };\n}\n\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;;AAQD,wBAAwB;AACxB,MAAM,aAAa,IAAI;AAEvB,qDAAqD;AACrD,MAAM,mBAAmB,KAAK,KAAK,MAAM,4BAA4B;AACrE,MAAM,UAAU,KAAK,KAAK,KAAK,MAAM,oCAAoC;AAEzE,mBAAmB;AACnB,IAAI,OAAO,gBAAgB,aAAa;IACtC,YAAY;QACV,MAAM,MAAM,IAAI;QAChB,KAAK,MAAM,CAAC,IAAI,IAAI,IAAI,WAAW,OAAO,GAAI;YAC5C,MAAM,MAAM,IAAI,OAAO,KAAK,IAAI,UAAU,CAAC,OAAO;YAClD,IAAI,MAAM,SAAS;gBACjB,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,GAAG,EAAE,EAAE,IAAI,QAAQ,CAAC,CAAC,CAAC;gBAC/D,WAAW,MAAM,CAAC;YACpB;QACF;IACF,GAAG;AACL;AAKO,SAAS,SAAS,UAAkB,EAAE,MAAc,EAAE,QAAgB;IAC3E,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,WAAW,EAAE,EAAE,SAAS,EAAE,EAAE,OAAO,MAAM,CAAC,OAAO,CAAC;IACjF,WAAW,GAAG,CAAC,YAAY;QACzB;QACA;QACA,YAAY,IAAI;IAClB;AACF;AAKO,SAAS,OAAO,UAAkB;IACvC,MAAM,SAAS,WAAW,GAAG,CAAC;IAC9B,IAAI,CAAC,QAAQ;QACX,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,YAAY;QAC5C,OAAO;IACT;IACA,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,WAAW,EAAE,EAAE,OAAO,QAAQ,CAAC,EAAE,EAAE,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC;IAChG,OAAO;QACL,QAAQ,OAAO,MAAM;QACrB,UAAU,OAAO,QAAQ;IAC3B;AACF;AAKO,SAAS,UAAU,UAAkB;IAC1C,MAAM,UAAU,WAAW,MAAM,CAAC;IAClC,IAAI,SAAS;QACX,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,YAAY;IAC/C;IACA,OAAO;AACT;AAKO,SAAS;IACd,IAAI,YAAY;IAChB,KAAK,MAAM,OAAO,WAAW,MAAM,GAAI;QACrC,aAAa,IAAI,MAAM,CAAC,MAAM;IAChC;IACA,OAAO;QACL,OAAO,WAAW,IAAI;QACtB;IACF;AACF","debugId":null}},
    {"offset": {"line": 127, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/app/api/convert/pdf-to-docx/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { Readable } from 'stream';\nimport { getPDF } from '@/lib/pdfStorage';\n\nexport const runtime = 'nodejs';\nexport const maxDuration = 60; // 60 seconds max for conversion\n\n/**\n * Fallback conversion using open-source libraries\n * This is used if Adobe PDF Services fails\n */\nasync function fallbackPdfToDocx(pdfBuffer: Buffer): Promise<Buffer> {\n  console.log('üîÑ Using fallback conversion method (pdf-lib + docx)...');\n  \n  try {\n    // Import required libraries dynamically\n    const pdfjsLib = await import('pdfjs-dist/legacy/build/pdf.mjs');\n    const { Document, Paragraph, TextRun, HeadingLevel } = await import('docx');\n    const { Packer } = await import('docx');\n    \n    console.log('‚úÖ Fallback libraries loaded');\n    \n    // Parse PDF (worker is not needed in Node.js environment)\n    // In Node.js, pdfjs-dist works synchronously without a worker\n    const loadingTask = pdfjsLib.getDocument({\n      data: pdfBuffer,\n      // Disable worker for Node.js environment\n      useWorkerFetch: false,\n      isEvalSupported: false,\n      useSystemFonts: true\n    });\n    const pdfDoc = await loadingTask.promise;\n    const numPages = pdfDoc.numPages;\n    \n    console.log(`üìÑ PDF has ${numPages} pages, extracting text...`);\n    \n    // Extract text from all pages\n    const paragraphs: any[] = [];\n    \n    for (let pageNum = 1; pageNum <= numPages; pageNum++) {\n      const page = await pdfDoc.getPage(pageNum);\n      const textContent = await page.getTextContent();\n      \n      // Group text items by their Y position (lines)\n      const lines = new Map<number, string[]>();\n      \n      for (const item of textContent.items as any[]) {\n        if ('str' in item && item.str.trim()) {\n          const y = Math.round(item.transform[5]); // Y position\n          if (!lines.has(y)) {\n            lines.set(y, []);\n          }\n          lines.get(y)!.push(item.str);\n        }\n      }\n      \n      // Convert lines to paragraphs, sorted by Y position (top to bottom)\n      const sortedLines = Array.from(lines.entries()).sort((a, b) => b[0] - a[0]);\n      \n      for (const [_, textParts] of sortedLines) {\n        const lineText = textParts.join(' ').trim();\n        if (lineText) {\n          // Simple heuristic to detect headings (short lines with capital letters)\n          const isHeading = lineText.length < 50 && \n                           lineText === lineText.toUpperCase() &&\n                           !lineText.match(/^\\d+/);\n          \n          paragraphs.push(\n            new Paragraph({\n              children: [new TextRun(lineText)],\n              ...(isHeading ? { heading: HeadingLevel.HEADING_2 } : {}),\n              spacing: { after: 200 }\n            })\n          );\n        }\n      }\n      \n      // Add page break (except for last page)\n      if (pageNum < numPages) {\n        paragraphs.push(\n          new Paragraph({\n            children: [new TextRun('')],\n            pageBreakBefore: true\n          })\n        );\n      }\n    }\n    \n    console.log(`‚úÖ Extracted ${paragraphs.length} paragraphs`);\n    \n    // Create DOCX document\n    const doc = new Document({\n      sections: [{\n        properties: {},\n        children: paragraphs\n      }]\n    });\n    \n    // Generate buffer\n    const docxBuffer = await Packer.toBuffer(doc);\n    console.log(`‚úÖ Fallback conversion successful, DOCX size: ${docxBuffer.length} bytes`);\n    \n    return Buffer.from(docxBuffer);\n    \n  } catch (fallbackError) {\n    console.error('‚ùå Fallback conversion also failed:', fallbackError);\n    throw new Error(`Fallback conversion failed: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`);\n  }\n}\n\n/**\n * Convert PDF to DOCX using Adobe PDF Services API\n * Accepts either a file upload or a document ID to fetch from storage\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Validate Adobe credentials\n    const clientId = process.env.ADOBE_PDFSERVICES_CLIENT_ID;\n    const clientSecret = process.env.ADOBE_PDFSERVICES_CLIENT_SECRET;\n\n    if (!clientId || !clientSecret) {\n      console.error('‚ùå Adobe PDF Services credentials not configured');\n      return NextResponse.json(\n        {\n          error: 'Configuration Error',\n          message: 'Adobe PDF Services credentials are not configured',\n          details: 'Please ensure ADOBE_PDFSERVICES_CLIENT_ID and ADOBE_PDFSERVICES_CLIENT_SECRET are set in your environment variables'\n        },\n        { status: 500 }\n      );\n    }\n\n    console.log('‚úÖ Adobe credentials found');\n\n    // Validate request\n    const contentType = request.headers.get('content-type');\n    console.log('üì• Incoming request content-type:', contentType);\n    \n    let file: File | null = null;\n    let fileName = 'document.pdf';\n    \n    // Check if it's JSON (document ID-based) or multipart (file upload)\n    if (contentType?.includes('application/json')) {\n      console.log('üìã Parsing JSON body...');\n      const body = await request.json();\n      const documentId = body.documentId as string | undefined;\n      \n      if (documentId) {\n        console.log('üì• Processing PDF from storage (documentId:', documentId, ')...');\n        \n        // Retrieve PDF from storage\n        const storedPdf = getPDF(documentId);\n        if (!storedPdf) {\n          return NextResponse.json(\n            { \n              error: 'PDF not found',\n              message: `No PDF found for document ID: ${documentId}. The PDF may have expired or been deleted.`,\n              details: 'PDFs are stored temporarily (24 hours). Please re-upload the document.'\n            },\n            { status: 404 }\n          );\n        }\n        \n        // Convert buffer to File\n        fileName = storedPdf.fileName;\n        file = new File([new Uint8Array(storedPdf.buffer)], fileName, { type: 'application/pdf' });\n        console.log('‚úÖ Retrieved PDF from storage:', fileName, '(', storedPdf.buffer.length, 'bytes)');\n      } else {\n        return NextResponse.json(\n          { \n            error: 'No PDF source provided',\n            message: 'Please provide a documentId in the request body'\n          },\n          { status: 400 }\n        );\n      }\n    } else if (contentType?.includes('multipart/form-data')) {\n      console.log('üìã Parsing form data (file upload)...');\n      const formData = await request.formData();\n      file = formData.get('file') as File;\n\n      // Log all form data entries for debugging\n      console.log('üìã Form data entries:');\n      for (const [key, value] of formData.entries()) {\n        if (value instanceof File) {\n          console.log(`  - ${key}: File(name=\"${value.name}\", type=\"${value.type}\", size=${value.size})`);\n        } else {\n          console.log(`  - ${key}:`, value);\n        }\n      }\n    } else {\n      console.warn('‚ö†Ô∏è Unexpected content type:', contentType);\n      return NextResponse.json(\n        { \n          error: 'Invalid content type',\n          message: 'Request must be either application/json (with documentId) or multipart/form-data (with file)'\n        },\n        { status: 400 }\n      );\n    }\n\n    if (!file) {\n      console.error('‚ùå No file provided');\n      return NextResponse.json(\n        { \n          error: 'No file provided',\n          message: 'Please ensure a file is included in the request or a valid documentId is provided'\n        },\n        { \n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    console.log('‚úÖ Processing file:', {\n      name: file.name,\n      type: file.type,\n      size: file.size\n    });\n\n    // Check if it's a PDF\n    const hasValidExtension = file.name.toLowerCase().endsWith('.pdf');\n    const hasValidMimeType = file.type === 'application/pdf';\n    \n    console.log('üîç File validation:');\n    console.log('  - Has .pdf extension:', hasValidExtension);\n    console.log('  - Has PDF MIME type:', hasValidMimeType);\n    console.log('  - File type:', file.type || '(empty)');\n    \n    if (!hasValidExtension && !hasValidMimeType) {\n      console.error('‚ùå Invalid file type:', file.type, 'for file:', file.name);\n      return NextResponse.json(\n        { \n          error: 'File must be a PDF',\n          message: `Received file type: ${file.type || 'unknown'}`,\n          details: `File name: ${file.name}. Expected .pdf extension and/or application/pdf MIME type.`\n        },\n        { \n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    // Check file size (optional validation)\n    if (file.size === 0) {\n      console.error('‚ùå Empty file provided');\n      return NextResponse.json(\n        { \n          error: 'Empty file provided',\n          message: 'The PDF file appears to be empty (0 bytes)',\n          details: `File name: ${file.name}, Size: ${file.size} bytes`\n        },\n        { \n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n    \n    console.log('‚úÖ File validation passed');\n\n    // Read PDF file as buffer\n    console.log('üìÑ Reading PDF file...');\n    let pdfBuffer: Buffer;\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      pdfBuffer = Buffer.from(arrayBuffer);\n      console.log('‚úÖ PDF file read, size:', pdfBuffer.length, 'bytes');\n    } catch (readError) {\n      console.error('‚ùå Failed to read PDF file:', readError);\n      const readErrorMessage = readError instanceof Error ? readError.message : 'Unknown error';\n      return NextResponse.json(\n        {\n          error: 'Failed to read PDF file',\n          message: readErrorMessage,\n          details: 'The PDF file could not be read from the request.'\n        },\n        {\n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    // Convert PDF to DOCX using Adobe PDF Services\n    console.log('üîÑ Converting PDF to DOCX using Adobe PDF Services...');\n    let docxBuffer: Buffer;\n    \n    try {\n      // Dynamically import Adobe SDK (ensures it's only loaded on server)\n      const { \n        ServicePrincipalCredentials, \n        PDFServices, \n        MimeType, \n        ExportPDFJob, \n        ExportPDFResult,\n        ExportPDFParams,\n        ExportPDFTargetFormat,\n        ClientConfig \n      } = await import('@adobe/pdfservices-node-sdk');\n      \n      console.log('‚úÖ Adobe SDK loaded');\n      \n      // Create credentials from environment variables (SDK v4.x)\n      const credentials = new ServicePrincipalCredentials({\n        clientId: clientId,\n        clientSecret: clientSecret\n      });\n      \n      console.log('‚úÖ Credentials created');\n\n      // Configure client with increased timeout (60 seconds = 60000ms)\n      // ClientConfig directly accepts timeout in constructor\n      const clientConfig = new ClientConfig({\n        timeout: 60000  // 60 seconds timeout for all operations\n      });\n      \n      console.log('‚úÖ Client config created with 60s timeout');\n\n      // Initialize PDF Services with custom timeout configuration\n      const pdfServices = new PDFServices({ credentials, clientConfig });\n      console.log('‚úÖ PDF Services initialized with extended timeout');\n\n      // Retry logic with exponential backoff\n      const maxRetries = 3;\n      let lastError: Error | null = null;\n      \n      for (let attempt = 1; attempt <= maxRetries; attempt++) {\n        try {\n          console.log(`üîÑ Conversion attempt ${attempt}/${maxRetries}...`);\n          \n          // Create a read stream from the buffer\n          const readStream = Readable.from(pdfBuffer);\n          \n          // Upload PDF as asset\n          console.log('üì§ Uploading PDF to Adobe...');\n          const inputAsset = await pdfServices.upload({\n            readStream,\n            mimeType: MimeType.PDF\n          });\n          console.log('‚úÖ PDF uploaded as asset');\n\n          // Create export parameters for DOCX format\n          const params = new ExportPDFParams({\n            targetFormat: ExportPDFTargetFormat.DOCX\n          });\n          \n          // Create export job to convert PDF to DOCX\n          const job = new ExportPDFJob({ inputAsset, params });\n          console.log('‚úÖ Export job created for DOCX conversion');\n\n          // Submit job and poll until complete\n          console.log('‚è≥ Submitting conversion job...');\n          const pollingURL = await pdfServices.submit({ job });\n          console.log('‚úÖ Job submitted, polling for result...');\n          \n          const pdfServicesResponse = await pdfServices.getJobResult({\n            pollingURL,\n            resultType: ExportPDFResult\n          });\n          console.log('‚úÖ Job completed');\n\n          // Get result asset\n          const resultAsset = pdfServicesResponse.result.asset;\n          const streamAsset = await pdfServices.getContent({ asset: resultAsset });\n          \n          // Read the stream into a buffer\n          console.log('üì• Downloading DOCX result...');\n          const chunks: Buffer[] = [];\n          for await (const chunk of streamAsset.readStream) {\n            chunks.push(Buffer.from(chunk));\n          }\n          docxBuffer = Buffer.concat(chunks);\n          \n          console.log('‚úÖ Conversion successful, DOCX size:', docxBuffer.length, 'bytes');\n          \n          if (!docxBuffer || docxBuffer.length === 0) {\n            throw new Error('Conversion produced an empty file');\n          }\n          \n          // Success - break out of retry loop\n          break;\n          \n        } catch (retryError) {\n          lastError = retryError instanceof Error ? retryError : new Error(String(retryError));\n          const isNetworkError = lastError.message.includes('timeout') || \n                                 lastError.message.includes('network') ||\n                                 lastError.message.includes('ECONNRESET') ||\n                                 lastError.message.includes('ETIMEDOUT');\n          \n          if (attempt < maxRetries && isNetworkError) {\n            const waitTime = Math.pow(2, attempt) * 1000; // Exponential backoff: 2s, 4s, 8s\n            console.warn(`‚ö†Ô∏è Attempt ${attempt} failed (${lastError.message}), retrying in ${waitTime}ms...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            // Last attempt failed or non-retryable error\n            throw lastError;\n          }\n        }\n      }\n    } catch (conversionError) {\n      console.error('‚ùå Adobe PDF Services conversion failed:', conversionError);\n      const conversionErrorMessage = conversionError instanceof Error ? conversionError.message : 'Unknown error';\n      const conversionErrorStack = conversionError instanceof Error ? conversionError.stack : undefined;\n      \n      console.error('Conversion error details:', {\n        message: conversionErrorMessage,\n        stack: conversionErrorStack,\n        errorType: conversionError instanceof Error ? conversionError.constructor.name : typeof conversionError\n      });\n      \n      // Try fallback conversion method\n      console.warn('‚ö†Ô∏è Attempting fallback conversion method...');\n      try {\n        docxBuffer = await fallbackPdfToDocx(pdfBuffer);\n        console.log('‚úÖ Fallback conversion succeeded!');\n        // Continue to the return statement below\n      } catch (fallbackError) {\n        console.error('‚ùå Fallback conversion also failed:', fallbackError);\n        \n        // Both methods failed - return detailed error\n        let detailedMessage = 'PDF to DOCX conversion failed using both Adobe services and fallback method. ';\n        if (conversionErrorMessage.includes('credentials')) {\n          detailedMessage += 'Please check your Adobe API credentials are correct.';\n        } else if (conversionErrorMessage.includes('quota') || conversionErrorMessage.includes('limit')) {\n          detailedMessage += 'API quota may have been exceeded. Check your Adobe account.';\n        } else if (conversionErrorMessage.includes('network') || conversionErrorMessage.includes('timeout')) {\n          detailedMessage += 'Network error occurred. This is often temporary - please try again.';\n        } else {\n          detailedMessage += 'The PDF file may be corrupted, encrypted, or in an unsupported format.';\n        }\n        \n        return NextResponse.json(\n          {\n            error: 'Failed to convert PDF to DOCX',\n            message: conversionErrorMessage,\n            details: detailedMessage,\n            fallbackError: fallbackError instanceof Error ? fallbackError.message : String(fallbackError),\n            ...(process.env.NODE_ENV === 'development' && conversionErrorStack ? { stack: conversionErrorStack } : {})\n          },\n          {\n            status: 500,\n            headers: {\n              'Content-Type': 'application/json',\n            }\n          }\n        );\n      }\n    }\n\n    // Return DOCX file\n    const outputFileName = file.name.replace(/\\.pdf$/i, '.docx');\n    console.log('üì§ Sending DOCX file:', outputFileName);\n    \n    return new NextResponse(docxBuffer, {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        'Content-Disposition': `attachment; filename=\"${outputFileName}\"`,\n      },\n    });\n  } catch (error) {\n    console.error('‚ùå PDF to DOCX conversion error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    const errorStack = error instanceof Error ? error.stack : undefined;\n    const errorName = error instanceof Error ? error.name : 'Error';\n    \n    // Log full error details for debugging\n    console.error('Error name:', errorName);\n    console.error('Error message:', errorMessage);\n    if (errorStack) {\n      console.error('Error stack:', errorStack);\n    }\n    \n    // Ensure we always return a valid JSON error response\n    const errorResponse = {\n      error: 'Failed to convert PDF to DOCX',\n      message: errorMessage,\n      ...(process.env.NODE_ENV === 'development' && {\n        details: errorMessage,\n        name: errorName,\n        ...(errorStack ? { stack: errorStack } : {})\n      })\n    };\n    \n    console.error('Returning error response:', JSON.stringify(errorResponse, null, 2));\n    \n    return NextResponse.json(\n      errorResponse,\n      { \n        status: 500,\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}