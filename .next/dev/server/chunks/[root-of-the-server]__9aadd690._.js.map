{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"info\", \"warn\", \"error\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;QAAQ;KAAQ,GAAG;AACrF;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/lib/db-helpers.ts"],"sourcesContent":["import { prisma } from \"./db\";\nimport type { Prisma } from \"@prisma/client\";\n\n/**\n * Save an uploaded document to the database\n * @param userId - Clerk user ID (string)\n * @param originalName - Original filename\n * @param fileType - File type (e.g., \"pdf\", \"docx\")\n * @param storageUrl - URL or path where the file is stored\n * @returns The created document\n */\nexport async function saveUploadedDocument(\n  userId: string,\n  originalName: string,\n  fileType: string,\n  storageUrl: string\n) {\n  try {\n    const document = await prisma.document.create({\n      data: {\n        userId,\n        originalName,\n        fileType,\n        storageUrl,\n      },\n    });\n    return document;\n  } catch (error) {\n    console.error(\"Error saving document:\", error);\n    throw new Error(\"Failed to save document to database\");\n  }\n}\n\n/**\n * Save AI-generated suggestions for a document\n * @param documentId - Document ID\n * @param suggestions - Array of suggestion objects\n * @returns Array of created suggestions\n */\nexport async function saveAISuggestions(\n  documentId: string,\n  suggestions: Array<{\n    category: string;\n    issue: string;\n    severity: string;\n    startIndex?: number | null;\n    endIndex?: number | null;\n    suggestedFix?: string | null;\n  }>\n) {\n  try {\n    // Delete existing suggestions for this document (optional - you might want to keep them)\n    // await prisma.suggestion.deleteMany({ where: { documentId } });\n\n    // Create new suggestions\n    const createdSuggestions = await prisma.suggestion.createMany({\n      data: suggestions.map((s) => ({\n        documentId,\n        category: s.category,\n        issue: s.issue,\n        severity: s.severity,\n        startIndex: s.startIndex ?? null,\n        endIndex: s.endIndex ?? null,\n        suggestedFix: s.suggestedFix ?? null,\n      })),\n      skipDuplicates: true,\n    });\n\n    // Fetch and return the created suggestions\n    const savedSuggestions = await prisma.suggestion.findMany({\n      where: { documentId },\n      orderBy: { id: \"asc\" },\n    });\n\n    return savedSuggestions;\n  } catch (error) {\n    console.error(\"Error saving suggestions:\", error);\n    throw new Error(\"Failed to save suggestions to database\");\n  }\n}\n\n/**\n * Get a document with all its suggestions\n * @param documentId - Document ID\n * @param userId - Optional user ID for security check\n * @returns Document with suggestions, or null if not found\n */\nexport async function getDocumentWithSuggestions(\n  documentId: string,\n  userId?: string\n) {\n  try {\n    const where: Prisma.DocumentWhereInput = { id: documentId };\n    if (userId) {\n      where.userId = userId;\n    }\n\n    const document = await prisma.document.findFirst({\n      where,\n      include: {\n        suggestions: {\n          orderBy: [\n            { severity: \"asc\" }, // Critical first\n            { category: \"asc\" },\n          ],\n        },\n      },\n    });\n\n    return document;\n  } catch (error) {\n    console.error(\"Error fetching document:\", error);\n    throw new Error(\"Failed to fetch document from database\");\n  }\n}\n\n/**\n * Get all documents for a user\n * @param userId - Clerk user ID\n * @returns Array of documents with suggestion counts\n */\nexport async function getUserDocuments(userId: string) {\n  try {\n    const documents = await prisma.document.findMany({\n      where: { userId },\n      include: {\n        _count: {\n          select: { suggestions: true },\n        },\n      },\n      orderBy: { createdAt: \"desc\" },\n    });\n\n    return documents;\n  } catch (error) {\n    console.error(\"Error fetching user documents:\", error);\n    \n    // Provide more specific error messages\n    if (error instanceof Error) {\n      // Check for common Prisma errors\n      if (error.message.includes('P1001') || error.message.includes('Can\\'t reach database server')) {\n        throw new Error(\"Database connection failed. Please check your DATABASE_URL environment variable.\");\n      }\n      if (error.message.includes('P2002')) {\n        throw new Error(\"Database constraint violation\");\n      }\n      if (error.message.includes('P2025')) {\n        throw new Error(\"Record not found\");\n      }\n      // Re-throw with original message for other errors\n      throw new Error(`Failed to fetch user documents: ${error.message}`);\n    }\n    \n    throw new Error(\"Failed to fetch user documents: Unknown error\");\n  }\n}\n\n/**\n * Update a document\n * @param documentId - Document ID\n * @param userId - User ID for security check\n * @param data - Partial document data to update\n * @returns Updated document\n */\nexport async function updateDocument(\n  documentId: string,\n  userId: string,\n  data: Partial<{\n    originalName: string;\n    fileType: string;\n    storageUrl: string;\n  }>\n) {\n  try {\n    const document = await prisma.document.updateMany({\n      where: {\n        id: documentId,\n        userId, // Ensure user owns the document\n      },\n      data,\n    });\n\n    if (document.count === 0) {\n      throw new Error(\"Document not found or access denied\");\n    }\n\n    return await prisma.document.findUnique({\n      where: { id: documentId },\n    });\n  } catch (error) {\n    console.error(\"Error updating document:\", error);\n    throw new Error(\"Failed to update document\");\n  }\n}\n\n/**\n * Delete a document and its suggestions (cascade)\n * @param documentId - Document ID\n * @param userId - User ID for security check\n */\nexport async function deleteDocument(documentId: string, userId: string) {\n  try {\n    const result = await prisma.document.deleteMany({\n      where: {\n        id: documentId,\n        userId, // Ensure user owns the document\n      },\n    });\n\n    if (result.count === 0) {\n      throw new Error(\"Document not found or access denied\");\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting document:\", error);\n    throw new Error(\"Failed to delete document\");\n  }\n}\n\n/**\n * Update a suggestion\n * @param suggestionId - Suggestion ID\n * @param data - Partial suggestion data to update\n * @param documentId - Optional document ID to verify the suggestion belongs to the document\n * @returns Updated suggestion\n */\nexport async function updateSuggestion(\n  suggestionId: string,\n  data: Partial<{\n    category: string;\n    issue: string;\n    severity: string;\n    startIndex: number | null;\n    endIndex: number | null;\n    suggestedFix: string | null;\n  }>,\n  documentId?: string\n) {\n  try {\n    // First, check if the suggestion exists\n    const existingSuggestion = await prisma.suggestion.findUnique({\n      where: { id: suggestionId },\n    });\n\n    if (!existingSuggestion) {\n      throw new Error(`Suggestion with ID ${suggestionId} not found`);\n    }\n\n    // If documentId is provided, verify the suggestion belongs to that document\n    if (documentId && existingSuggestion.documentId !== documentId) {\n      throw new Error(\"Suggestion does not belong to the specified document\");\n    }\n\n    // Update the suggestion\n    const suggestion = await prisma.suggestion.update({\n      where: { id: suggestionId },\n      data,\n    });\n\n    return suggestion;\n  } catch (error) {\n    console.error(\"Error updating suggestion:\", error);\n    \n    // Handle Prisma P2025 error (record not found)\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'P2025') {\n      throw new Error(`Suggestion with ID ${suggestionId} not found`);\n    }\n    \n    // Re-throw if it's already our custom error\n    if (error instanceof Error) {\n      throw error;\n    }\n    \n    throw new Error(\"Failed to update suggestion\");\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/app/api/compliance/apply-change/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { auth } from '@clerk/nextjs/server';\nimport { PDFDocument } from 'pdf-lib';\nimport mammoth from 'mammoth';\nimport { Document, Packer, Paragraph, TextRun } from 'docx';\nimport { JSDOM } from 'jsdom';\nimport { updateSuggestion, getDocumentWithSuggestions } from '@/lib/db-helpers';\n\n// Force Node.js runtime\nexport const runtime = 'nodejs';\n\n// Helper function to load pdfjs dynamically\nasync function loadPdfJs() {\n  const pdfjs = await import('pdfjs-dist');\n  // Set worker source if not already set\n  if (typeof globalThis !== 'undefined' && !pdfjs.GlobalWorkerOptions.workerSrc) {\n    pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`;\n  }\n  return pdfjs;\n}\n\n/**\n * Extract text from PDF using pdfjs-dist\n */\nasync function extractTextFromPdf(buffer: Buffer): Promise<string> {\n  const pdfjs = await loadPdfJs();\n  const pdf = await pdfjs.getDocument({ data: buffer }).promise;\n  \n  let fullText = '';\n  \n  // Extract text from each page\n  for (let i = 1; i <= pdf.numPages; i++) {\n    const page = await pdf.getPage(i);\n    const textContent = await page.getTextContent();\n    \n    // Combine text items with proper spacing\n    const pageText = textContent.items\n      .map((item: any) => {\n        if ('str' in item) {\n          return item.str;\n        }\n        return '';\n      })\n      .join(' ');\n    \n    fullText += pageText + '\\n\\n';\n  }\n  \n  return fullText.trim();\n}\n\n/**\n * Apply text replacement in PDF using PDF→DOCX→PDF workflow\n * This is the recommended approach for complex text modifications\n */\nasync function applyChangeToPdf(\n  pdfBuffer: Buffer,\n  originalText: string,\n  suggestedText: string\n): Promise<Buffer> {\n  try {\n    // Step 1: Extract text from PDF\n    let modifiedText = await extractTextFromPdf(pdfBuffer);\n    \n    // Step 2: Apply text replacement\n    const regex = new RegExp(originalText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi');\n    modifiedText = modifiedText.replace(regex, suggestedText);\n    \n    // Step 3: Convert to DOCX format\n    const paragraphs = modifiedText\n      .split('\\n\\n')\n      .filter((p: string) => p.trim())\n      .map((p: string) => new Paragraph({\n        children: [new TextRun(p.trim())],\n      }));\n    \n    const doc = new Document({\n      sections: [{\n        properties: {},\n        children: paragraphs.length > 0 ? paragraphs : [\n          new Paragraph({ children: [new TextRun('')] })\n        ],\n      }],\n    });\n    \n    // Step 4: Generate DOCX buffer\n    const docxBuffer = await Packer.toBuffer(doc);\n    \n    // Note: In a production environment, you would convert DOCX back to PDF\n    // using a service like LibreOffice, Gotenberg, or a cloud API\n    // For now, we return the modified text as a simple PDF\n    \n    // Step 5: Create a new PDF with modified text\n    const newPdfDoc = await PDFDocument.create();\n    const page = newPdfDoc.addPage([595, 842]); // A4 size\n    const { height } = page.getSize();\n    const fontSize = 12;\n    const margin = 50;\n    let yPosition = height - margin;\n    \n    // Split text into lines and add to PDF\n    const lines = modifiedText.split('\\n');\n    for (const line of lines) {\n      if (yPosition < margin) {\n        // Add new page if needed\n        const newPage = newPdfDoc.addPage([595, 842]);\n        yPosition = newPage.getSize().height - margin;\n      }\n      \n      page.drawText(line.slice(0, 80), { // Limit line length\n        x: margin,\n        y: yPosition,\n        size: fontSize,\n      });\n      \n      yPosition -= fontSize + 4;\n    }\n    \n    const pdfBytes = await newPdfDoc.save();\n    return Buffer.from(pdfBytes);\n  } catch (error) {\n    console.error('Error applying change to PDF:', error);\n    throw new Error('Failed to apply change to PDF');\n  }\n}\n\n/**\n * Apply text replacement in DOCX\n */\nasync function applyChangeToDocx(\n  docxBuffer: Buffer,\n  originalText: string,\n  suggestedText: string\n): Promise<Buffer> {\n  try {\n    // Extract HTML from DOCX\n    const result = await mammoth.convertToHtml({ buffer: docxBuffer });\n    let htmlContent = result.value;\n    \n    // Apply text replacement\n    const regex = new RegExp(originalText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi');\n    htmlContent = htmlContent.replace(regex, suggestedText);\n    \n    // Convert back to DOCX\n    // Parse HTML and create DOCX structure using JSDOM\n    const dom = new JSDOM(htmlContent);\n    const textContent = dom.window.document.body.textContent || '';\n    \n    const paragraphs = textContent\n      .split('\\n')\n      .filter(p => p.trim())\n      .map(p => new Paragraph({\n        children: [new TextRun(p.trim())],\n      }));\n    \n    const wordDoc = new Document({\n      sections: [{\n        properties: {},\n        children: paragraphs.length > 0 ? paragraphs : [\n          new Paragraph({ children: [new TextRun('')] })\n        ],\n      }],\n    });\n    \n    const buffer = await Packer.toBuffer(wordDoc);\n    return Buffer.from(buffer);\n  } catch (error) {\n    console.error('Error applying change to DOCX:', error);\n    throw new Error('Failed to apply change to DOCX');\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Get authenticated user\n    const { userId } = await auth();\n    \n    if (!userId) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      );\n    }\n\n    const body = await request.json();\n    const { \n      documentId, \n      originalText, \n      suggestedText, \n      suggestionId,\n      fileType, // 'pdf' or 'docx'\n      documentData, // Base64 encoded document data (optional)\n    } = body;\n\n    // Validate input\n    if (!documentId || !originalText || !suggestedText) {\n      return NextResponse.json(\n        { error: 'Missing required fields: documentId, originalText, suggestedText' },\n        { status: 400 }\n      );\n    }\n\n    // Verify user owns the document\n    const document = await getDocumentWithSuggestions(documentId, userId);\n    if (!document) {\n      return NextResponse.json(\n        { error: 'Document not found or access denied' },\n        { status: 404 }\n      );\n    }\n\n    let modifiedDocumentUrl: string | undefined;\n\n    // If document data is provided, apply the change\n    if (documentData && fileType) {\n      try {\n        // Decode base64 document data\n        const buffer = Buffer.from(documentData.split(',')[1] || documentData, 'base64');\n        \n        let modifiedBuffer: Buffer;\n        \n        if (fileType === 'pdf') {\n          // Apply change to PDF using PDF→DOCX→PDF workflow\n          modifiedBuffer = await applyChangeToPdf(buffer, originalText, suggestedText);\n          const base64 = modifiedBuffer.toString('base64');\n          modifiedDocumentUrl = `data:application/pdf;base64,${base64}`;\n        } else if (fileType === 'docx') {\n          // Apply change to DOCX\n          modifiedBuffer = await applyChangeToDocx(buffer, originalText, suggestedText);\n          const base64 = modifiedBuffer.toString('base64');\n          modifiedDocumentUrl = `data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,${base64}`;\n        }\n      } catch (error) {\n        console.error('Error processing document:', error);\n        // Continue without modified document URL\n      }\n    }\n\n    // Update suggestion in database if suggestionId is provided\n    // Note: In a full implementation, you might want to add an isApplied field to the schema\n    // For now, we'll just log the application\n    if (suggestionId) {\n      try {\n        // Try to find and update the suggestion\n        // Since the current schema doesn't have isApplied, we'll just update the suggestedFix\n        // Pass documentId to verify the suggestion belongs to this document\n        await updateSuggestion(\n          suggestionId,\n          {\n            suggestedFix: suggestedText,\n          },\n          documentId\n        );\n        console.log('✅ Updated suggestion in database:', suggestionId);\n      } catch (dbError) {\n        console.error('❌ Database error updating suggestion:', dbError);\n        // Log the error but continue - the document update was successful\n        // This allows the user to apply changes even if the suggestion record is missing\n      }\n    }\n\n    // Simulate processing delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Mock: Deduct balance for applying change (0.01 credits per change)\n    const costPerChange = 0.01;\n\n    return NextResponse.json({\n      success: true,\n      documentId,\n      appliedChange: {\n        from: originalText,\n        to: suggestedText,\n        suggestionId,\n      },\n      modifiedDocumentUrl, // Optional: URL to download modified document\n      cost: costPerChange,\n      message: 'Change applied successfully',\n    });\n  } catch (error) {\n    console.error('Error applying change:', error);\n    return NextResponse.json(\n      { \n        error: 'Failed to apply change',\n        details: error instanceof Error ? error.message : String(error)\n      },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}