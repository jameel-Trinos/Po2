{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/lib/pdfStorage.ts"],"sourcesContent":["/**\n * In-memory storage for PDF documents\n * Stores PDFs temporarily for conversion operations\n * \n * Note: This is a simple in-memory solution. For production,\n * consider using Redis, S3, or a database.\n */\n\ninterface StoredPDF {\n  buffer: Buffer;\n  fileName: string;\n  uploadedAt: Date;\n}\n\n// In-memory storage Map\nconst pdfStorage = new Map<string, StoredPDF>();\n\n// Cleanup interval (remove PDFs older than 1 hour)\nconst CLEANUP_INTERVAL = 60 * 60 * 1000; // 1 hour\nconst MAX_AGE = 60 * 60 * 1000; // 1 hour\n\n// Periodic cleanup\nif (typeof setInterval !== 'undefined') {\n  setInterval(() => {\n    const now = new Date();\n    for (const [id, pdf] of pdfStorage.entries()) {\n      const age = now.getTime() - pdf.uploadedAt.getTime();\n      if (age > MAX_AGE) {\n        console.log(`üóëÔ∏è  Cleaning up old PDF: ${id} (${pdf.fileName})`);\n        pdfStorage.delete(id);\n      }\n    }\n  }, CLEANUP_INTERVAL);\n}\n\n/**\n * Store a PDF in memory\n */\nexport function storePDF(documentId: string, buffer: Buffer, fileName: string): void {\n  console.log(`üíæ Storing PDF: ${documentId} (${fileName}, ${buffer.length} bytes)`);\n  pdfStorage.set(documentId, {\n    buffer,\n    fileName,\n    uploadedAt: new Date(),\n  });\n}\n\n/**\n * Retrieve a stored PDF\n */\nexport function getPDF(documentId: string): { buffer: Buffer; fileName: string } | null {\n  const stored = pdfStorage.get(documentId);\n  if (!stored) {\n    console.log(`‚ùå PDF not found: ${documentId}`);\n    return null;\n  }\n  console.log(`‚úÖ Retrieved PDF: ${documentId} (${stored.fileName}, ${stored.buffer.length} bytes)`);\n  return {\n    buffer: stored.buffer,\n    fileName: stored.fileName,\n  };\n}\n\n/**\n * Delete a stored PDF\n */\nexport function deletePDF(documentId: string): boolean {\n  const deleted = pdfStorage.delete(documentId);\n  if (deleted) {\n    console.log(`üóëÔ∏è  Deleted PDF: ${documentId}`);\n  }\n  return deleted;\n}\n\n/**\n * Get storage statistics\n */\nexport function getStorageStats(): { count: number; totalSize: number } {\n  let totalSize = 0;\n  for (const pdf of pdfStorage.values()) {\n    totalSize += pdf.buffer.length;\n  }\n  return {\n    count: pdfStorage.size,\n    totalSize,\n  };\n}\n\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;;;AAQD,wBAAwB;AACxB,MAAM,aAAa,IAAI;AAEvB,mDAAmD;AACnD,MAAM,mBAAmB,KAAK,KAAK,MAAM,SAAS;AAClD,MAAM,UAAU,KAAK,KAAK,MAAM,SAAS;AAEzC,mBAAmB;AACnB,IAAI,OAAO,gBAAgB,aAAa;IACtC,YAAY;QACV,MAAM,MAAM,IAAI;QAChB,KAAK,MAAM,CAAC,IAAI,IAAI,IAAI,WAAW,OAAO,GAAI;YAC5C,MAAM,MAAM,IAAI,OAAO,KAAK,IAAI,UAAU,CAAC,OAAO;YAClD,IAAI,MAAM,SAAS;gBACjB,QAAQ,GAAG,CAAC,CAAC,0BAA0B,EAAE,GAAG,EAAE,EAAE,IAAI,QAAQ,CAAC,CAAC,CAAC;gBAC/D,WAAW,MAAM,CAAC;YACpB;QACF;IACF,GAAG;AACL;AAKO,SAAS,SAAS,UAAkB,EAAE,MAAc,EAAE,QAAgB;IAC3E,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,WAAW,EAAE,EAAE,SAAS,EAAE,EAAE,OAAO,MAAM,CAAC,OAAO,CAAC;IACjF,WAAW,GAAG,CAAC,YAAY;QACzB;QACA;QACA,YAAY,IAAI;IAClB;AACF;AAKO,SAAS,OAAO,UAAkB;IACvC,MAAM,SAAS,WAAW,GAAG,CAAC;IAC9B,IAAI,CAAC,QAAQ;QACX,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,YAAY;QAC5C,OAAO;IACT;IACA,QAAQ,GAAG,CAAC,CAAC,iBAAiB,EAAE,WAAW,EAAE,EAAE,OAAO,QAAQ,CAAC,EAAE,EAAE,OAAO,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC;IAChG,OAAO;QACL,QAAQ,OAAO,MAAM;QACrB,UAAU,OAAO,QAAQ;IAC3B;AACF;AAKO,SAAS,UAAU,UAAkB;IAC1C,MAAM,UAAU,WAAW,MAAM,CAAC;IAClC,IAAI,SAAS;QACX,QAAQ,GAAG,CAAC,CAAC,kBAAkB,EAAE,YAAY;IAC/C;IACA,OAAO;AACT;AAKO,SAAS;IACd,IAAI,YAAY;IAChB,KAAK,MAAM,OAAO,WAAW,MAAM,GAAI;QACrC,aAAa,IAAI,MAAM,CAAC,MAAM;IAChC;IACA,OAAO;QACL,OAAO,WAAW,IAAI;QACtB;IACF;AACF","debugId":null}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/app/api/pdf-to-docx/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { Document, Packer, Paragraph, TextRun, HeadingLevel } from 'docx';\nimport { getPDF } from '@/lib/pdfStorage';\nimport pdfParse from 'pdf-parse';\n\nexport const runtime = 'nodejs';\n\n/**\n * Extract text from PDF using pdf-parse (Node.js native)\n */\nasync function extractTextFromPdf(buffer: Buffer): Promise<{ text: string; numPages: number }> {\n  console.log('Parsing PDF with pdf-parse...');\n  \n  try {\n    const data = await pdfParse(buffer);\n    \n    console.log('PDF parsed successfully');\n    console.log('Pages:', data.numpages);\n    console.log('Text length:', data.text.length);\n    \n    return {\n      text: data.text,\n      numPages: data.numpages\n    };\n  } catch (error) {\n    console.error('PDF parsing error:', error);\n    throw error;\n  }\n}\n\n/**\n * Convert PDF to DOCX via backend\n * Extracts text from PDF and creates a DOCX document\n * Accepts either a file upload or a URL to fetch the PDF from\n */\nexport async function POST(request: NextRequest) {\n  try {\n    // Validate request\n    const contentType = request.headers.get('content-type');\n    console.log('üì• Incoming request content-type:', contentType);\n    \n    let file: File | null = null;\n    let fileName = 'document.pdf';\n    \n    // Check if it's JSON (URL-based or document ID-based) or multipart (file upload)\n    if (contentType?.includes('application/json')) {\n      console.log('üìã Parsing JSON body...');\n      const body = await request.json();\n      const documentId = body.documentId as string | undefined;\n      const pdfUrl = body.pdfUrl as string | undefined;\n      \n      // Priority: documentId > pdfUrl\n      if (documentId) {\n        console.log('üì• Processing PDF from storage (documentId:', documentId, ')...');\n        \n        // Retrieve PDF from storage\n        const storedPdf = getPDF(documentId);\n        if (!storedPdf) {\n          return NextResponse.json(\n            { \n              error: 'PDF not found',\n              message: `No PDF found for document ID: ${documentId}. The PDF may have expired or been deleted.`,\n              details: 'PDFs are stored temporarily (1 hour). Please re-upload the document.'\n            },\n            { status: 404 }\n          );\n        }\n        \n        // Convert buffer to File\n        fileName = storedPdf.fileName;\n        file = new File([storedPdf.buffer], fileName, { type: 'application/pdf' });\n        console.log('‚úÖ Retrieved PDF from storage:', fileName, '(', storedPdf.buffer.length, 'bytes)');\n      } else if (pdfUrl) {\n        console.log('üì• Processing PDF from URL...');\n        \n        try {\n          let pdfBlob: Blob;\n        \n        // Check if it's a data URL (starts with data:)\n        if (pdfUrl.startsWith('data:')) {\n          console.log('üìã Detected data URL, converting directly to blob...');\n          \n          // Extract the base64 data from the data URL\n          const base64Data = pdfUrl.split(',')[1];\n          if (!base64Data) {\n            throw new Error('Invalid data URL format');\n          }\n          \n          // Convert base64 to binary\n          const binaryString = atob(base64Data);\n          const bytes = new Uint8Array(binaryString.length);\n          for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n          }\n          \n          pdfBlob = new Blob([bytes], { type: 'application/pdf' });\n          console.log('‚úÖ Data URL converted to blob, size:', pdfBlob.size, 'bytes');\n        } else {\n          console.log('üåê Fetching PDF from remote URL:', pdfUrl.substring(0, 100) + '...');\n          \n          // Fetch PDF from URL server-side\n          const pdfResponse = await fetch(pdfUrl, {\n            headers: {\n              'Accept': 'application/pdf,*/*'\n            }\n          });\n          \n          if (!pdfResponse.ok) {\n            throw new Error(`Failed to fetch PDF: ${pdfResponse.statusText}`);\n          }\n          \n          pdfBlob = await pdfResponse.blob();\n          console.log('‚úÖ PDF fetched from URL, size:', pdfBlob.size, 'bytes');\n        }\n        \n        // Extract filename from URL if possible (skip for data URLs)\n        if (!pdfUrl.startsWith('data:')) {\n          const urlPath = pdfUrl.split('?')[0];\n          const urlFileName = urlPath.split('/').pop();\n          if (urlFileName && urlFileName.endsWith('.pdf')) {\n            fileName = urlFileName;\n          }\n        }\n        \n        // Convert blob to File\n        file = new File([pdfBlob], fileName, { type: 'application/pdf' });\n      } catch (fetchError) {\n        console.error('‚ùå Failed to process PDF from URL:', fetchError);\n        const fetchErrorMessage = fetchError instanceof Error ? fetchError.message : 'Unknown error';\n        return NextResponse.json(\n          {\n            error: 'Failed to process PDF from URL',\n            message: fetchErrorMessage,\n            details: `Could not retrieve or convert PDF from the provided URL`\n          },\n          { status: 400 }\n        );\n      }\n    } else {\n      return NextResponse.json(\n        { \n          error: 'No PDF source provided',\n          message: 'Please provide either a documentId or pdfUrl in the request body'\n        },\n        { status: 400 }\n      );\n    }\n    } else if (contentType?.includes('multipart/form-data')) {\n      console.log('üìã Parsing form data (file upload)...');\n      const formData = await request.formData();\n      file = formData.get('file') as File;\n\n      // Log all form data entries for debugging\n      console.log('üìã Form data entries:');\n      for (const [key, value] of formData.entries()) {\n        if (value instanceof File) {\n          console.log(`  - ${key}: File(name=\"${value.name}\", type=\"${value.type}\", size=${value.size})`);\n        } else {\n          console.log(`  - ${key}:`, value);\n        }\n      }\n    } else {\n      console.warn('‚ö†Ô∏è Unexpected content type:', contentType);\n      return NextResponse.json(\n        { \n          error: 'Invalid content type',\n          message: 'Request must be either application/json (with pdfUrl) or multipart/form-data (with file)'\n        },\n        { status: 400 }\n      );\n    }\n\n    if (!file) {\n      console.error('‚ùå No file provided');\n      return NextResponse.json(\n        { \n          error: 'No file provided',\n          message: 'Please ensure a file is included in the request or a valid pdfUrl is provided'\n        },\n        { \n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    console.log('‚úÖ Processing file:', {\n      name: file.name,\n      type: file.type,\n      size: file.size\n    });\n\n    // Check if it's a PDF\n    const hasValidExtension = file.name.toLowerCase().endsWith('.pdf');\n    const hasValidMimeType = file.type === 'application/pdf';\n    \n    console.log('üîç File validation:');\n    console.log('  - Has .pdf extension:', hasValidExtension);\n    console.log('  - Has PDF MIME type:', hasValidMimeType);\n    console.log('  - File type:', file.type || '(empty)');\n    \n    if (!hasValidExtension && !hasValidMimeType) {\n      console.error('‚ùå Invalid file type:', file.type, 'for file:', file.name);\n      return NextResponse.json(\n        { \n          error: 'File must be a PDF',\n          message: `Received file type: ${file.type || 'unknown'}`,\n          details: `File name: ${file.name}. Expected .pdf extension and/or application/pdf MIME type.`\n        },\n        { \n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    // Check file size (optional validation)\n    if (file.size === 0) {\n      console.error('‚ùå Empty file provided');\n      return NextResponse.json(\n        { \n          error: 'Empty file provided',\n          message: 'The PDF file appears to be empty (0 bytes)',\n          details: `File name: ${file.name}, Size: ${file.size} bytes`\n        },\n        { \n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n    \n    console.log('‚úÖ File validation passed');\n\n    console.log('Reading PDF file...');\n    let pdfBuffer: Buffer;\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      pdfBuffer = Buffer.from(arrayBuffer);\n      console.log('PDF file read, size:', pdfBuffer.length, 'bytes');\n    } catch (readError) {\n      console.error('Failed to read PDF file:', readError);\n      const readErrorMessage = readError instanceof Error ? readError.message : 'Unknown error';\n      return NextResponse.json(\n        {\n          error: 'Failed to read PDF file',\n          message: readErrorMessage,\n          details: 'The PDF file could not be read from the request.'\n        },\n        {\n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    console.log('Parsing PDF document...');\n    let pdfData: { text: string; numPages: number };\n    try {\n      // Extract text using pdf-parse (Node.js native library)\n      pdfData = await extractTextFromPdf(pdfBuffer);\n      \n      console.log('PDF parsed successfully, pages:', pdfData.numPages);\n      console.log('Text length:', pdfData.text.length);\n      \n      if (!pdfData.text || pdfData.text.length === 0) {\n        console.warn('No text extracted from PDF');\n        return NextResponse.json(\n          {\n            error: 'No text found in PDF',\n            message: 'The PDF appears to be empty or contains only images/scanned content.',\n            details: 'Try using a PDF with selectable text, or use OCR for scanned documents.'\n          },\n          {\n            status: 400,\n            headers: {\n              'Content-Type': 'application/json',\n            }\n          }\n        );\n      }\n    } catch (parseError) {\n      console.error('Failed to parse PDF:', parseError);\n      const parseErrorMessage = parseError instanceof Error ? parseError.message : 'Unknown error';\n      const parseErrorStack = parseError instanceof Error ? parseError.stack : undefined;\n      \n      console.error('Parse error details:', {\n        message: parseErrorMessage,\n        stack: parseErrorStack,\n        errorType: parseError instanceof Error ? parseError.constructor.name : typeof parseError\n      });\n      \n      return NextResponse.json(\n        {\n          error: 'Failed to parse PDF',\n          message: parseErrorMessage,\n          details: 'The PDF file could not be parsed. It may be corrupted or in an unsupported format.',\n          ...(process.env.NODE_ENV === 'development' && parseErrorStack ? { stack: parseErrorStack } : {})\n        },\n        {\n          status: 400,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    // Extract text and structure from PDF\n    console.log('Extracting text from PDF...');\n    const paragraphs: Paragraph[] = [];\n    \n    try {\n      // Split text into paragraphs (double newlines indicate paragraph breaks)\n      const textBlocks = pdfData.text.split(/\\n\\s*\\n/).filter(block => block.trim());\n      \n      textBlocks.forEach((textBlock) => {\n        const trimmedText = textBlock.trim();\n        if (!trimmedText) return;\n\n        // Simple heuristic: detect headings (short lines, typically at start)\n        const lines = trimmedText.split('\\n');\n        const firstLine = lines[0]?.trim() || '';\n        \n        let paragraphOptions: any = {\n          children: [new TextRun({ text: trimmedText })],\n        };\n\n        // Determine if it's a heading (short first line, typically less than 100 chars)\n        if (firstLine.length < 100 && lines.length === 1) {\n          // Check if it looks like a heading (all caps, or starts with number, etc.)\n          if (firstLine === firstLine.toUpperCase() || /^\\d+\\.?\\s/.test(firstLine)) {\n            paragraphOptions.heading = HeadingLevel.HEADING_2;\n          } else if (firstLine.length < 60) {\n            paragraphOptions.heading = HeadingLevel.HEADING_3;\n          }\n        }\n\n        paragraphs.push(new Paragraph(paragraphOptions));\n      });\n    } catch (extractionError) {\n      console.error('Error extracting text from PDF:', extractionError);\n      const extractionErrorMessage = extractionError instanceof Error ? extractionError.message : 'Unknown error';\n      return NextResponse.json(\n        {\n          error: 'Failed to extract text from PDF',\n          message: extractionErrorMessage,\n          details: 'An error occurred while extracting text from the PDF.'\n        },\n        {\n          status: 500,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    console.log('Text extraction complete. Paragraphs:', paragraphs.length);\n\n    // Create DOCX document\n    console.log('Creating DOCX document...');\n    let doc;\n    try {\n      doc = new Document({\n        sections: [\n          {\n            properties: {},\n            children: paragraphs.length > 0 ? paragraphs : [\n              new Paragraph({\n                children: [new TextRun({ text: 'No text content found in PDF.' })],\n              }),\n            ],\n          },\n        ],\n      });\n      console.log('DOCX document created successfully');\n    } catch (docError) {\n      console.error('Error creating DOCX document:', docError);\n      const docErrorMessage = docError instanceof Error ? docError.message : 'Unknown error';\n      return NextResponse.json(\n        {\n          error: 'Failed to create DOCX document',\n          message: docErrorMessage,\n          details: 'An error occurred while creating the DOCX document structure.'\n        },\n        {\n          status: 500,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    // Generate DOCX buffer\n    console.log('Generating DOCX buffer...');\n    let buffer;\n    try {\n      buffer = await Packer.toBuffer(doc);\n      console.log('DOCX buffer generated, size:', buffer.length, 'bytes');\n    } catch (bufferError) {\n      console.error('Error generating DOCX buffer:', bufferError);\n      const bufferErrorMessage = bufferError instanceof Error ? bufferError.message : 'Unknown error';\n      return NextResponse.json(\n        {\n          error: 'Failed to generate DOCX file',\n          message: bufferErrorMessage,\n          details: 'An error occurred while generating the DOCX file buffer.'\n        },\n        {\n          status: 500,\n          headers: {\n            'Content-Type': 'application/json',\n          }\n        }\n      );\n    }\n\n    // Return DOCX file\n    return new NextResponse(new Uint8Array(buffer), {\n      status: 200,\n      headers: {\n        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        'Content-Disposition': `attachment; filename=\"${file.name.replace(/\\.pdf$/i, '.docx')}\"`,\n      },\n    });\n  } catch (error) {\n    console.error('PDF to DOCX conversion error:', error);\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    const errorStack = error instanceof Error ? error.stack : undefined;\n    const errorName = error instanceof Error ? error.name : 'Error';\n    \n    // Log full error details for debugging\n    console.error('Error name:', errorName);\n    console.error('Error message:', errorMessage);\n    if (errorStack) {\n      console.error('Error stack:', errorStack);\n    }\n    \n    // Ensure we always return a valid JSON error response\n    const errorResponse = {\n      error: 'Failed to convert PDF to DOCX',\n      message: errorMessage,\n      ...(process.env.NODE_ENV === 'development' && {\n        details: errorMessage,\n        name: errorName,\n        ...(errorStack ? { stack: errorStack } : {})\n      })\n    };\n    \n    console.error('Returning error response:', JSON.stringify(errorResponse, null, 2));\n    \n    return NextResponse.json(\n      errorResponse,\n      { \n        status: 500,\n        headers: {\n          'Content-Type': 'application/json',\n        }\n      }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}