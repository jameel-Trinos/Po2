{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/app/api/compliance/apply-change/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { PDFDocument } from 'pdf-lib';\nimport mammoth from 'mammoth';\nimport { Document, Packer, Paragraph, TextRun } from 'docx';\nimport { JSDOM } from 'jsdom';\n\n// Force Node.js runtime\nexport const runtime = 'nodejs';\n\n// Helper function to load pdfjs dynamically\nasync function loadPdfJs() {\n  const pdfjs = await import('pdfjs-dist');\n  // Set worker source if not already set\n  if (typeof globalThis !== 'undefined' && !pdfjs.GlobalWorkerOptions.workerSrc) {\n    pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`;\n  }\n  return pdfjs;\n}\n\n/**\n * Extract text from PDF using pdfjs-dist\n */\nasync function extractTextFromPdf(buffer: Buffer): Promise<string> {\n  const pdfjs = await loadPdfJs();\n  const pdf = await pdfjs.getDocument({ data: buffer }).promise;\n  \n  let fullText = '';\n  \n  // Extract text from each page\n  for (let i = 1; i <= pdf.numPages; i++) {\n    const page = await pdf.getPage(i);\n    const textContent = await page.getTextContent();\n    \n    // Combine text items with proper spacing\n    const pageText = textContent.items\n      .map((item: any) => {\n        if ('str' in item) {\n          return item.str;\n        }\n        return '';\n      })\n      .join(' ');\n    \n    fullText += pageText + '\\n\\n';\n  }\n  \n  return fullText.trim();\n}\n\n/**\n * Apply text replacement in PDF using PDF→DOCX→PDF workflow\n * This is the recommended approach for complex text modifications\n */\nasync function applyChangeToPdf(\n  pdfBuffer: Buffer,\n  originalText: string,\n  suggestedText: string\n): Promise<Buffer> {\n  try {\n    // Step 1: Extract text from PDF\n    let modifiedText = await extractTextFromPdf(pdfBuffer);\n    \n    // Step 2: Apply text replacement\n    const regex = new RegExp(originalText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi');\n    modifiedText = modifiedText.replace(regex, suggestedText);\n    \n    // Step 3: Convert to DOCX format\n    const paragraphs = modifiedText\n      .split('\\n\\n')\n      .filter((p: string) => p.trim())\n      .map((p: string) => new Paragraph({\n        children: [new TextRun(p.trim())],\n      }));\n    \n    const doc = new Document({\n      sections: [{\n        properties: {},\n        children: paragraphs.length > 0 ? paragraphs : [\n          new Paragraph({ children: [new TextRun('')] })\n        ],\n      }],\n    });\n    \n    // Step 4: Generate DOCX buffer\n    const docxBuffer = await Packer.toBuffer(doc);\n    \n    // Note: In a production environment, you would convert DOCX back to PDF\n    // using a service like LibreOffice, Gotenberg, or a cloud API\n    // For now, we return the modified text as a simple PDF\n    \n    // Step 5: Create a new PDF with modified text\n    const newPdfDoc = await PDFDocument.create();\n    const page = newPdfDoc.addPage([595, 842]); // A4 size\n    const { height } = page.getSize();\n    const fontSize = 12;\n    const margin = 50;\n    let yPosition = height - margin;\n    \n    // Split text into lines and add to PDF\n    const lines = modifiedText.split('\\n');\n    for (const line of lines) {\n      if (yPosition < margin) {\n        // Add new page if needed\n        const newPage = newPdfDoc.addPage([595, 842]);\n        yPosition = newPage.getSize().height - margin;\n      }\n      \n      page.drawText(line.slice(0, 80), { // Limit line length\n        x: margin,\n        y: yPosition,\n        size: fontSize,\n      });\n      \n      yPosition -= fontSize + 4;\n    }\n    \n    const pdfBytes = await newPdfDoc.save();\n    return Buffer.from(pdfBytes);\n  } catch (error) {\n    console.error('Error applying change to PDF:', error);\n    throw new Error('Failed to apply change to PDF');\n  }\n}\n\n/**\n * Apply text replacement in DOCX\n */\nasync function applyChangeToDocx(\n  docxBuffer: Buffer,\n  originalText: string,\n  suggestedText: string\n): Promise<Buffer> {\n  try {\n    // Extract HTML from DOCX\n    const result = await mammoth.convertToHtml({ buffer: docxBuffer });\n    let htmlContent = result.value;\n    \n    // Apply text replacement\n    const regex = new RegExp(originalText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'gi');\n    htmlContent = htmlContent.replace(regex, suggestedText);\n    \n    // Convert back to DOCX\n    // Parse HTML and create DOCX structure using JSDOM\n    const dom = new JSDOM(htmlContent);\n    const textContent = dom.window.document.body.textContent || '';\n    \n    const paragraphs = textContent\n      .split('\\n')\n      .filter(p => p.trim())\n      .map(p => new Paragraph({\n        children: [new TextRun(p.trim())],\n      }));\n    \n    const wordDoc = new Document({\n      sections: [{\n        properties: {},\n        children: paragraphs.length > 0 ? paragraphs : [\n          new Paragraph({ children: [new TextRun('')] })\n        ],\n      }],\n    });\n    \n    const buffer = await Packer.toBuffer(wordDoc);\n    return Buffer.from(buffer);\n  } catch (error) {\n    console.error('Error applying change to DOCX:', error);\n    throw new Error('Failed to apply change to DOCX');\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json();\n    const { \n      documentId, \n      originalText, \n      suggestedText, \n      suggestionId,\n      fileType, // 'pdf' or 'docx'\n      documentData, // Base64 encoded document data (optional)\n    } = body;\n\n    // Validate input\n    if (!documentId || !originalText || !suggestedText) {\n      return NextResponse.json(\n        { error: 'Missing required fields: documentId, originalText, suggestedText' },\n        { status: 400 }\n      );\n    }\n\n    let modifiedDocumentUrl: string | undefined;\n\n    // If document data is provided, apply the change\n    if (documentData && fileType) {\n      try {\n        // Decode base64 document data\n        const buffer = Buffer.from(documentData.split(',')[1] || documentData, 'base64');\n        \n        let modifiedBuffer: Buffer;\n        \n        if (fileType === 'pdf') {\n          // Apply change to PDF using PDF→DOCX→PDF workflow\n          modifiedBuffer = await applyChangeToPdf(buffer, originalText, suggestedText);\n          const base64 = modifiedBuffer.toString('base64');\n          modifiedDocumentUrl = `data:application/pdf;base64,${base64}`;\n        } else if (fileType === 'docx') {\n          // Apply change to DOCX\n          modifiedBuffer = await applyChangeToDocx(buffer, originalText, suggestedText);\n          const base64 = modifiedBuffer.toString('base64');\n          modifiedDocumentUrl = `data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,${base64}`;\n        }\n      } catch (error) {\n        console.error('Error processing document:', error);\n        // Continue without modified document URL\n      }\n    }\n\n    // Simulate processing delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Mock: Deduct balance for applying change (0.01 credits per change)\n    const costPerChange = 0.01;\n\n    return NextResponse.json({\n      success: true,\n      documentId,\n      appliedChange: {\n        from: originalText,\n        to: suggestedText,\n        suggestionId,\n      },\n      modifiedDocumentUrl, // Optional: URL to download modified document\n      cost: costPerChange,\n      message: 'Change applied successfully',\n    });\n  } catch (error) {\n    console.error('Error applying change:', error);\n    return NextResponse.json(\n      { \n        error: 'Failed to apply change',\n        details: error instanceof Error ? error.message : String(error)\n      },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}}]
}