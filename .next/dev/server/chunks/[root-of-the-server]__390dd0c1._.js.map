{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/lib/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"info\", \"warn\", \"error\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAQ;QAAQ;KAAQ,GAAG;AACrF;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/lib/db-helpers.ts"],"sourcesContent":["import { prisma } from \"./db\";\nimport type { Prisma } from \"@prisma/client\";\n\n/**\n * Save an uploaded document to the database\n * @param userId - Clerk user ID (string)\n * @param originalName - Original filename\n * @param fileType - File type (e.g., \"pdf\", \"docx\")\n * @param storageUrl - URL or path where the file is stored\n * @returns The created document\n */\nexport async function saveUploadedDocument(\n  userId: string,\n  originalName: string,\n  fileType: string,\n  storageUrl: string\n) {\n  try {\n    const document = await prisma.document.create({\n      data: {\n        userId,\n        originalName,\n        fileType,\n        storageUrl,\n      },\n    });\n    return document;\n  } catch (error) {\n    console.error(\"Error saving document:\", error);\n    throw new Error(\"Failed to save document to database\");\n  }\n}\n\n/**\n * Save AI-generated suggestions for a document\n * @param documentId - Document ID\n * @param suggestions - Array of suggestion objects\n * @returns Array of created suggestions\n */\nexport async function saveAISuggestions(\n  documentId: string,\n  suggestions: Array<{\n    category: string;\n    issue: string;\n    severity: string;\n    startIndex?: number | null;\n    endIndex?: number | null;\n    suggestedFix?: string | null;\n  }>\n) {\n  try {\n    // Delete existing suggestions for this document (optional - you might want to keep them)\n    // await prisma.suggestion.deleteMany({ where: { documentId } });\n\n    // Create new suggestions\n    const createdSuggestions = await prisma.suggestion.createMany({\n      data: suggestions.map((s) => ({\n        documentId,\n        category: s.category,\n        issue: s.issue,\n        severity: s.severity,\n        startIndex: s.startIndex ?? null,\n        endIndex: s.endIndex ?? null,\n        suggestedFix: s.suggestedFix ?? null,\n      })),\n      skipDuplicates: true,\n    });\n\n    // Fetch and return the created suggestions\n    const savedSuggestions = await prisma.suggestion.findMany({\n      where: { documentId },\n      orderBy: { id: \"asc\" },\n    });\n\n    return savedSuggestions;\n  } catch (error) {\n    console.error(\"Error saving suggestions:\", error);\n    throw new Error(\"Failed to save suggestions to database\");\n  }\n}\n\n/**\n * Get a document with all its suggestions\n * @param documentId - Document ID\n * @param userId - Optional user ID for security check\n * @returns Document with suggestions, or null if not found\n */\nexport async function getDocumentWithSuggestions(\n  documentId: string,\n  userId?: string\n) {\n  try {\n    const where: Prisma.DocumentWhereInput = { id: documentId };\n    if (userId) {\n      where.userId = userId;\n    }\n\n    const document = await prisma.document.findFirst({\n      where,\n      include: {\n        suggestions: {\n          orderBy: [\n            { severity: \"asc\" }, // Critical first\n            { category: \"asc\" },\n          ],\n        },\n      },\n    });\n\n    return document;\n  } catch (error) {\n    console.error(\"Error fetching document:\", error);\n    throw new Error(\"Failed to fetch document from database\");\n  }\n}\n\n/**\n * Get all documents for a user\n * @param userId - Clerk user ID\n * @returns Array of documents with suggestion counts\n */\nexport async function getUserDocuments(userId: string) {\n  try {\n    const documents = await prisma.document.findMany({\n      where: { userId },\n      include: {\n        _count: {\n          select: { suggestions: true },\n        },\n      },\n      orderBy: { createdAt: \"desc\" },\n    });\n\n    return documents;\n  } catch (error) {\n    console.error(\"Error fetching user documents:\", error);\n    \n    // Provide more specific error messages\n    if (error instanceof Error) {\n      // Check for common Prisma errors\n      if (error.message.includes('P1001') || error.message.includes('Can\\'t reach database server')) {\n        throw new Error(\"Database connection failed. Please check your DATABASE_URL environment variable.\");\n      }\n      if (error.message.includes('P2002')) {\n        throw new Error(\"Database constraint violation\");\n      }\n      if (error.message.includes('P2025')) {\n        throw new Error(\"Record not found\");\n      }\n      // Re-throw with original message for other errors\n      throw new Error(`Failed to fetch user documents: ${error.message}`);\n    }\n    \n    throw new Error(\"Failed to fetch user documents: Unknown error\");\n  }\n}\n\n/**\n * Update a document\n * @param documentId - Document ID\n * @param userId - User ID for security check\n * @param data - Partial document data to update\n * @returns Updated document\n */\nexport async function updateDocument(\n  documentId: string,\n  userId: string,\n  data: Partial<{\n    originalName: string;\n    fileType: string;\n    storageUrl: string;\n  }>\n) {\n  try {\n    const document = await prisma.document.updateMany({\n      where: {\n        id: documentId,\n        userId, // Ensure user owns the document\n      },\n      data,\n    });\n\n    if (document.count === 0) {\n      throw new Error(\"Document not found or access denied\");\n    }\n\n    return await prisma.document.findUnique({\n      where: { id: documentId },\n    });\n  } catch (error) {\n    console.error(\"Error updating document:\", error);\n    throw new Error(\"Failed to update document\");\n  }\n}\n\n/**\n * Delete a document and its suggestions (cascade)\n * @param documentId - Document ID\n * @param userId - User ID for security check\n */\nexport async function deleteDocument(documentId: string, userId: string) {\n  try {\n    const result = await prisma.document.deleteMany({\n      where: {\n        id: documentId,\n        userId, // Ensure user owns the document\n      },\n    });\n\n    if (result.count === 0) {\n      throw new Error(\"Document not found or access denied\");\n    }\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting document:\", error);\n    throw new Error(\"Failed to delete document\");\n  }\n}\n\n/**\n * Update a suggestion\n * @param suggestionId - Suggestion ID\n * @param data - Partial suggestion data to update\n * @param documentId - Optional document ID to verify the suggestion belongs to the document\n * @returns Updated suggestion\n */\nexport async function updateSuggestion(\n  suggestionId: string,\n  data: Partial<{\n    category: string;\n    issue: string;\n    severity: string;\n    startIndex: number | null;\n    endIndex: number | null;\n    suggestedFix: string | null;\n  }>,\n  documentId?: string\n) {\n  try {\n    // First, check if the suggestion exists\n    const existingSuggestion = await prisma.suggestion.findUnique({\n      where: { id: suggestionId },\n    });\n\n    if (!existingSuggestion) {\n      throw new Error(`Suggestion with ID ${suggestionId} not found`);\n    }\n\n    // If documentId is provided, verify the suggestion belongs to that document\n    if (documentId && existingSuggestion.documentId !== documentId) {\n      throw new Error(\"Suggestion does not belong to the specified document\");\n    }\n\n    // Update the suggestion\n    const suggestion = await prisma.suggestion.update({\n      where: { id: suggestionId },\n      data,\n    });\n\n    return suggestion;\n  } catch (error) {\n    console.error(\"Error updating suggestion:\", error);\n    \n    // Handle Prisma P2025 error (record not found)\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'P2025') {\n      throw new Error(`Suggestion with ID ${suggestionId} not found`);\n    }\n    \n    // Re-throw if it's already our custom error\n    if (error instanceof Error) {\n      throw error;\n    }\n    \n    throw new Error(\"Failed to update suggestion\");\n  }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 298, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Trinos/Learning/PointofTwo/Po2/app/api/documents/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { auth } from '@clerk/nextjs/server';\nimport { getUserDocuments } from '@/lib/db-helpers';\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Get authenticated user\n    const { userId } = await auth();\n    \n    if (!userId) {\n      console.error('[GET /api/documents] Unauthorized: No userId');\n      return NextResponse.json(\n        { error: 'Unauthorized', details: 'User not authenticated' },\n        { status: 401 }\n      );\n    }\n\n    console.log('[GET /api/documents] Fetching documents for user:', userId);\n\n    // Fetch user's documents from database\n    const documents = await getUserDocuments(userId);\n\n    console.log('[GET /api/documents] Successfully fetched', documents.length, 'documents');\n\n    return NextResponse.json({\n      success: true,\n      documents: documents.map(doc => ({\n        id: doc.id,\n        originalName: doc.originalName,\n        fileType: doc.fileType,\n        createdAt: doc.createdAt.toISOString(),\n        updatedAt: doc.updatedAt.toISOString(),\n        suggestionCount: doc._count?.suggestions || 0,\n      })),\n    });\n  } catch (error) {\n    console.error('[GET /api/documents] Error fetching documents:', error);\n    \n    // More detailed error logging\n    if (error instanceof Error) {\n      console.error('[GET /api/documents] Error name:', error.name);\n      console.error('[GET /api/documents] Error message:', error.message);\n      console.error('[GET /api/documents] Error stack:', error.stack);\n    }\n\n    return NextResponse.json(\n      { \n        success: false,\n        error: 'Failed to fetch documents',\n        details: error instanceof Error ? error.message : String(error),\n        type: error instanceof Error ? error.name : 'UnknownError'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,yBAAyB;QACzB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,IAAA,6LAAI;QAE7B,IAAI,CAAC,QAAQ;YACX,QAAQ,KAAK,CAAC;YACd,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;gBAAgB,SAAS;YAAyB,GAC3D;gBAAE,QAAQ;YAAI;QAElB;QAEA,QAAQ,GAAG,CAAC,qDAAqD;QAEjE,uCAAuC;QACvC,MAAM,YAAY,MAAM,IAAA,0IAAgB,EAAC;QAEzC,QAAQ,GAAG,CAAC,6CAA6C,UAAU,MAAM,EAAE;QAE3E,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,WAAW,UAAU,GAAG,CAAC,CAAA,MAAO,CAAC;oBAC/B,IAAI,IAAI,EAAE;oBACV,cAAc,IAAI,YAAY;oBAC9B,UAAU,IAAI,QAAQ;oBACtB,WAAW,IAAI,SAAS,CAAC,WAAW;oBACpC,WAAW,IAAI,SAAS,CAAC,WAAW;oBACpC,iBAAiB,IAAI,MAAM,EAAE,eAAe;gBAC9C,CAAC;QACH;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kDAAkD;QAEhE,8BAA8B;QAC9B,IAAI,iBAAiB,OAAO;YAC1B,QAAQ,KAAK,CAAC,oCAAoC,MAAM,IAAI;YAC5D,QAAQ,KAAK,CAAC,uCAAuC,MAAM,OAAO;YAClE,QAAQ,KAAK,CAAC,qCAAqC,MAAM,KAAK;QAChE;QAEA,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO;YACP,SAAS,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO;YACzD,MAAM,iBAAiB,QAAQ,MAAM,IAAI,GAAG;QAC9C,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}