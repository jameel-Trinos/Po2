module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:crypto [external] (node:crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:crypto", () => require("node:crypto"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/jsdom [external] (jsdom, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("jsdom", () => require("jsdom"));

module.exports = mod;
}),
"[externals]/@prisma/client [external] (@prisma/client, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("@prisma/client", () => require("@prisma/client"));

module.exports = mod;
}),
"[project]/lib/db.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "prisma",
    ()=>prisma
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@prisma/client [external] (@prisma/client, cjs)");
;
const globalForPrisma = globalThis;
const prisma = globalForPrisma.prisma ?? new __TURBOPACK__imported__module__$5b$externals$5d2f40$prisma$2f$client__$5b$external$5d$__$2840$prisma$2f$client$2c$__cjs$29$__["PrismaClient"]({
    log: ("TURBOPACK compile-time truthy", 1) ? [
        "query",
        "info",
        "warn",
        "error"
    ] : "TURBOPACK unreachable"
});
if ("TURBOPACK compile-time truthy", 1) globalForPrisma.prisma = prisma;
}),
"[project]/lib/db-helpers.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deleteDocument",
    ()=>deleteDocument,
    "getDocumentWithSuggestions",
    ()=>getDocumentWithSuggestions,
    "getUserDocuments",
    ()=>getUserDocuments,
    "saveAISuggestions",
    ()=>saveAISuggestions,
    "saveUploadedDocument",
    ()=>saveUploadedDocument,
    "updateDocument",
    ()=>updateDocument,
    "updateSuggestion",
    ()=>updateSuggestion
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db.ts [app-route] (ecmascript)");
;
async function saveUploadedDocument(userId, originalName, fileType, storageUrl) {
    try {
        const document = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].document.create({
            data: {
                userId,
                originalName,
                fileType,
                storageUrl
            }
        });
        return document;
    } catch (error) {
        console.error("Error saving document:", error);
        throw new Error("Failed to save document to database");
    }
}
async function saveAISuggestions(documentId, suggestions) {
    try {
        // Delete existing suggestions for this document (optional - you might want to keep them)
        // await prisma.suggestion.deleteMany({ where: { documentId } });
        // Create new suggestions
        const createdSuggestions = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].suggestion.createMany({
            data: suggestions.map((s)=>({
                    documentId,
                    category: s.category,
                    issue: s.issue,
                    severity: s.severity,
                    startIndex: s.startIndex ?? null,
                    endIndex: s.endIndex ?? null,
                    suggestedFix: s.suggestedFix ?? null
                })),
            skipDuplicates: true
        });
        // Fetch and return the created suggestions
        const savedSuggestions = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].suggestion.findMany({
            where: {
                documentId
            },
            orderBy: {
                id: "asc"
            }
        });
        return savedSuggestions;
    } catch (error) {
        console.error("Error saving suggestions:", error);
        throw new Error("Failed to save suggestions to database");
    }
}
async function getDocumentWithSuggestions(documentId, userId) {
    try {
        const where = {
            id: documentId
        };
        if (userId) {
            where.userId = userId;
        }
        const document = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].document.findFirst({
            where,
            include: {
                suggestions: {
                    orderBy: [
                        {
                            severity: "asc"
                        },
                        {
                            category: "asc"
                        }
                    ]
                }
            }
        });
        return document;
    } catch (error) {
        console.error("Error fetching document:", error);
        throw new Error("Failed to fetch document from database");
    }
}
async function getUserDocuments(userId) {
    try {
        const documents = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].document.findMany({
            where: {
                userId
            },
            include: {
                _count: {
                    select: {
                        suggestions: true
                    }
                }
            },
            orderBy: {
                createdAt: "desc"
            }
        });
        return documents;
    } catch (error) {
        console.error("Error fetching user documents:", error);
        // Provide more specific error messages
        if (error instanceof Error) {
            // Check for common Prisma errors
            if (error.message.includes('P1001') || error.message.includes('Can\'t reach database server')) {
                throw new Error("Database connection failed. Please check your DATABASE_URL environment variable.");
            }
            if (error.message.includes('P2002')) {
                throw new Error("Database constraint violation");
            }
            if (error.message.includes('P2025')) {
                throw new Error("Record not found");
            }
            // Re-throw with original message for other errors
            throw new Error(`Failed to fetch user documents: ${error.message}`);
        }
        throw new Error("Failed to fetch user documents: Unknown error");
    }
}
async function updateDocument(documentId, userId, data) {
    try {
        const document = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].document.updateMany({
            where: {
                id: documentId,
                userId
            },
            data
        });
        if (document.count === 0) {
            throw new Error("Document not found or access denied");
        }
        return await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].document.findUnique({
            where: {
                id: documentId
            }
        });
    } catch (error) {
        console.error("Error updating document:", error);
        throw new Error("Failed to update document");
    }
}
async function deleteDocument(documentId, userId) {
    try {
        const result = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].document.deleteMany({
            where: {
                id: documentId,
                userId
            }
        });
        if (result.count === 0) {
            throw new Error("Document not found or access denied");
        }
        return {
            success: true
        };
    } catch (error) {
        console.error("Error deleting document:", error);
        throw new Error("Failed to delete document");
    }
}
async function updateSuggestion(suggestionId, data, documentId) {
    try {
        // First, check if the suggestion exists
        const existingSuggestion = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].suggestion.findUnique({
            where: {
                id: suggestionId
            }
        });
        if (!existingSuggestion) {
            throw new Error(`Suggestion with ID ${suggestionId} not found`);
        }
        // If documentId is provided, verify the suggestion belongs to that document
        if (documentId && existingSuggestion.documentId !== documentId) {
            throw new Error("Suggestion does not belong to the specified document");
        }
        // Update the suggestion
        const suggestion = await __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prisma"].suggestion.update({
            where: {
                id: suggestionId
            },
            data
        });
        return suggestion;
    } catch (error) {
        console.error("Error updating suggestion:", error);
        // Handle Prisma P2025 error (record not found)
        if (error && typeof error === 'object' && 'code' in error && error.code === 'P2025') {
            throw new Error(`Suggestion with ID ${suggestionId} not found`);
        }
        // Re-throw if it's already our custom error
        if (error instanceof Error) {
            throw error;
        }
        throw new Error("Failed to update suggestion");
    }
}
}),
"[project]/app/api/compliance/apply-change/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST,
    "runtime",
    ()=>runtime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$nextjs$2f$dist$2f$esm$2f$app$2d$router$2f$server$2f$auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@clerk/nextjs/dist/esm/app-router/server/auth.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdf$2d$lib$2f$es$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/pdf-lib/es/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pdf-lib/es/api/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mammoth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mammoth/lib/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/docx/dist/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$jsdom__$5b$external$5d$__$28$jsdom$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/jsdom [external] (jsdom, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/db-helpers.ts [app-route] (ecmascript)");
;
;
;
;
;
;
;
const runtime = 'nodejs';
// Helper function to load pdfjs dynamically
async function loadPdfJs() {
    const pdfjs = await __turbopack_context__.A("[project]/node_modules/pdfjs-dist/build/pdf.mjs [app-route] (ecmascript, async loader)");
    // Set worker source if not already set
    if (typeof globalThis !== 'undefined' && !pdfjs.GlobalWorkerOptions.workerSrc) {
        pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.mjs`;
    }
    return pdfjs;
}
/**
 * Extract text from PDF using pdfjs-dist
 */ async function extractTextFromPdf(buffer) {
    const pdfjs = await loadPdfJs();
    const pdf = await pdfjs.getDocument({
        data: buffer
    }).promise;
    let fullText = '';
    // Extract text from each page
    for(let i = 1; i <= pdf.numPages; i++){
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        // Combine text items with proper spacing
        const pageText = textContent.items.map((item)=>{
            if ('str' in item) {
                return item.str;
            }
            return '';
        }).join(' ');
        fullText += pageText + '\n\n';
    }
    return fullText.trim();
}
/**
 * Apply text replacement in PDF using PDF→DOCX→PDF workflow
 * This is the recommended approach for complex text modifications
 */ async function applyChangeToPdf(pdfBuffer, originalText, suggestedText) {
    try {
        // Step 1: Extract text from PDF
        let modifiedText = await extractTextFromPdf(pdfBuffer);
        // Step 2: Apply text replacement
        const regex = new RegExp(originalText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        modifiedText = modifiedText.replace(regex, suggestedText);
        // Step 3: Convert to DOCX format
        const paragraphs = modifiedText.split('\n\n').filter((p)=>p.trim()).map((p)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Paragraph"]({
                children: [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextRun"](p.trim())
                ]
            }));
        const doc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Document"]({
            sections: [
                {
                    properties: {},
                    children: paragraphs.length > 0 ? paragraphs : [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Paragraph"]({
                            children: [
                                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextRun"]('')
                            ]
                        })
                    ]
                }
            ]
        });
        // Step 4: Generate DOCX buffer
        const docxBuffer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Packer"].toBuffer(doc);
        // Note: In a production environment, you would convert DOCX back to PDF
        // using a service like LibreOffice, Gotenberg, or a cloud API
        // For now, we return the modified text as a simple PDF
        // Step 5: Create a new PDF with modified text
        const newPdfDoc = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pdf$2d$lib$2f$es$2f$api$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PDFDocument"].create();
        const page = newPdfDoc.addPage([
            595,
            842
        ]); // A4 size
        const { height } = page.getSize();
        const fontSize = 12;
        const margin = 50;
        let yPosition = height - margin;
        // Split text into lines and add to PDF
        const lines = modifiedText.split('\n');
        for (const line of lines){
            if (yPosition < margin) {
                // Add new page if needed
                const newPage = newPdfDoc.addPage([
                    595,
                    842
                ]);
                yPosition = newPage.getSize().height - margin;
            }
            page.drawText(line.slice(0, 80), {
                x: margin,
                y: yPosition,
                size: fontSize
            });
            yPosition -= fontSize + 4;
        }
        const pdfBytes = await newPdfDoc.save();
        return Buffer.from(pdfBytes);
    } catch (error) {
        console.error('Error applying change to PDF:', error);
        throw new Error('Failed to apply change to PDF');
    }
}
/**
 * Apply text replacement in DOCX
 */ async function applyChangeToDocx(docxBuffer, originalText, suggestedText) {
    try {
        // Extract HTML from DOCX
        const result = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mammoth$2f$lib$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].convertToHtml({
            buffer: docxBuffer
        });
        let htmlContent = result.value;
        // Apply text replacement
        const regex = new RegExp(originalText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        htmlContent = htmlContent.replace(regex, suggestedText);
        // Convert back to DOCX
        // Parse HTML and create DOCX structure using JSDOM
        const dom = new __TURBOPACK__imported__module__$5b$externals$5d2f$jsdom__$5b$external$5d$__$28$jsdom$2c$__cjs$29$__["JSDOM"](htmlContent);
        const textContent = dom.window.document.body.textContent || '';
        const paragraphs = textContent.split('\n').filter((p)=>p.trim()).map((p)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Paragraph"]({
                children: [
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextRun"](p.trim())
                ]
            }));
        const wordDoc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Document"]({
            sections: [
                {
                    properties: {},
                    children: paragraphs.length > 0 ? paragraphs : [
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Paragraph"]({
                            children: [
                                new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TextRun"]('')
                            ]
                        })
                    ]
                }
            ]
        });
        const buffer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$docx$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Packer"].toBuffer(wordDoc);
        return Buffer.from(buffer);
    } catch (error) {
        console.error('Error applying change to DOCX:', error);
        throw new Error('Failed to apply change to DOCX');
    }
}
async function POST(request) {
    try {
        // Get authenticated user
        const { userId } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$clerk$2f$nextjs$2f$dist$2f$esm$2f$app$2d$router$2f$server$2f$auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["auth"])();
        if (!userId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        const body = await request.json();
        const { documentId, originalText, suggestedText, suggestionId, fileType, documentData } = body;
        // Validate input
        if (!documentId || !originalText || !suggestedText) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Missing required fields: documentId, originalText, suggestedText'
            }, {
                status: 400
            });
        }
        // Verify user owns the document
        const document = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getDocumentWithSuggestions"])(documentId, userId);
        if (!document) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Document not found or access denied'
            }, {
                status: 404
            });
        }
        let modifiedDocumentUrl;
        // If document data is provided, apply the change
        if (documentData && fileType) {
            try {
                // Decode base64 document data
                const buffer = Buffer.from(documentData.split(',')[1] || documentData, 'base64');
                let modifiedBuffer;
                if (fileType === 'pdf') {
                    // Apply change to PDF using PDF→DOCX→PDF workflow
                    modifiedBuffer = await applyChangeToPdf(buffer, originalText, suggestedText);
                    const base64 = modifiedBuffer.toString('base64');
                    modifiedDocumentUrl = `data:application/pdf;base64,${base64}`;
                } else if (fileType === 'docx') {
                    // Apply change to DOCX
                    modifiedBuffer = await applyChangeToDocx(buffer, originalText, suggestedText);
                    const base64 = modifiedBuffer.toString('base64');
                    modifiedDocumentUrl = `data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,${base64}`;
                }
            } catch (error) {
                console.error('Error processing document:', error);
            // Continue without modified document URL
            }
        }
        // Update suggestion in database if suggestionId is provided
        // Note: In a full implementation, you might want to add an isApplied field to the schema
        // For now, we'll just log the application
        if (suggestionId) {
            try {
                // Try to find and update the suggestion
                // Since the current schema doesn't have isApplied, we'll just update the suggestedFix
                // Pass documentId to verify the suggestion belongs to this document
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$db$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["updateSuggestion"])(suggestionId, {
                    suggestedFix: suggestedText
                }, documentId);
                console.log('✅ Updated suggestion in database:', suggestionId);
            } catch (dbError) {
                console.error('❌ Database error updating suggestion:', dbError);
            // Log the error but continue - the document update was successful
            // This allows the user to apply changes even if the suggestion record is missing
            }
        }
        // Simulate processing delay
        await new Promise((resolve)=>setTimeout(resolve, 100));
        // Mock: Deduct balance for applying change (0.01 credits per change)
        const costPerChange = 0.01;
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            documentId,
            appliedChange: {
                from: originalText,
                to: suggestedText,
                suggestionId
            },
            modifiedDocumentUrl,
            cost: costPerChange,
            message: 'Change applied successfully'
        });
    } catch (error) {
        console.error('Error applying change:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            error: 'Failed to apply change',
            details: error instanceof Error ? error.message : String(error)
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__9aadd690._.js.map